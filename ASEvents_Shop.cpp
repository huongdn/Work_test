//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ASEvents_Shop.h"
#include "ASEvents_Weapons.h"
#include "ASEvents_Avatar.h"
#include "Multiplayer/EloLeaderboard.h"
#include "ASEvents.h"
#include "ASUtils.h"
#include "ASEvents_IGM.h"
#include "ASEvents_Weapons.h"
#include "ASEvents_Multiplayer.h"
#include "ASEvents_Subscription.h"
#include "ASEvents_ClanBattlepass.h"
#include "Game/Utils/Utils.h"
#include "OnlineManagers/AHCheatCommands.h"
#include "Generic/Strings/StringsManager.h"
#include <gameswf/ui/flashfx.h>
#include <gameswf/swf/character_handle.h>
#include "gameswf/as_classes/as_array.h"
#include <gameswf/gameswf.h>
#include "Multiplayer/MultiplayerCredits.h"
#include "CRM/CrmStrings.h"
#include "Application.h"
#include "GameStates/GameStates.h"
#include "Configs/Demo.h"
#include "GameServerMessages.h"

#include "EventsEnum.h"
#include "Game/Level/Level.h"
#include "Gameplay/Core/Weapons/WeaponManager.h"
#include "Gameplay/Core/Weapons/WeaponComponent.h"
#include "Gameplay/Core/Components/Player/PlayerComponent.h"
#include "Generic/StateMachine/SMExecutor.h"
#include "Generic/Strings/StringsManager.h"
#include "Generic/Tracking/GlotManager.h"

#include "AutoGenerated/strings/MAIN.h"
#include "AutoGenerated/zone/ComponentAttachment.h"
#include "AutoGenerated/zone/ComponentTemplates.h"
#include "AutoGenerated/zone/ComponentWeapon.h"
#include "AutoGenerated/tuning/ArmoryParams.h"

#include "Gameplay/Core/Weapons/Armory.h"
#include "Game/Shop/PlayerProfile.h"

#include "Gameplay/Core/Rewards/RewardsManager.h"
#include "Gameplay/Core/Rewards/DailyManager.h"

#include "Game/Events/EvMenuCmd.h"
#include "Gameplay/Core/EventsManager/EventManager.h"

#include "Gameplay/Core/Objects/Camera/CameraManager.h"
#include "Gameplay/Core/Objects/Camera/GameCameraComponent.h"

#include "Menus/Menu/MenuManager.h"
#include "Menus/Menu/HighlightManager.h"

#include "Game/Shop/NotificationsManager.h"
#include "OnlineManagers/OnlineManager.h"
#include "OnlineManagers/IapManager.h"
#include "OnlineManagers/CRMManager.h"
#include "OnlineManagers/SEMEvents/SemEventHelper.h"
#include "Game/Utils/Utils.h"
#include "AutoGenerated/strings/MAIN.h"
#include "Game/Shop/ShopManager.h"
#include "Game/Shop/ShopNames.h"
//#include "OnlineManagers/GLAdsManager.h"

#include "Missions/EventsDataManager.h"
#include "Weapons/WeaponDataManager.h"
#include "Tutorials/TutorialManager.h"
#include "Multiplayer/PvpDataManager.h"

#include "FakeSmallMap.h"
#if GAMELOFT_SHOP
#	include "FrameworkUtils.h"
#endif
#ifdef OS_ANDROID
#include "OnlineManagers/SocialLibManager.h"
extern bool m_Subscription_account;//ledien
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForShopData()
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_SHOP_DATA))
	{
		return;
	}
	auto fxPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(fxPlayer);

	{
		// --- tutorial (if any active)
		AddActiveMenuTutorialInfo(data);
	}

	{
		// --- offers
		auto offers = swfnew gameswf::ASArray(fxPlayer);
		data->setMemberByName("offers", offers);

		auto weaponOffers = GetShopManager()->GetOffersInCategory(SHOP_ITEM_CATEGORY_WEAPON);

		data->setMemberByName("snipersPromo", false);
		data->setMemberByName("assaultsPromo", false);
		data->setMemberByName("exoticsPromo", false);

		auto fillWeaponData = [fxPlayer, data](StringHash weaponId, bool showcase)
		{
			auto offer = swfnew gameswf::ASObject(fxPlayer);

			auto weaponClass = WeaponDataManager()->GetWeaponClass(weaponId);
			auto weaponClassName = WeaponDataManager()->GetWeaponClassInternalName(weaponClass);

			offer->setMemberByName("id", (int)weaponId.GetHash());
			offer->setMemberByName("weaponId", (int)weaponId.GetHash());
			const char* name = WeaponDataManager()->GetWeaponName(weaponId);
			if (name)
				offer->setMemberByName("displayName", FormatUnicodeText(name));
			offer->setMemberByName("internalName", WeaponDataManager()->GetWeaponIcon(weaponId));
			offer->setMemberByName("weaponClass", weaponClassName);

			auto charges = ConstructChargesInfo(fxPlayer, weaponId, nullptr);
			if (charges)
				offer->setMemberByName(KSTR("charges"), charges);

			AddWeaponModifiersInfo(offer, weaponId);

			bool hasRedirect = SetOfferRedirectionFromExtraCategory(weaponId, offer);

			gameswf::ASObject* specOffer = nullptr;
			if (!hasRedirect)
			{
				auto cost = ConstructCostInfo(fxPlayer, weaponId, &specOffer);
				offer->setMemberByName("cost", cost);
			}
			if (!showcase)
				return offer;

			Weapons_AddWeaponRegionInterval(offer, weaponId);

			if (specOffer)
			{
				offer->setMemberByName("specialOffer", specOffer);

				std::string promo_bool = weaponClassName;
				std::transform(promo_bool.begin(), promo_bool.end(), promo_bool.begin(), ::tolower);
				promo_bool += "sPromo";
				data->setMemberByName(promo_bool.c_str(), true);
			}
			else
			{
				specOffer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("specialOffer", specOffer);
			}

			return offer;
		};

		typedef std::vector<std::pair<gameswf::ASObject*, int>> specialOffersT;
		specialOffersT specialOffers;
		for (const auto weapOff : weaponOffers)
		{
			const auto& weaponOffer = *weapOff;
			if (PLAYER_PROFILE()->GetInventory().GetShopItem(weaponOffer.id.GetHash()) != 0 && PLAYER_PROFILE()->GetInventory().ItemExpiry(weaponOffer.id.GetHash()) == 0)	// --- already owned and not rented
				continue;

			bool hasRedirect = SetOfferRedirectionFromExtraCategory(weaponOffer.id, nullptr);

			if (!hasRedirect)
			{
				// --- only send offers with discounts
				if (std::none_of(weaponOffer.inItem.begin(), weaponOffer.inItem.end(), [&](const CShopManager::ShopItemQty& price)
					{
						return std::any_of(weaponOffer.inItemReplaced.begin(), weaponOffer.inItemReplaced.end(), [&](const CShopManager::ShopItemQty& entry)
							{
								return entry.item == price.item && entry.qty > price.qty;
							});
					}))
					continue;
			}

			int order = 0;
			bool skip = false;
			for (auto xtraHash : weaponOffer.xtra)
			{
				static const std::string xtra_part("min_parts=");
				static const std::string min_region("min_region=");

				const auto& categStr = GetShopManager()->Hash2Name(xtraHash);
				if (categStr.empty())
					continue;

				if (categStr == "no_showcase")
				{
					skip = true;
					break;
				}

				if (categStr.find(xtra_part) == 0)
				{
					// --- found an extra category, parse it
					int parts = atoi(&categStr.at(xtra_part.length()));
					if (parts)																	// --- valid min parts value found
					{
						auto partCreditId = WeaponDataManager()->GetWeaponPartCreditId(weaponOffer.id);
						if (PLAYER_PROFILE()->GetInventory().GetShopItem(partCreditId) < parts)	// --- remove if we have less than "parts" parts for this weapon
							skip = true;
					}
				}

				if (categStr.find(min_region) == 0)
				{
					int region = atoi(&categStr.at(min_region.length()));
					int maxChapterUnlocked = PLAYER_PROFILE()->GetCurrentChapter() + 1;
					if (maxChapterUnlocked < region)
						skip = true;
				}

				if (sscanf(categStr.c_str(), "%d", &order) == 1)
				{
					break;
				}
				order = 0;
			}

			if (skip)
			{
				bool hasPromo;
				ConstructCostInfo(nullptr, weaponOffer.id, nullptr, &hasPromo);
				if (hasPromo)
				{
					auto weaponClass = WeaponDataManager()->GetWeaponClass(weaponOffer.id);
					auto weaponClassName = WeaponDataManager()->GetWeaponClassInternalName(weaponClass);
					std::string promo_bool = weaponClassName;
					std::transform(promo_bool.begin(), promo_bool.end(), promo_bool.begin(), ::tolower);
					promo_bool += "sPromo";
					data->setMemberByName(promo_bool.c_str(), true);
				}
				continue;
			}

			auto offer = fillWeaponData(weaponOffer.id, true);
			specialOffers.push_back(std::make_pair(offer, order));
		}

		if (specialOffers.empty())	// --- choose a weapon per day
		{
			auto profile = PLAYER_PROFILE();
			auto weapons = profile->GetNotOwnedWeapons();
			mcfwutil::fsmap<weapon_class_key_t, float> damage_map;

			// --- remove all weapons that we own or that are weaker than our best weapon of its class or have no price or are priced in sc
			weapons.erase(
				std::remove_if(weapons.begin(), weapons.end(), [&](weapon_key_t weapon)
					{
						if (profile->GetInventory().GetShopItem(weapon) != 0)
							return true;

						auto offer = GetShopManager()->FindShopOffer(weapon);
						if (!offer || offer->inItem.empty())
							return true;

						if (std::find_if(offer->inItem.begin(), offer->inItem.end(), [](const CShopManager::ShopItemQty& price)
							{
								return price.item == StringHash("sc") || price.item == StringHash("weapon_part");
							}) != offer->inItem.end())
							return true;

							auto weaponClass = WeaponDataManager()->GetWeaponClass(weapon);
							auto& damage = damage_map[weaponClass];	// --- silent insert from hell
							if (!damage)
							{
								auto classWeapons = WeaponDataManager()->GetWeaponsByClass(weaponClass);
								auto it = std::max_element(classWeapons.begin(), classWeapons.end(), [profile](weapon_key_t weapon1, weapon_key_t weapon2)
									{
										bool owned1 = profile->GetInventory().GetShopItem(weapon1) != 0;
										bool owned2 = profile->GetInventory().GetShopItem(weapon2) != 0;

										float damage1 = owned1 * profile->GetWeaponAttributeValue(weapon1, "Power");
										float damage2 = owned2 * profile->GetWeaponAttributeValue(weapon2, "Power");

										return damage1 < damage2;
									});
								if (it != classWeapons.end())
									damage = profile->GetWeaponMinPower(*it);
							}
							return profile->GetWeaponMinPower(weapon) < damage;
					}),
				weapons.end());

			if (!weapons.empty())
			{
				time_t now = GetShopManager()->GetServerTime();
				auto gm = localtime(&now);
				auto weapon = weapons[gm->tm_yday % weapons.size()];

				auto offer = fillWeaponData(weapon, false);
				offers->push(offer);
			}
		}
		else	// --- sort offers
		{
			std::sort(specialOffers.begin(), specialOffers.end(), [](const specialOffersT::value_type& p1, const specialOffersT::value_type& p2) { return p1.second < p2.second; });
			for (const auto& it : specialOffers)
			{
				offers->push(it.first);
			}
		}

		bool gachaPromo = GetShopManager()->CategoryHasPromo(GetShopManager()->GetBattlepackOfferCategory().c_str()) != 0 ||
			(GetShopManager()->UseGachaKeys() && (GetShopManager()->CategoryHasPromo("pack_gacha_key") != 0 || GetShopManager()->CategoryHasPromo("pack_gacha_key_arena") != 0)) ||
			GetShopManager()->HasIAPCategoryPromo("gacha");
		data->setMemberByName("battlepacksPromo", gachaPromo);

		auto bundlesPromo = GetShopManager()->FindBundlesPromo();
		data->setMemberByName("bundlesPromo", bundlesPromo != 0);

		// --- check for unopened battlepacks
		data->setMemberByName(KSTR("battlepacksUnread"), GetShopManager()->FindTopBarUnopenedBattlepacks() != 0);
	}

	// --- battlepacks timer
	{
		auto seconds = Shop_ComputeAndSendBattlepacksInitData(false, BattlepackType::Ordinary);
		if (seconds > 0)
		{
			auto battlepacks = swfnew gameswf::ASObject(fxPlayer);
			auto timeLeft = ConstructTimeLeft(seconds, fxPlayer);
			if (timeLeft)
			{
				data->setMemberByName("battlepacks", battlepacks);
				battlepacks->setMemberByName("timeLeft", timeLeft);
			}
		}
	}

	// --- bm time left until auto refresh & refresh notification
	{
		const auto& bmData = PLAYER_PROFILE()->GetProfileBlackMarketData();
		time_t now = GetShopManager()->GetServerTime();

		auto swfBmData = swfnew gameswf::ASObject(fxPlayer);
		data->setMemberByName("blackMarket", swfBmData);

		data->setMemberByName("unreadBlackMarket", NOTIFICATIONS()->CheckNotificationFromInfo("bm", "refresh") ? 1 : 0);

		int hh_timeleft = bmData.happyHourEnd() - now;
		auto hh_active = hh_timeleft > 0;
		if (hh_active)
		{
			auto hh_offer = GetShopManager()->FindShopOffer("bm_1");
			hh_active = hh_offer && !hh_offer->inItem.empty() && !hh_offer->outItems.empty();
		}
		data->setMemberByName("unreadHappyHour", hh_active ? 1 : 0);

		if (hh_active)
		{
			auto timeLeft = ConstructTimeLeft(hh_timeleft, fxPlayer);
			swfBmData->setMemberByName("timeLeft", timeLeft);
		}
		else
		{
			auto swfBmTimeLeft = ConstructTimeLeft((int)(bmData.autoRefreshTs() - now), fxPlayer);
			swfBmData->setMemberByName("timeLeft", swfBmTimeLeft);
		}
	}

	int currentRegion = PLAYER_PROFILE()->GetCurrentChapter() + 1;
	data->setMemberByName("currentRegion", currentRegion);

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_SHOP_DATA, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForShopData(const gameswf::ASNativeEventState& eventState)
{
	Shop_onAskForShopData();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_SendShopSpecialOffers()
{
	Shop_onAskForShopData();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

enum E_CustomTimer { E_CT_No, E_CT_Valid, E_CT_Expired };
static E_CustomTimer HasCustomTimer(int itemIdx)
{
	const auto crmi = IAP()->GetCRMItem(itemIdx);
	auto customTimerField = crmi->GetPromotionEndTime();
	if (customTimerField)
	{
		time_t utc_time = 0;
		if (CShopManager::parse_time(customTimerField, utc_time))
		{
			return (int64)utc_time > GetShopManager()->GetServerTime() ? E_CT_Valid : E_CT_Expired;
		}
	}
	return E_CT_No;
}

int ComputeCustomTimer(int itemIdx)
{
	int customTimer = 0;
	const auto crmi = IAP()->GetCRMItem(itemIdx);
	auto customTimerField = crmi->GetPromotionEndTime();
	if (customTimerField)
	{
		time_t utc_time = 0;
		if (CShopManager::parse_time(customTimerField, utc_time))
		{
			customTimer = (int64)utc_time - (int64)GetShopManager()->GetServerTime();
		}
	}
	return customTimer;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool BundleHasExtracategory(const Json::Value& extra_category, const char* tag)
{
	for (const auto& v : extra_category)
	{
		const std::string& categ = v.asString();
		if (categ == tag)
		{
			return true;
		}
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

std::string GetBundleExtraCategoryValue(const Json::Value& extra_category, const char* tag)
{
	for (const auto& v : extra_category)
	{
		const std::string& categ = v.asString();
		auto idx = categ.find(tag);
		if (idx == 0)
		{
			return categ.substr(strlen(tag));
		}
	}
	return "";
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

std::string GetBundleXtraCategoryValue(const CShopManager::ShopOffer& offer, const char* tag)
{
	for (const auto& v : offer.xtra)
	{
		const std::string& categ = GetShopManager()->Hash2Name(v);
		auto idx = categ.find(tag);
		if (idx == 0)
		{
			return categ.substr(strlen(tag));
		}
	}
	return "";
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_BundlesCheckAdd3DContent(gameswf::ASObject* swfItem, const std::vector<StringHash>& content)
{
	// --- for now only display 3D shop objects for:
	// --- - bundles which contain all of a gearset's pieces (and only those)
	// --- - bundles which contain a gearset (arena / survival) and only that gearset
	if (content.empty())
		return;

	auto firstItem = GetShopManager()->FindShopItem(content.front());
	if (!firstItem)
		return;

	auto addSwfContent = [&swfItem](const char* label, StringHash id)
	{
		auto content3D = swfnew gameswf::ASObject(swfItem->getPlayer());
		swfItem->setMemberByName("content3D", content3D);

		content3D->setMemberByName(label, (int)id.GetHash());
	};

	if (firstItem->category == StringHash(SHOP_ITEM_CATEGORY_AVATAR_GEARSET) &&
		content.size() == 1)
	{
		addSwfContent("gearset", firstItem->id);
	}
	else if (firstItem->category == SHOP_ITEM_CATEGORY_AVATAR_MODULE)
	{
		const auto& mp_data = GetShopManager()->GetMultiplayerData();
		auto setId = mp_data.AvatarModuleSet(firstItem->id);
		if (!setId)
			return;

		auto setData = mp_data.AvatarSet(setId);

		// check if there's any item are Time
		bool hasTimeItem = false;
		for (auto item : content)
		{
			if (item == StringHash(SHOP_ITEM_CATEGORY_TIME))
			{
				hasTimeItem = true;
				break;
			}
		}
		// if have Time, size -= 1
		if ((setData.pieces() != (int)content.size() && !hasTimeItem) || (setData.pieces() != (int)content.size() - 1 && hasTimeItem))
			return;

		for (auto pieceId : content)
		{
			if (pieceId != StringHash(SHOP_ITEM_CATEGORY_TIME))
			{
				auto pieceSetId = mp_data.AvatarModuleSet(pieceId);
				if (pieceSetId != setId)
					return;
			}
		}

		addSwfContent("gearset", setId);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* CreateBundleIAPItem(int itemIdx, const Json::Value& extra_category, gameswf::Player* fxPlayer, BundleListFlags flags = BundleListFlags::None)
{
	const auto crmi = IAP()->GetCRMItem(itemIdx);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
	if (crmi->IsHidden())
		return nullptr;
#endif

	if (crmi->GetBillingMethodCount() < 1)
		return nullptr;

	// --- check for subscriptions
	StringHash isSubscription = IAP()->GetBundleOldSubscription(itemIdx);
	auto sub_data = GetShopManager()->GetOldSubscriptionData(isSubscription);

	const std::string& type = crmi->GetType();
	if (!isSubscription && !crmi->HasBundleItems())
		return nullptr;

	// --- check if item is already owned
	if (!isSubscription && GetShopManager()->ShouldHideBundle(IAP()->GetItemHashId(crmi)))
		return nullptr;

	auto itemSwf = swfnew gameswf::ASObject(fxPlayer);
	bool hasPromoOff = true;

#if USE_IN_APP_BILLING  && !USE_IN_APP_BILLING_CRM
	itemSwf->setMemberByName("id", crmi->GetUid());
	itemSwf->setMemberByName("art", crmi->getIconSavePath());
#else
	if (isSubscription)
	{
		itemSwf->setMemberByName("id", crmi->GetEntryId());
	}
	else
	{
		itemSwf->setMemberByName("id", (int)StringHash(crmi->GetEntryId()).GetHash());
	}
	itemSwf->setMemberByName("art", crmi->GetIconName());
#endif
	itemSwf->setMemberByName("name", crmi->GetName());
	if (flags & BundleListFlags::ShopV2)
		itemSwf->setMemberByName("title", crmi->GetName());

	int remaining = crmi->GetRemainingPurchaseCount();
	if (remaining > 0)
	{
		itemSwf->setMemberByName("stock", remaining);
	}

	if (flags & BundleListFlags::ShopV2)
	{
		// --- default is medium, overridable from extra category
		itemSwf->setMemberByName("size", "medium");
	}

	bool has_energy_bonus_flag = false;
	//custom sorting and custom pointcuts from extra category
	auto ex = crmi->GetExtendedField("category");
	if (ex.IsValid() && ex.IsJSON())
	{
		const static std::string customPointcut = "use_pointcut=";
		const static std::string priceOff = "price_cut";
		const static std::string valuex = "value=x";

		for (const auto& v : extra_category)
		{
			auto place = std::strtol(v.asCString(), nullptr, 10);
			if (place > 0)
			{
				//items_ixs.back().second = place;
				itemSwf->setMemberByName("customListPlace", (int)place);
			}

			const std::string& categ = v.asString();
			if (categ.find(customPointcut) == 0)
			{
				const std::string pointcutToUse = categ.substr(customPointcut.length());
				itemSwf->setMemberByName("infoPointcut", pointcutToUse.c_str());
			}
			if (categ == "energy_bonus")
			{
				has_energy_bonus_flag = true;
			}
			if (categ == "chain_offer")
			{
				itemSwf->setMemberByName("category", "chain_offer");
				itemSwf->setMemberByName("chainIndex", IAP()->GetChainIndex(itemIdx));
				if (crmi->GetCampaignSpecificId() == IAP()->GetChainStartName(crmi->GetCampaignSpecificId()))
				{
					itemSwf->setMemberByName("isChainStart", true);
				}
				else
				{
					itemSwf->setMemberByName("isChainStart", false);
				}
			}

			if (categ == "mystery")
			{
				itemSwf->setMemberByName("mystery", true);
			}

			if (categ.find(valuex) == 0)
			{
				double x = atof(categ.c_str() + valuex.length());
				if (x > 1)
				{
					double price = crmi->GetRegularPriceValue();
					if (!price)
						price = crmi->GetPriceValue();
					std::string currency = crmi->GetBillingMethod(0)->GetCurrencySymbol();
					std::string currencyISO = crmi->GetBillingMethod(0)->GetCurrency();
					auto val = _round(price * x);

					auto priceStr = IAP()->GetItemDisplayPrice(crmi);
					std::string valueStr(std::to_string(val));

					int n = priceStr.find(currency);
					if (n != priceStr.npos)
					{
						if (n == 0)
						{
							valueStr = currency + " " + valueStr;
						}
						else
						{
							valueStr += " " + currency;
						}
					}
					else
					{
						n = priceStr.find(currencyISO);
						if (n == 0)
						{
							valueStr = currencyISO + " " + valueStr;
						}
						else
						{
							valueStr += " " + currencyISO;
						}
					}

					itemSwf->setMemberByName("valuex", valueStr.c_str());
				}
			}

			if (categ.find(priceOff) == 0)
				hasPromoOff = false;

			static const std::string bin_xtra("Bundle:");
			if (categ.find(bin_xtra) == 0)
			{
				itemSwf->setMemberByName("internalName", categ.c_str() + bin_xtra.length());
			}

			static const std::string rarity_xtra("rarity=");
			if (categ.find(rarity_xtra) == 0)
			{
				itemSwf->setMemberByName("rarity", categ.c_str() + rarity_xtra.length());
			}

			static const std::string size_xtra("size=");
			if (categ.find(size_xtra) == 0)
			{
				itemSwf->setMemberByName("size", categ.c_str() + size_xtra.length());
			}
		}
	}

	gameswf::ASObject* swfContent = nullptr;
	if (flags & BundleListFlags::ShopV2)
	{
		swfContent = swfnew gameswf::ASObject(fxPlayer);
		itemSwf->setMemberByName(KSTR("content"), swfContent);
	}

	if (!isSubscription || !sub_data || !sub_data->active)	// --- no promotions for active subscriptions
	{
		auto cost = swfnew gameswf::ASObject(fxPlayer);
		itemSwf->setMemberByName("cost", cost);
		auto money = swfnew gameswf::ASObject(fxPlayer);
		cost->setMemberByName("money", money);
		money->setMemberByName("value", IAP()->GetItemDisplayPrice(crmi).c_str());
		// Fix bug [SFQA-3118] Bundles promo timer appear even when the timer is not set on CROM
		//bool showTimer = false;
		if (crmi->HasPricePromotion())
		{
			money->setMemberByName("oldValue", IAP()->GetItemReplacedDisplayPrice(crmi).c_str());
			//showTimer = true;
		}
		itemSwf->setMemberByName("currency", "money");
		itemSwf->setMemberByName("num", crmi->GetPriceValue());

		if (GetShopManager()->FindShopOffer(StringHash("vip_tickets_earn")))
		{
			auto tier = crmi->GetExtendedField("tier").ToString();
			auto tickets = GetShopManager()->GetMultiplayerData().GetIAPTickets(tier);
			if (tickets > 0)
				itemSwf->setMemberByName("bonusTicket", std::to_string(tickets).c_str());
		}

		// --- timer
		int customTimer = isSubscription ? 0 : ComputeCustomTimer(itemIdx);
		if (customTimer > 0)
		{
			auto tl = (customTimer > 0) ? ConstructTimeLeft(customTimer, fxPlayer) : ConstructIAPTimeLeft(fxPlayer);
			if (tl)
			{
				itemSwf->setMemberByName("timeLeft", tl);
			}
		}

		// --- promo more / off
		if (hasPromoOff)
		{
			auto specialOffer = ConstructOffIAPPromo(crmi, fxPlayer);
			if (specialOffer)
			{
				itemSwf->setMemberByName("specialOffer", specialOffer);
			}
		}
	}

	if (isSubscription)
	{
		auto subscription = swfnew gameswf::ASObject(fxPlayer);
		itemSwf->setMemberByName(KSTR("subscription"), subscription);

		if (sub_data)
		{

#ifdef OS_ANDROID
			if (!(GetSocialLibManager()->m_loginSNS[SNS_GAME_API].isLoggedIn) && (m_Subscription_account == 1))
			{
				subscription->setMemberByName(KSTR("active"), 1);
			}
			else

#endif	
			{
				subscription->setMemberByName(KSTR("active"), sub_data->active.Get());
			}
			subscription->setMemberByName(KSTR("showInfo"), sub_data->type != CShopManager::ESTF_STEALTH);

			//
			auto reward = swfnew gameswf::ASObject(fxPlayer);
			subscription->setMemberByName(KSTR("reward"), reward);
			auto hc1 = swfnew gameswf::ASObject(fxPlayer);
			reward->setMemberByName(GetShopManager()->Hash2Name(sub_data->currency.GetHash()).c_str(), hc1);
			hc1->setMemberByName(KSTR("value"), sub_data->init_qty.Get());

			auto dailyReward = swfnew gameswf::ASObject(fxPlayer);
			subscription->setMemberByName(KSTR("dailyReward"), dailyReward);
			auto hc2 = swfnew gameswf::ASObject(fxPlayer);
			dailyReward->setMemberByName(GetShopManager()->Hash2Name(sub_data->currency.GetHash()).c_str(), hc2);
			hc2->setMemberByName(KSTR("value"), sub_data->daily_qty.Get());

			auto hc3 = swfnew gameswf::ASObject(fxPlayer);
			subscription->setMemberByName(GetShopManager()->Hash2Name(sub_data->currency.GetHash()).c_str(), hc3);
			if (sub_data->active.Get())
			{
				hc3->setMemberByName(KSTR("value"), sub_data->daily_qty.Get() * sub_data->days.Get());
			}
			else
			{
				hc3->setMemberByName(KSTR("value"), sub_data->daily_qty.Get() * sub_data->init_days.Get() + sub_data->init_qty);
			}

			subscription->setMemberByName(KSTR("daysLeft"), sub_data->days.Get());

			// --- timer
			// --- we do not support timer for subscriptions for now
			//int customTimer = ComputeCustomTimer(itemIdx);
			//if (customTimer > 0)
			//{
			//	auto tl = ConstructTimeLeft(customTimer, fxPlayer);
			//	if (tl)
			//	{
			//		itemSwf->setMemberByName("timeLeft", tl);
			//	}
			//}

			if (GetShopManager()->GetEnergyBonusMinQty() && has_energy_bonus_flag)
			{
				auto energyShopItem = GetShopManager()->FindShopItem("energy");
				auto energyBonusOffer = GetShopManager()->FindShopOffer("energy_slot");
				if (energyBonusOffer && !energyBonusOffer->outItems.empty())
					itemSwf->setMemberByName("energyBonus", energyBonusOffer->outItems.front().qty.Get());
			}
		}
		else
		{
			return nullptr;
		}
	}
	else
	{
		// --- check if there are any weapons, make sure to put them first in case there are
		ShopVector<ShopItemQty>::type outItems;
		if ((flags & BundleListFlags::ShopV2) && crmi->GetBundleItemCount() > 1)
		{
			outItems.reserve(crmi->GetBundleItemCount());
			for (int j = 0; j < crmi->GetBundleItemCount(); ++j)
			{
				auto bItem = crmi->GetBundleItem(j);
				outItems.emplace_back(StringHash(bItem->GetType()), SecuredIntMin(bItem->GetAmount()));
			}

			std::stable_sort(outItems.begin(), outItems.end(), [](const ShopItemQty& s1, const ShopItemQty& s2)
				{
					auto si1 = GetShopManager()->FindShopItem(s1.item);
					auto si2 = GetShopManager()->FindShopItem(s2.item);
					return si1 && si1->category == StringHash(SHOP_ITEM_CATEGORY_WEAPON) &&
						(!si2 || si2->category != StringHash(SHOP_ITEM_CATEGORY_WEAPON));
				});
		}

		BundleListArray bla(fxPlayer, SwfCards::WeaponModifiers);
		if (!outItems.empty())
		{
			for (const auto& entry : outItems)
				bla.AddItem(entry.item, entry.qty);
		}
		else
		{
#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID //truong.px4 add fix compile GAND
			for (int j = 0; j < crmi->GetBundleItemCount(); ++j)
			{
				auto bItem = crmi->GetBundleItem(j);
				bla.AddItem(StringHash(bItem->GetType()), bItem->GetAmount());
			}
#endif
		}

		auto list = bla.GetArray();
		if (list)
		{
			if ((flags & BundleListFlags::ShopV2) && swfContent)
				swfContent->setMemberByName(KSTR("cards"), list);
			else
				itemSwf->setMemberByName("list", list);
		}

		// --- check if we should display any 3D content instead of cards
		std::vector<StringHash> content;
		content.reserve(crmi->GetBundleItemCount());

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID //truong.px4 add fix compile GAND
		for (int j = 0; j < crmi->GetBundleItemCount(); ++j)
		{
			auto bItem = crmi->GetBundleItem(j);
			content.emplace_back(StringHash(bItem->GetType()));
		}
		Shop_BundlesCheckAdd3DContent(itemSwf, content);
#endif
	}

	//	auto debugstr = gameswf::toJsonValue(itemSwf).toStyledString();
	//	debugstr = debugstr;

	return itemSwf;
}

auto Shop_GetIAPGift(const Json::Value& array) -> std::pair<int, std::string>
{
	std::pair<int, std::string> ret(0, "");

	if (!array.isArray() || array.empty())
		return ret;

	const static std::string iap_gift[] = { "iap_gift=", "iap_gift_bronze=", "iap_gift_silver=", "iap_gift_gold=" };
	const static std::string gift_type[] = { "bronze", "bronze", "silver", "gold" };
	for (const auto& key : array)
	{
		auto categ = key.asString();
		auto it = std::find_if(std::begin(iap_gift), std::end(iap_gift), [&categ](const std::string& str) { return categ.find(str) == 0; });
		if (it == std::end(iap_gift))
			continue;

		ret.second = gift_type[std::distance(std::begin(iap_gift), it)];
		ret.first = atoi(categ.c_str() + (*it).length());
		break;
	}
	return ret;
};

gameswf::ASObject* Shop_CreateIAPGift(int giftID, const std::string& giftName, gameswf::Player* fxPlayer)
{
	StringHash offerId = Hash("iap_gift_", std::to_string(giftID).c_str());
	auto offer = GetShopManager()->FindShopOffer(offerId);
	if (offer)
	{
		auto gift = swfnew gameswf::ASObject(fxPlayer);

		gift->setMemberByName(KSTR("id"), giftID);
		gift->setMemberByName(KSTR("internalName"), giftName.c_str());
		BundleListArray bla(fxPlayer);
		for (const auto& k : offer->outItems)
		{
			bla.AddItem(k.item, k.qty);
		}
		auto list = bla.GetArray();
		if (list)
			gift->setMemberByName("list", list);

		return gift;
	}

	return nullptr;
}

gameswf::ASObject* CreateIAPItem(int itemIdx, const Json::Value& extra_category, bool hasPromo, double smallest_price, int smallest_amount, gameswf::Player* fxPlayer, bool skipShowSubcription, bool shopV2 = false)
{
	const auto crmi = IAP()->GetCRMItem(itemIdx);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
	if (crmi->IsHidden())
		return nullptr;
#endif

#if defined(OS_ANDROID) && USE_IN_APP_BILLING_CRM //subscription tam.dnn add
	std::string content_id;
	if (crmi->GetBillingMethodCount() > 0)
		content_id = crmi->GetBillingMethod(0)->GetExtendedField("content_id").ToString();
	if (content_id.find("android_nrsubscription") != std::string::npos)
		return nullptr;
	if (content_id.find("android_rsubscription") != std::string::npos && skipShowSubcription)
		return nullptr;
#endif

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
	const std::string& currency = crmi->GetType();
#else
	const std::string& currency = crmi->GetSubType();
#endif

	if (HasCustomTimer(itemIdx) == E_CT_Expired)
		return nullptr;

	StringHash isVipSubscription = IAP()->GetBundleSubscription(itemIdx);
	if (isVipSubscription)
	{
		return Subscription_CreateIAPItem(itemIdx, fxPlayer, 0);
	}

	StringHash isOldSubscription = IAP()->GetBundleOldSubscription(itemIdx);
	if (isOldSubscription || crmi->HasBundleItems())
	{
		return CreateBundleIAPItem(itemIdx, extra_category, fxPlayer);
	}

	gameswf::ASObject* itemSwf = swfnew gameswf::ASObject(fxPlayer);
	gameswf::ASObject* itemSwfContent = shopV2 ? swfnew gameswf::ASObject(fxPlayer) : itemSwf;
	if (shopV2)
	{
		itemSwf->setMemberByName("content", itemSwfContent);
	}

	auto cost = swfnew gameswf::ASObject(fxPlayer);
	itemSwf->setMemberByName("cost", cost);
	auto money = swfnew gameswf::ASObject(fxPlayer);
	cost->setMemberByName("money", money);

	itemSwf->setMemberByName(shopV2 ? "title" : "name", crmi->GetName());
	money->setMemberByName("value", IAP()->GetItemDisplayPrice(crmi).c_str());
	//			itemSwf->setMemberByName("value", crmi->GetAmount());

	if (GetShopManager()->FindShopOffer(StringHash("vip_tickets_earn")))
	{
		auto tier = crmi->GetExtendedField("tier").ToString();
		auto tickets = GetShopManager()->GetMultiplayerData().GetIAPTickets(tier);
		if (tickets > 0)
			itemSwfContent->setMemberByName("bonusTicket", (std::string("+") + std::to_string(tickets)).c_str());
	}

#if USE_IN_APP_BILLING  && !USE_IN_APP_BILLING_CRM
	itemSwf->setMemberByName("id", crmi->GetUid());
	itemSwf->setMemberByName("art", crmi->GetIconName());//truong.px4 add
#else
	itemSwf->setMemberByName("id", crmi->GetEntryId());
	const char* icon = crmi->GetPreviewPath();
#if !defined(OS_W8) && !defined(OS_W10) && !defined(OS_WD)
	if (icon && strstr(icon, "store_item_icon_") == icon)
		icon += strlen("store_item_icon_");
	itemSwfContent->setMemberByName("art", icon);
#else
	if (icon && strstr(icon, "store_item_icon_") == icon)
	{
		icon += strlen("store_item_icon_");
		itemSwfContent->setMemberByName("art", icon);
	}
	//fix wrong icon of iap items for hybrid mode
	else
	{
		std::string tracking_uid = crmi->GetExtendedField("tracking_uid").ToString();
		icon = tracking_uid.c_str();
		if (icon && strstr(icon, "com.gameloft.mcfw.win_") == icon)
			icon += strlen("com.gameloft.mcfw.win_");
		itemSwfContent->setMemberByName("art", icon);
	}
#endif//OS_W8 OS_WD
#endif

	int remaining = crmi->GetRemainingPurchaseCount();
	if (remaining > 0)
	{
		itemSwf->setMemberByName("stock", remaining);
	}


	gameswf::ASObject* qtyval = swfnew gameswf::ASObject(fxPlayer);
#if USE_IN_APP_BILLING  && !USE_IN_APP_BILLING_CRM
	qtyval->setMemberByName("value", crmi->GetAmount() + crmi->GetBonusAmount());//truong.px4 add
#else
	qtyval->setMemberByName("value", crmi->GetAmount());
#endif
	itemSwfContent->setMemberByName(currency.c_str(), qtyval);

	if (GetShopManager()->GetEnergyBonusMinQty() && currency == "hc" && crmi->GetAmount() >= GetShopManager()->GetEnergyBonusMinQty())
	{
		auto energyShopItem = GetShopManager()->FindShopItem("energy");
		auto energyBonusOffer = GetShopManager()->FindShopOffer("energy_slot");
		if (energyBonusOffer && !energyBonusOffer->outItems.empty())
			itemSwfContent->setMemberByName("energyBonus", energyBonusOffer->outItems.front().qty.Get());
	}

	// --- promo
	bool promo = false;
	if (crmi->HasPricePromotion())
	{
		money->setMemberByName("oldValue", IAP()->GetItemReplacedDisplayPrice(crmi).c_str());
		promo = true;
	}
	if (crmi->HasAmountPromotion())
	{
#if USE_IN_APP_BILLING  && !USE_IN_APP_BILLING_CRM
		qtyval->setMemberByName("oldValue", crmi->GetAmount());//truong.px4 add
#else
		qtyval->setMemberByName("oldValue", crmi->GetAmount() - crmi->GetBonusAmount());
#endif
		promo = true;
	}

	int customTimer = ComputeCustomTimer(itemIdx);

	// --- timer
	if (promo || customTimer > 0)
	{
		auto tl = (customTimer > 0) ? ConstructTimeLeft(customTimer, fxPlayer) : ConstructIAPTimeLeft(fxPlayer);
		if (tl)
		{
			itemSwf->setMemberByName("timeLeft", tl);
		}
	}

	auto IsKeyInArray = [](const std::string& key, const Json::Value& array) -> bool
	{
		if (!array.isArray() || array.empty())
			return false;

		Json::Value jkey(key);
		return std::find(array.begin(), array.end(), jkey) != array.end();
	};

	// --- promo more / off
	if (!IsKeyInArray("price_cut", extra_category)) //don't show if extra category contains 'price_cut'
	{
		auto specialOffer = ConstructOffIAPPromo(crmi, fxPlayer);
		if (specialOffer)
		{
			itemSwf->setMemberByName("specialOffer", specialOffer);
		}
	}

	itemSwf->setMemberByName(KSTR("bestValue"), IsKeyInArray("best_value", extra_category));
	itemSwf->setMemberByName(KSTR("mostPopular"), IsKeyInArray("most_popular", extra_category));

	// --- more free
	if (!hasPromo && smallest_amount > 0 && smallest_price > 0)
	{
		int qty = (int)glf::Ceil(smallest_amount / smallest_price * crmi->GetBillingMethod(0)->GetPrice());
		if (qty > 0 && qty < crmi->GetAmount())
		{
			auto more = _round(100.0f * (crmi->GetAmount() - qty) / qty);
			gameswf::ASObject* specialOffer = swfnew gameswf::ASObject(fxPlayer);
			specialOffer->setMemberByName("value", more);
			specialOffer->setMemberByName("type", "free");

			itemSwf->setMemberByName("specialOffer", specialOffer);
		}
	}

	auto iap_gift = Shop_GetIAPGift(extra_category);
	if (iap_gift.first > 0)
	{
		auto gift = Shop_CreateIAPGift(iap_gift.first, iap_gift.second, fxPlayer);
		if (gift)
		{
			itemSwf->setMemberByName(KSTR("gift"), gift);
		}
	}

	auto topupEvents = SemEventManager::Instance()->GetEventsOfType(EVENT_TYPE_TOPUP);
	if (topupEvents.size())
	{
		if (currency == "hc")
		{
			auto pack_name = crmi->GetExtendedField("group").ToString();
			auto score = GetShopManager()->GetMultiplayerData().GetTopupEventScoreFromIAPName(pack_name, "");
			itemSwfContent->setMemberByName("topUpPoints", std::to_string(score).c_str());
		}
	}

	return itemSwf;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace
{

	bool ComputeIAPPromo(const std::string& req_type, double* smallest_price, int* smallest_amount, bool* has_promo)
	{
		bool ret = false;

		*smallest_price = -1;
		*smallest_amount = -1;
		*has_promo = false;

		for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif
			if (crmi->GetBillingMethodCount() < 1)
				continue;

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			const std::string& currency = crmi->GetType();
#else
			const std::string& currency = crmi->GetSubType();
#endif			

			auto subscriptionId = IAP()->GetBundleOldSubscription(i);
			if (subscriptionId)
			{
				if (req_type != "hc")
					continue;

				ret = true;
				if (crmi->HasPricePromotion())
					*has_promo = true;
			}
			else
			{
				if (currency != req_type)
					continue;

				ret = true;

				if (crmi->HasAmountPromotion() || crmi->HasPricePromotion())
					*has_promo = true;

				if (*smallest_price < 0 || crmi->GetBillingMethod(0)->GetPrice() < *smallest_price)
				{
					*smallest_price = crmi->GetBillingMethod(0)->GetPrice();
					*smallest_amount = crmi->GetAmount();
				}
			}
		}

		return ret;
	}

}	// --- namespace

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_SendCreditsShopData()
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_CREDITS_SHOP_DATA))
	{
		return;
	}
	auto fxPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(fxPlayer);

	std::set<std::string> promo;

	for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
	{
		auto item = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
		if (item->IsHidden())
			continue;
#endif
		if (item->HasPricePromotion() || item->HasAmountPromotion())
		{
#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			std::string s = item->GetType();
#else
			std::string s = item->GetSubType();
#endif				
			s += "Promo";
			promo.insert(s);

			if (auto sub = IAP()->GetBundleOldSubscription(i))
			{
				auto sub_data = GetShopManager()->GetOldSubscriptionData(sub);
				if (sub_data && !sub_data->active)
					promo.insert("hcPromo");
			}
		}
	}

	for (const auto& p : promo)
	{
		data->setMemberByName(p.c_str(), true);
	}

	//attention - cappingReached (from VideoHC = !enabled videoEnergy) - the condittions for cappingReached are opposite for VideoEnergy and Video Cash
	GameAdsManager::TVideoState videoState = ADS()->GetVideoState(GameAdsManager::k_HC);
	data->setMemberByName("watchVideo", videoState.isAvailableFromCrom &&
		(ADS()->IsIncentivizedAvailable(videoState.m_video[crm::k_szPopupAdsLocation].asString()) == adslib::AvailabilityStatus::ADS_STATUS_AVAILABLE));
	data->setMemberByName("cappingReached", false);

	// --- TODO: move to server
	auto energyShopItem = GetShopManager()->FindShopItem("energy");
	auto energyBonusOffer = GetShopManager()->FindShopOffer("energy_slot");
	if (GetShopManager()->GetEnergyBonusMinQty() && energyBonusOffer && !energyBonusOffer->outItems.empty())
		data->setMemberByName("hcEnergyBonus", energyBonusOffer->outItems.front().qty.Get());

	bool show_description = !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP);
	StringHash descriptionId = 0;

	// --- featured
	{
		bool hcUsed = false;

		for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif
			if (crmi->GetBillingMethodCount() < 1)
				continue;

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			const std::string& currency = crmi->GetType();
#else
			const std::string& currency = crmi->GetSubType();
#endif			

			auto isOldSubscription = IAP()->GetBundleOldSubscription(i);
			auto isVipSubscription = IAP()->GetBundleSubscription(i);
			auto isBundle = crmi->HasBundleItems();

			if (isVipSubscription && GetShopManager()->GetActiveSubscriptionType())
				continue;

			if (currency != "hc" && currency != "sc" && currency != SHOP_ITEM_HOARD && currency != "arena_token" && !isOldSubscription && !isBundle && !isVipSubscription)
				continue;

			if (currency == "sc")
			{
				auto shopItem = GetShopManager()->FindShopItem("sc");
				int max_qty = GetShopManager()->GetMaxQty(shopItem);
				if (max_qty > 0 && crmi->GetAmount() + PLAYER_PROFILE()->GetInventory().GetShopItem("sc") > max_qty)
					continue;
			}

			if (currency == SHOP_ITEM_HOARD)
			{
				auto offer = GetShopManager()->FindShopOffer(StringHash(SHOP_ITEM_HOARD));
				if (offer)
				{
					gameswf::ASObject* itemSwf = swfnew gameswf::ASObject(fxPlayer);
					auto cost = swfnew gameswf::ASObject(fxPlayer);
					itemSwf->setMemberByName("cost", cost);
					auto money = swfnew gameswf::ASObject(fxPlayer);
					cost->setMemberByName("money", money);
					itemSwf->setMemberByName("id", crmi->GetEntryId());
					itemSwf->setMemberByName("name", crmi->GetName());
					itemSwf->setMemberByName("art", crmi->GetIconName());
					if (crmi->HasPricePromotion())
						money->setMemberByName("oldValue", IAP()->GetItemReplacedDisplayPrice(crmi).c_str());
					money->setMemberByName("value", IAP()->GetItemDisplayPrice(crmi).c_str());

					if (GetShopManager()->FindShopOffer(StringHash("vip_tickets_earn")))
					{
						auto tier = crmi->GetExtendedField("tier").ToString();
						auto tickets = GetShopManager()->GetMultiplayerData().GetIAPTickets(tier);
						if (tickets > 0)
							itemSwf->setMemberByName("bonusTicket", (std::string("+") + std::to_string(tickets)).c_str());
					}

					int currentHoard = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_HOARD);
					auto configValue = GetShopManager()->GetMultiplayerData().GetEntryIdxInSkirmishConfig(currentHoard);
					itemSwf->setMemberByName("increaseAmount", configValue.virtual_hc);
					//ceg capping
					int platinumCnt = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_PLATINUM_CAPPING);
					int capping = platinumCnt ? configValue.platinum_capping : configValue.capping;
					itemSwf->setMemberByName("maxAmount", capping);

					gameswf::ASObject* hc_itemSwf = swfnew gameswf::ASObject(fxPlayer);
					hc_itemSwf->setMemberByName("value", offer->outItems.front().qty.Get());
					itemSwf->setMemberByName(SHOP_ITEM_HARD_CURRENCY, hc_itemSwf);

					// --- we do not support timer for skirmisher hoard for now.  If we ever, uncomment this.
					//int customTimer = ComputeCustomTimer(i);
					//if (customTimer > 0)
					//{
					//	auto timeleft = ConstructTimeLeft(customTimer, fxPlayer);
					//	if (timeleft)
					//		itemSwf->setMemberByName("timeLeft", timeleft);
					//}
					if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
					{
						show_description = true;
						descriptionId = IAP()->GetItemHashId(crmi);
					}
					if (platinumCnt)
						itemSwf->setMemberByName("doubleCapacity", true);
					auto topupEvents = SemEventManager::Instance()->GetEventsOfType(EVENT_TYPE_TOPUP);
					if (topupEvents.size())
					{
						auto pack_name = crmi->GetExtendedField("group").ToString();
						char pack_name_full[255];
						if (currentHoard > 0)
							glf::Snprintf(pack_name_full, "%s_%d", pack_name.c_str(), currentHoard - 1);
						else
							glf::Snprintf(pack_name_full, "%s", pack_name.c_str());
						auto score = GetShopManager()->GetMultiplayerData().GetTopupEventScoreFromIAPName(pack_name_full, pack_name);
						itemSwf->setMemberByName("topUpPoints", std::to_string(score).c_str());

					}
					data->setMemberByName(SHOP_ITEM_HOARD, itemSwf);
				}
			}
			else if (currency == "arena_token")
			{
				if (!PLAYER_PROFILE()->FeatureUnlocked("royale_unlocked"))
					continue;

				auto shopItem = GetShopManager()->FindShopItem("arena_token");
				int max_qty = GetShopManager()->GetMaxQty(shopItem);
				if (max_qty > 0 && crmi->GetAmount() + PLAYER_PROFILE()->GetInventory().GetShopItem("arena_token") > max_qty)
					continue;

				data->setMemberByName("showArenaTokens", true);
				if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
				{
					show_description = true;
					descriptionId = IAP()->GetItemHashId(crmi);
				}
			}

			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Value jex;
				Json::Reader rd;
				rd.parse(sjex, jex);

				bool price_cut = false;
				bool add_item = false;
				for (const auto& v : jex)
				{
					if (v.asString() == "featured")
					{
						double smallest_price;
						int smallest_amount;
						bool has_promo;
						if (!ComputeIAPPromo(currency, &smallest_price, &smallest_amount, &has_promo))
						{
							smallest_price = 0;
							smallest_amount = 0;
							has_promo = false;
						}

						auto item = CreateIAPItem(i, jex, has_promo, smallest_price, smallest_amount, fx->getPlayer(), false);
						std::string categ = "bundleOffer";
						if (item)
						{
							if (isVipSubscription)
							{
								Subscription_FillSubscriptionEntries();
								categ = "subscriptionOffer";
								if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
								{
									show_description = true;
									descriptionId = IAP()->GetItemHashId(crmi);
								}
							}
							else if (currency == "hc" || isOldSubscription || currency == "arena_token")
							{
								if (hcUsed)
									categ = "scOffer";
								else
									categ = "hcOffer";
								hcUsed = true;

								if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
								{
									show_description = true;
									descriptionId = IAP()->GetItemHashId(crmi);
								}
							}
							else if (currency == "sc")
							{
								categ = "scOffer";
								if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
								{
									show_description = true;
									descriptionId = IAP()->GetItemHashId(crmi);
								}
							}
							data->setMemberByName(categ.c_str(), item);
						}
						break;
					}
				}
			}
		}
	}

	if (show_description)
	{
		data->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));
	}

	data->setMemberByName("showArenaTokens", !EloLeaderboard::Get()->GetArenaComingSoon());

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_CREDITS_SHOP_DATA, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* CreateHCItem(const ShopOffer* offer, gameswf::Player* fxPlayer, bool shopV2 = false)
{
	if (!offer)
		return nullptr;

	gameswf::ASObject* itemSwf = swfnew gameswf::ASObject(fxPlayer);

	gameswf::ASObject* itemSwfContent = itemSwf;
	if (shopV2)
	{
		// for shopV2 add some members to content
		itemSwfContent = swfnew gameswf::ASObject(fxPlayer);
		itemSwf->setMemberByName("content", itemSwfContent);
	}

	gameswf::ASObject* specialOffer = nullptr;
	bool hasSpecialOffer = false;

	itemSwf->setMemberByName(shopV2 ? "title" : "name", GetShopManager()->GetShopItemDisplayName(offer->id));
	itemSwf->setMemberByName("cost", ConstructCostInfo(fxPlayer, offer->id, &specialOffer, &hasSpecialOffer));

	itemSwf->setMemberByName("id", offer->name.Get().c_str());

	itemSwfContent->setMemberByName("art", offer->name.Get().c_str());

	if (!offer->outItems.empty() && offer->outItems.front().item == StringHash("give_neutronium"))
	{
		auto nSwf = swfnew gameswf::ASObject(fxPlayer);
		itemSwfContent->setMemberByName(KSTR("neutronium"), nSwf);

		nSwf->setMemberByName(KSTR("value"), offer->outItems.front().qty.Get());
	}
	else if (!offer->outItems.empty())
	{
		auto credit = GetShopManager()->FindShopItem(offer->outItems.front().item);
		if (credit && credit->category == StringHash("gacha_currency"))
		{
			auto nSwf = swfnew gameswf::ASObject(fxPlayer);
			itemSwfContent->setMemberByName(credit->name.Get().c_str(), nSwf);

			nSwf->setMemberByName(KSTR("value"), offer->outItems.front().qty.Get());
		}
	}

	// --- timer
	if (hasSpecialOffer)
	{
		auto tl = ConstructOfflineItemsTimeLeft(fxPlayer, offer->id);
		if (tl)
		{
			itemSwf->setMemberByName("timeLeft", tl);
		}
	}

	auto IsKeyInArray = [](StringHash key, const std::vector<StringHash>& arr)
	{
		return std::find(arr.begin(), arr.end(), key) != arr.end();
	};

	// --- promo more / off
	if (!IsKeyInArray("price_cut", offer->xtra) && specialOffer) //don't show if extra category contains 'price_cut'
	{
		itemSwf->setMemberByName("specialOffer", specialOffer);
	}

	itemSwf->setMemberByName(KSTR("bestValue"), IsKeyInArray("best_value", offer->xtra));
	itemSwf->setMemberByName(KSTR("mostPopular"), IsKeyInArray("most_popular", offer->xtra));

	return itemSwf;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForCreditsShopData(const gameswf::ASNativeEventState& eventState)
{
	CRM()->TriggerPointcutVideo(KSTR("Video_Cash"));

	Shop_SendCreditsShopData();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AddDummyBattlepackOffer(gameswf::ASArray* offers, offer_key_t id)
{
	auto fxPlayer = offers->getPlayer();

	auto shopOffer = GetShopManager()->FindShopOffer(id);
	if (!shopOffer)
		return;

	auto outSize = shopOffer->outItems.size();
	std::string name = "Buy x" + std::to_string(outSize);

	auto offer = ConstructCostInfo(fxPlayer, id);
	offers->push(offer);

	offer->setMemberByName(KSTR("id"), (int)id.GetHash());
	offer->setMemberByName(KSTR("name"), name.c_str());
	//auto cost = swfnew gameswf::ASObject(fxPlayer);
	//cost->setMemberByName(KSTR("value"), value);
	//offer->setMemberByName(KSTR("hc"), cost);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AddDummyCraftPartTeaser(gameswf::ASArray* craftParts, part_key_t id, int amount, int dropchance)
{
	auto fxPlayer = craftParts->getPlayer();

	auto craftPart = swfnew gameswf::ASObject(fxPlayer);
	craftParts->push(craftPart);

	auto wdmgr = WeaponDataManager();
	craftPart->setMemberByName(KSTR("id"), wdmgr->GetWeaponAttributeName(wdmgr->GetPartAttribute(id)));
	craftPart->setMemberByName(KSTR("rarity"), wdmgr->GetPartRarity(id));
	craftPart->setMemberByName(KSTR("amount"), amount);
	craftPart->setMemberByName(KSTR("dropchance"), dropchance);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void showBattlepacksCompensationRewards()
{
	int popup = NOTIFICATIONS()->GetFirstKeyNotification("lucky_compensation");
	if (popup > 0)
	{
		const auto& txt = NOTIFICATIONS()->GetInfoFromNotification("lucky_compensation", popup);
		Json::Value rewards;
		if (Json::Reader().parse(txt, rewards))
		{
			std::vector<ShopItemQty> items;
			for (const auto& reward : rewards)
			{
				items.emplace_back(StringHash(reward["id"].asString().c_str()), SecuredIntMin(reward["qty"].asInt()));
			}
			GetMenuManager()->ShowGiftPopup(GetStringsMgr()->GetStringFromHash("STR_FPS_MENU_FLASH_REMOVE_LUCKY_PACKS_TITLE"),
				GetStringsMgr()->GetStringFromHash("STR_FPS_MENU_FLASH_REMOVE_LUCKY_PACKS_MESSAGE"),
				items, false, GiftPopupType::FirstLuckyPackReward);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool IsLeagueLocked(std::string packID, int& leagueID, std::string& leagueName)
{
	auto mpStats = PLAYER_PROFILE()->GetMPStats();
	auto score = mpStats["score"].asInt();
	auto pvpmgr = PvpDataManager();
	auto leagueId = pvpmgr->PvpLeagueIdForScore(score);
	auto leaguesData = pvpmgr->PvpLeagues();

	if (!leaguesData.valid())
		return false;
	auto leaguesDataBSA = leaguesData.asBinaryStructArray();

	static const std::string PACK("_pack_t");
	auto ld = packID.find(PACK);
	auto leagueIdx = -1;
	if (ld != std::string::npos)
	{
		int start = ld + PACK.length();
		leagueIdx = atoi(packID.substr(start, packID.length() - start).c_str());
	}
	auto leaguesNo = leaguesDataBSA.size();
	for (auto it = leaguesDataBSA.begin(), end = leaguesDataBSA.end(); it != end; it++)
	{
		auto arenaData = *it;
		auto league_id = arenaData["league_id"].asInt();

		if (leagueIdx == leaguesNo - league_id + 1)
		{
			leagueID = league_id;
			leagueName = GetStringsMgr()->GetStringFromHash(arenaData["string"].asUInt());
			if (leagueId <= league_id)
				return false;
		}
	}
	return true;
}

int Shop_ComputeAndSendBattlepacksInitData(bool send, BattlepackType type)
{

	const char* flash_message = "";
	StringHash categoryHash;

	switch (type)
	{
	case BattlepackType::Ordinary:
		flash_message = CPP_SEND_BATTLE_PACKS_INIT_DATA;
		categoryHash = StringHash(GetShopManager()->GetBattlepackOfferCategory().c_str());
		break;

	case BattlepackType::Arena:
		flash_message = CPP_SEND_RTPVP_SHOP_DATA;
		categoryHash = StringHash(GetShopManager()->GetArenaBattlepackCategory().c_str());
		break;

	default:
		GLF_ASSERT(0);
		break;

	}

	gameswf::RenderFX* fx = nullptr;
	if (send)
	{
		fx = GetMenuManager()->GetRoot(k_MainMenu);
		if (!fx)
			fx = GetMenuManager()->GetRoot(k_InGameMenu);
		if (!fx || !fx->getStage().hasEventListener(flash_message/*CPP_SEND_BATTLE_PACKS_INIT_DATA*/))
		{
			return 0;
		}
	}

	bool push_keys_pack = false;
	struct ButtonData
	{
		StringHash item;
		int off;
		int timeLeft;
		std::string discount;
		int order;
		bool notification;
		bool _new;
		bool locked;

		ButtonData(StringHash item = 0, int order = 1024) : item(item), off(0), timeLeft(0), order(order), notification(false), _new(false), locked(false) {}
	};
	std::vector<ButtonData> tmpPacks;
	auto credits = GetShopManager()->GetCreditsInCategory(categoryHash/*StringHash(GetShopManager()->GetBattlepackOfferCategory().c_str())*/);

	for (auto credit : credits)
	{
		auto offerHash = credit->id;
		auto shopOffer = GetShopManager()->FindShopOffer(offerHash);
		bool open_if_hidden = false;

		if (!shopOffer)
			continue;

		if (shopOffer->outItems.empty())
			continue;

		auto buyItem = shopOffer->outItems.front();

		open_if_hidden = std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("open_if_hidden")) != shopOffer->xtra.end();
		if (open_if_hidden)
		{
			open_if_hidden = PLAYER_PROFILE()->GetInventory().GetShopItem(buyItem.item) > 0;
		}

		if (shopOffer->inItem.empty() && !open_if_hidden)
			continue;

		auto openWithKey = GetShopManager()->GetActivateBy(buyItem.item);
		if (openWithKey)
			continue;

		if (openWithKey && !PLAYER_PROFILE()->TutorialCompleted("tutorial_SquadOps"))
			continue;

		StringHash item = shopOffer->outItems.front().item;
		auto str = GetShopManager()->Hash2Name(shopOffer->outItems.front().item);
		if (type == BattlepackType::Arena)
		{
			static const std::string STD("_std_");
			auto ld = str.find(STD);
			if (ld != std::string::npos)
			{
				str.replace(ld, STD.length(), "_premium_");
			}
		}

		int* crtOff = nullptr;
		auto itt = std::find_if(tmpPacks.begin(), tmpPacks.end(), [item, str](const ButtonData& b) { return (b.item == item || b.item == StringHash(str.c_str())); });

		if (itt == tmpPacks.end())
		{
			tmpPacks.push_back(ButtonData(StringHash(str.c_str()), 1024 - tmpPacks.size()));
			itt = tmpPacks.end() - 1;

			const auto& json = GetShopManager()->GetGachaMaxChances();
			const auto& promos = json[GetShopManager()->Hash2Name(item)]["_packs_promo"];
			if (std::find(promos.begin(), promos.end(), Json::Value("limited")) != promos.end())
				itt->_new = true;
			int leagueID = -1;
			std::string name;
			itt->locked = !GetShopManager()->ValidateCredit(buyItem.item);
			if (!itt->locked && type == BattlepackType::Arena)
				itt->locked = IsLeagueLocked(str, leagueID, name);
		}
		else
		{
			crtOff = &itt->off;
		}

		itt->notification |= !!PLAYER_PROFILE()->GetInventory().GetShopItem(item);


		for (auto xtraHash : shopOffer->xtra)
		{
			const auto& categStr = GetShopManager()->Hash2Name(xtraHash);
			if (categStr.empty())
				continue;

			int order = 0;
			if (sscanf(categStr.c_str(), "%d", &order) == 1)
			{
				if (order > 0 && order < itt->order)
				{
					itt->order = order;
				}
			}

			std::string moreValue;
			std::string moreValueType;
			auto discount = CheckForMoreValueInExtraCategory(categStr, moreValue, moreValueType);
			if (discount && moreValueType == "hc_off")
				itt->discount = moreValue;
		}

		if (!shopOffer->inItemReplaced.empty() &&
			!shopOffer->inItem.empty() &&
			shopOffer->inItem.front().item == shopOffer->inItemReplaced.front().item &&
			shopOffer->inItem.front().qty < shopOffer->inItemReplaced.front().qty)
		{
			auto off = _round(100.f * (1.0f - ((float)shopOffer->inItem.front().qty.Get() / shopOffer->inItemReplaced.front().qty)));
			if (off > itt->off)
				itt->off = off;
		}

		if (itt->off || !itt->discount.empty())
		{
			auto tl = GetOfflineItemsTimeLeft(offerHash);
			if (tl > 0 && (itt->timeLeft == 0 || tl < itt->timeLeft))
				itt->timeLeft = tl;
		}

		if (!push_keys_pack && !shopOffer->inItem.empty())
		{
			auto keyCredit = GetShopManager()->FindShopItem(shopOffer->inItem.front().item);
			push_keys_pack = keyCredit && keyCredit->category == StringHash("gacha_currency");
		}
	}

	// --- add IAP gacha packs
	{
		for (unsigned i = 0; i != IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

			const std::string& ctype = crmi->GetType();
			if (crmi->HasBundleItems())
				continue;

			if (crmi->GetBillingMethodCount() < 1)
				continue;

			StringHash hash(ctype.c_str());
			auto credit = GetShopManager()->FindShopItem(hash);
			if (!credit)
				continue;

			if (credit->category != StringHash("gacha"))
				continue;

			if ((credit->name.Get().find("arena") == 0) ^ (type == BattlepackType::Arena))
				continue;

			Json::Value jex;
			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Reader rd;
				rd.parse(sjex, jex);
			}

			auto itt = std::find_if(tmpPacks.begin(), tmpPacks.end(), [hash](const ButtonData& b) { return b.item == hash; });
			if (itt == tmpPacks.end())
			{
				tmpPacks.push_back(ButtonData(hash, 1024 - tmpPacks.size()));
				itt = tmpPacks.end() - 1;
				itt->locked = !GetShopManager()->ValidateCredit(credit->id);
			}

			itt->notification |= !!PLAYER_PROFILE()->GetInventory().GetShopItem(credit->id.GetHash());

			for (const auto& jCateg : jex)
			{
				auto categStr = jCateg.asString();
				if (categStr.empty())
					continue;

				int order = 0;
				if (sscanf(categStr.c_str(), "%d", &order) == 1)
				{
					if (order > 0 && order < itt->order)
					{
						itt->order = order;
					}
				}

				std::string moreValue;
				std::string moreValueType;
				auto discount = CheckForMoreValueInExtraCategory(categStr, moreValue, moreValueType);
				if (discount && moreValueType == "hc_off")
					itt->discount = moreValue;
			}

			if (crmi->HasPricePromotion())
			{
				auto price = crmi->GetBillingMethod(0)->GetPrice();
				auto oldPrice = crmi->GetBillingMethod(0)->GetReplacedPrice();
				if (oldPrice > 0)
				{
					auto off = _round(100.f * (1.0f - (price / oldPrice)));
					if (off > itt->off)
						itt->off = off;
				}
			}

			bool showTimer = false;
			if (crmi->HasPricePromotion())
			{
				showTimer = itt->off > 0;
			}
			auto hasCustomTimer = HasCustomTimer(i);

			if (hasCustomTimer != E_CT_Expired && (showTimer || hasCustomTimer == E_CT_Valid))
			{
				auto customTimer = (hasCustomTimer == E_CT_Valid) ? ComputeCustomTimer(i) : 0;
				if (customTimer <= 0)
				{
					auto promoEnd = GetShopManager()->GetIAPPromoEndTime();
					auto timeCurrent = GetShopManager()->GetServerTime();

					customTimer = (long)promoEnd - (long)timeCurrent;
				}
				if (customTimer > 0)
					itt->timeLeft = customTimer;
			}
		}
	}

	bool presentTutorialOffer = TutorialManager()->IsMenuTutorialActive("tutorial_Crafting") &&
		(!PLAYER_PROFILE()->GetInventory().HasShopItem(StringHash("battlepack_tutorial")));
	if (!presentTutorialOffer)
	{
		std::sort(tmpPacks.begin(), tmpPacks.end(), [](const ButtonData& l, const ButtonData& r)
			{
				if (l.locked != r.locked)
					return l.locked < r.locked;
				return l.order < r.order;
			});
	}

	int seconds = 0;
	for (const auto& btnData : tmpPacks)
	{
		if (btnData.timeLeft > 0)
		{
			if (seconds == 0 || btnData.timeLeft < seconds)
				seconds = btnData.timeLeft;
		}
	}

	if (!send)
		return seconds;

	auto fxPlayer = fx->getPlayer();
	gameswf::ASObject* data = swfnew gameswf::ASObject(fxPlayer);
	AddActiveMenuTutorialInfo(data);
	gameswf::ASArray* battlepacks = swfnew gameswf::ASArray(fxPlayer);

	static const char* packmap[]
	{
		"pack_t1", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_ALPHA_PACK_BREAKLINE",
		"pack_t2", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_DELTA_PACK_BREAKLINE",
		"pack_t3", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_KAPPA_PACK_BREAKLINE",
		"pack_t4", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_SIGMA_PACK_BREAKLINE",
		"pack_t5", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_OMEGA_PACK_BREAKLINE",
		"pack_t6", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_ARMAGEDDON_PACK_BREAKLINE",
	};

	for (const auto& it : tmpPacks)
	{
		std::string packID = GetShopManager()->Hash2Name(it.item);
		gameswf::ASObject* asPack = swfnew gameswf::ASObject(fxPlayer);
		if (type == BattlepackType::Arena)
		{
			static const std::string PREMIUM("_premium_");
			auto ld = packID.find(PREMIUM);
			if (ld != std::string::npos)
			{
				packID.replace(ld, PREMIUM.length(), "_std_");
			}
		}
		asPack->setMemberByName("id", packID.c_str());

		const char* name = GetShopManager()->GetShopItemDisplayName(StringHash(packID.c_str()));
		size_t n = sizeof(packmap) / sizeof(*packmap);
		for (size_t i = 0; i < n; i += 2)
		{
			if (packID.find(packmap[i]) != std::string::npos)
			{
				name = GetStringsMgr()->GetStringFromHash(packmap[i + 1]);
				break;
			}
		}

		asPack->setMemberByName("name", name);
		asPack->setMemberByName("unread", false);
		asPack->setMemberByName("locked", it.locked);

		if (it._new)
		{
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName("promo", promo);
			promo->setMemberByName("type", "new");
		}
		else if (!it.discount.empty())
		{
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName("promo", promo);
			promo->setMemberByName("type", "shop");

			auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
			promo->setMemberByName(KSTR("specialOffer"), specialOffer);
			specialOffer->setMemberByName(KSTR("value"), it.discount.c_str());
			specialOffer->setMemberByName(KSTR("type"), KSTR("hc_off"));
		}
		else if (it.off > 0)
		{
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName("promo", promo);
			promo->setMemberByName("type", "shop");

			auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
			promo->setMemberByName(KSTR("specialOffer"), specialOffer);
			specialOffer->setMemberByName(KSTR("value"), it.off);
			specialOffer->setMemberByName(KSTR("type"), KSTR("off"));

			if (it.timeLeft > 0)
			{
				auto timeLeft = ConstructTimeLeft(it.timeLeft, fxPlayer);
				if (timeLeft)
					promo->setMemberByName("timeLeft", timeLeft);
			}
		}
		else if (it.notification)
		{
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName("unread", true);
		}

		battlepacks->push(asPack);
	}

	if (push_keys_pack)
	{
		gameswf::ASObject* asPack = swfnew gameswf::ASObject(fxPlayer);
		battlepacks->push(asPack);

		bool unread = false;
		switch (type)
		{
		case BattlepackType::Ordinary:
			unread = GetShopManager()->CategoryHasPromo("pack_gacha_key") != 0;
			break;

		case BattlepackType::Arena:
			unread = GetShopManager()->CategoryHasPromo("pack_gacha_key_arena") != 0;
			break;

		default:
			GLF_ASSERTMSG(false, "Added a new battlepack type?  Please update here");
			break;
		}

		asPack->setMemberByName("id", "keys_pack");
		asPack->setMemberByName("name", GetStringsMgr()->GetStringFromHash("STR_FPS_MENU_FLASH_KEYS_PACK"));
		asPack->setMemberByName("unread", unread);
	}
	switch (type)
	{
	case BattlepackType::Ordinary:		data->setMemberByName("battlepacks", battlepacks);		break;
	case BattlepackType::Arena:			data->setMemberByName("packs", battlepacks);			break;
	default:																					break;
	}
	data->setMemberByName("selectedIndex", 0);

	//	auto debugstr = gameswf::toJsonValue(data).toStyledString();
	//	debugstr = debugstr;

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(flash_message/*CPP_SEND_BATTLE_PACKS_INIT_DATA*/, members, membersLength);

	return seconds;
}

void onAskForBattlepacksInitData(const gameswf::ASNativeEventState& eventState)
{
	Shop_ComputeAndSendBattlepacksInitData(true, BattlepackType::Ordinary);
}

void onAskForBattlepacksData(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	const std::string packID(data["battlepackId"].toString().c_str());

	{
		EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ChangeBattlepackType, StringHash(packID.c_str()).GetHash());
		GetEventManager()->raiseAsync(ev);
	}

	Shop_SendBattlepacks(packID);

	showBattlepacksCompensationRewards();
}

void Shop_SendBattlepacks(const std::string& packID, bool updateLast)
{
	static std::string lastPackId;

	if (updateLast && lastPackId != packID)
		return;

	lastPackId = packID;

	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_BATTLE_PACKS_DATA))
	{
		return;
	}
	auto fxPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(fxPlayer);


	// --- teasers
	auto teasers = swfnew gameswf::ASArray(fxPlayer);
	data->setMemberByName(KSTR("teaser"), teasers);

	const Json::Value* json = &GetShopManager()->GetGachaMaxChances();
	Json::Value jTmp;

	// --- more hardcoding for tutorial
	if (TutorialManager()->IsMenuTutorialActive("tutorial_Crafting") &&
		(!PLAYER_PROFILE()->GetInventory().HasShopItem(StringHash("battlepack_tutorial"))) &&
		packID == "bronze_pack")
	{
		auto shopOffer = GetShopManager()->FindShopOffer("battlepack_tutorial");
		if (shopOffer && !shopOffer->outItems.empty())
		{
			jTmp[packID] = (*json)[packID];
			json = &jTmp;

			Json::Value arr;
			Json::Value val;
			val[GetShopManager()->Hash2Name(shopOffer->outItems.front().item)] = shopOffer->outItems.front().qty.Get();
			arr.append(std::move(val));
			auto& delta = jTmp["bronze_pack"]["_inventory_delta"];
			for (auto& j : delta)
				arr.append(std::move(j));
			delta = std::move(arr);
		}
	}

	const auto& packJson = (*json)[packID];
	IGM_sendMissionCompletedPartsData(packJson, teasers);

	//auto mpPlayers = swfnew gameswf::ASArray(fxPlayer);
	//teasers->setMemberByName(KSTR("mpPlayers"), mpPlayers);

	//auto mpParts = swfnew gameswf::ASArray(fxPlayer);
	//teasers->setMemberByName(KSTR("mpParts"), mpParts);

	//auto craftParts = swfnew gameswf::ASArray(fxPlayer);
	//teasers->setMemberByName(KSTR("craftParts"), craftParts);

//	AddDummyCraftPartTeaser(craftParts, part_key_t("Zoom_Epic"), 1, 30);
//	AddDummyCraftPartTeaser(craftParts, part_key_t("Accuracy_Rare"), 3, 40);
//	AddDummyCraftPartTeaser(craftParts, part_key_t("Thermal_Common"), 5, 50);

	enum class ESource { None, Offline, IAP };
	ESource show_description = GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_OFFLINE) ? ESource::Offline : ESource::None;
	StringHash descriptionId = 0;

	bool added_coming_soon = false;
	bool added_stay_tuned = false;
	gameswf::ASObject* send_keys = nullptr;

	bool found = false;

	// --- offers
	auto offers = swfnew gameswf::ASArray(fxPlayer);
	auto credits = GetShopManager()->GetCreditsInCategory(StringHash(GetShopManager()->GetBattlepackOfferCategory().c_str()));

	std::sort(credits.begin(), credits.end(), [](const ShopItem* credit1, const ShopItem* credit2)
		{
			auto shopOffer1 = GetShopManager()->FindShopOffer(credit1->id);
			auto shopOffer2 = GetShopManager()->FindShopOffer(credit2->id);

			int qty1 = shopOffer1 ? (shopOffer1->outItems.empty() ? 0 : shopOffer1->outItems.front().qty.Get()) : 0;
			int qty2 = shopOffer2 ? (shopOffer2->outItems.empty() ? 0 : shopOffer2->outItems.front().qty.Get()) : 0;

			return qty1 < qty2;
		});

	for (const auto& credit : credits)
	{
		// --- oh, the hacks we do for tutorials...
		bool presentCraftingTutorialOffer = (credit->id == StringHash("battlepack_1") || credit->id == StringHash("cbattlepack_1")) &&
			TutorialManager()->IsMenuTutorialActive("tutorial_Crafting") &&
			(!PLAYER_PROFILE()->GetInventory().HasShopItem(StringHash("battlepack_tutorial")));
		bool presentFtueTutorialOffer = (credit->id == StringHash("battlepack_5") || credit->id == StringHash("cbattlepack_5")) &&
			TutorialManager()->IsMenuTutorialActive("tutorial_CoopEventPartTwo") &&
			(!PLAYER_PROFILE()->GetInventory().HasShopItem(StringHash("ftue_battlepack_tutorial")));
		auto presentTutorialOffer = presentCraftingTutorialOffer || presentFtueTutorialOffer;

		auto offerHash = presentCraftingTutorialOffer ? offer_key_t("battlepack_tutorial") :
			presentFtueTutorialOffer ? offer_key_t("ftue_battlepack_tutorial") :
			credit->id;

		auto shopOffer = GetShopManager()->FindShopOffer(offerHash);
		if (!shopOffer)
			continue;

		if (shopOffer->outItems.empty())
			continue;
		auto buyItem = shopOffer->outItems.front();
		auto openWithKey = GetShopManager()->GetActivateBy(buyItem.item);

		if (openWithKey)
			continue;

		if (shopOffer->inItem.empty() && !openWithKey)
			continue;

		if (!presentTutorialOffer && GetShopManager()->Hash2Name(buyItem.item) != packID)
			continue;

		if (openWithKey && buyItem.qty != 1)	// --- this is the unused one
			continue;

		found = true;
		bool open = false;

		if (!openWithKey && !send_keys)
		{
			auto currecyCredit = GetShopManager()->FindShopItem(shopOffer->inItem.front().item);
			if (currecyCredit && currecyCredit->category == StringHash("gacha_currency"))
			{
				send_keys = swfnew gameswf::ASObject(fxPlayer);
				send_keys->setMemberByName("type", "activate_currency");
				send_keys->setMemberByName("value", PLAYER_PROFILE()->GetInventory().GetShopItem(currecyCredit->id));
				send_keys->setMemberByName("id", currecyCredit->name.Get().c_str());
			}
		}

		bool coming_soon = GetShopManager()->IsComingSoon(shopOffer->id) || std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("coming_soon")) != shopOffer->xtra.end();
		bool stay_tuned = GetShopManager()->IsComingSoon(shopOffer->id) || std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("stay_tuned")) != shopOffer->xtra.end();
		bool redirectToSubscription = std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("get_from_subscription")) != shopOffer->xtra.end();
		gameswf::ASObject* offer = NULL;
		StringHash stringHash(0);
		int qty = 0, qty2 = 0, n = 0;
		bool has_enough_keys = !openWithKey || PLAYER_PROFILE()->GetInventory().HasShopItem(openWithKey);
		if (stay_tuned)
		{
			if (added_stay_tuned)
				continue;
			added_stay_tuned = true;
			offer = swfnew gameswf::ASObject(fxPlayer);
			offer->setMemberByName(KSTR("comingSoon"), true);
			stringHash = StringHash("STR_FPS_MENU_FLASH_EVENTS_STAY_TUNED");
		}
		else if (!presentTutorialOffer &&
			(buyItem.qty == 1) &&
			PLAYER_PROFILE()->GetInventory().HasShopItem(buyItem.item) &&
			!redirectToSubscription &&
			has_enough_keys)
		{
			offer = swfnew gameswf::ASObject(fxPlayer);
			gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
			cost->setMemberByName("value", 0);
			std::string hc = "hc";
			if (!shopOffer->inItem.empty())
				hc = GetShopManager()->Hash2Name(shopOffer->inItem.front().item);
			offer->setMemberByName(hc.c_str(), cost);
			stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");
			open = true;
			qty = 1;
			offerHash = buyItem.item;

			if (coming_soon)
				added_coming_soon = true;

			n = PLAYER_PROFILE()->GetInventory().GetShopItem(buyItem.item);
			if (openWithKey)
			{
				int m = PLAYER_PROFILE()->GetInventory().GetShopItem(openWithKey);
				if (m < n)
					n = m;
			}
			if (n > 1)
			{
				qty2 = std::min(n, 4);
			}
		}
		else
		{
			if (openWithKey)
			{
				offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("findKeys"), true);
				if (PLAYER_PROFILE()->GetInventory().HasShopItem(buyItem.item))
					stringHash = StringHash("STR_FPS_MENU_FLASH_LUCKY_CACHE_FIND_KEY");
				else
					stringHash = StringHash("STR_FPS_MENU_FLASH_LUCKY_CACHE_FIND_CHEST");

				auto hc = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("hc"), hc);
				hc->setMemberByName(KSTR("value"), 0);
			}
			else if (redirectToSubscription)
			{
				if (GetShopManager()->GetActiveSubscriptionType())
					continue;

				if (!IAP()->HasVipSubscriptions())
					continue;

				offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("subscribe", true);
				stringHash = StringHash("STR_FPS_MENU_FLASH_VIP_MEMBERSHIP");

				auto hc = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("hc"), hc);
				hc->setMemberByName(KSTR("value"), 0);
			}
			else if (coming_soon)
			{
				if (added_coming_soon)
					continue;
				added_coming_soon = true;
				offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("comingSoon"), true);
				stringHash = StringHash("STR_FPS_MENU_FLASH_EVENTS_COMING_SOON");
			}
			else if (presentFtueTutorialOffer)
			{
				offer = swfnew gameswf::ASObject(fxPlayer);
				gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
				cost->setMemberByName("value", 0);
				std::string hc = "hc";
				offer->setMemberByName(hc.c_str(), cost);
				stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");
				qty = 1;
				n = 1;
			}
			else
			{
				offer = ConstructCostInfo(fxPlayer, shopOffer->id);
				auto currencyCredit = GetShopManager()->FindShopItem(shopOffer->inItem.front().item);
				if (currencyCredit && currencyCredit->category == StringHash("gacha_currency"))
					stringHash = StringHash("STR_UNLOCK_BATTLEPACK");
				else
					stringHash = StringHash("STR_BUY_BATTLEPACK");
			}
			qty = shopOffer->outItems.front().qty.Get();

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_OFFLINE, shopOffer->id))
			{
				show_description = ESource::Offline;
				descriptionId = shopOffer->id;
			}
		}

		if (openWithKey)
		{
			SwfCards keyCard(nullptr);
			int keyQty = PLAYER_PROFILE()->GetInventory().GetShopItem(openWithKey);
			gameswf::ASObject* swfKeys = nullptr;
			if (keyQty > 0)
			{
				swfKeys = keyCard.Make(fxPlayer, SHOP_ITEM_LUCKY_KEY, keyQty, Json::Value::null, Json::Value::null);
			}
			else
			{
				swfKeys = swfnew gameswf::ASObject(fxPlayer);
				swfKeys->setMemberByName("type", "activate_currency");
				swfKeys->setMemberByName("value", 0);
				swfKeys->setMemberByName("id", "bronze_key");
			}

			data->setMemberByName(KSTR("keys"), swfKeys);
			data->setMemberByName(KSTR("packsAvailable"), PLAYER_PROFILE()->GetInventory().GetShopItem(buyItem.item));

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_OFFLINE, shopOffer->id))
			{
				show_description = ESource::Offline;
				descriptionId = shopOffer->id;
			}
		}

		offer->setMemberByName(KSTR("id"), (int)offerHash);
		offer->setMemberByName(KSTR("quantity"), 1);
		offer->setMemberByName("open", open);

		static const std::string QTY = "${QTY}";
		static const std::string TOTAL = "${TOTAL}";

		const char* buy_str = GetStringsMgr()->GetStringFromHash(stringHash);
		std::string buy_str_buff(buy_str);

		{
			int pos = buy_str_buff.find(QTY);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, QTY.length(), std::to_string(qty));
			pos = buy_str_buff.find(TOTAL);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, TOTAL.length(), std::to_string(n));
			offer->setMemberByName(KSTR("name"), buy_str_buff.c_str());
		}

		offers->push(offer);

		if (qty2 > 1)
		{
			gameswf::ASObject* offer2 = new gameswf::ASObject(*offer);
			offer2->setMemberByName(KSTR("quantity"), qty2);
			offer2->setMemberByName("open", open);

			buy_str_buff = GetStringsMgr()->GetStringFromHash(stringHash);
			int pos = buy_str_buff.find(QTY);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, QTY.length(), std::to_string(qty2));
			pos = buy_str_buff.find(TOTAL);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, TOTAL.length(), std::to_string(n));

			offer2->setMemberByName(KSTR("name"), buy_str_buff.c_str());
			offers->push(offer2);
		}
	}

	static const std::string QTY = "QTY";
	static const std::string TOTAL = "TOTAL";
	auto createOffer = [](StringHash id, int n, int nb, gameswf::Player* fxPlayer)
	{
		std::map<std::string, std::string> map;
		map[QTY] = std::to_string(n);
		map[TOTAL] = std::to_string(nb);

		auto stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");
		auto msg = StringsManager::FormatStringWithTags(stringHash, map);

		auto offer = swfnew gameswf::ASObject(fxPlayer);
		offer->setMemberByName("id", (int)id.GetHash());
		offer->setMemberByName("name", msg.c_str());
		offer->setMemberByName("quantity", n);
		offer->setMemberByName("open", true);

		gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
		cost->setMemberByName("value", 0);
		std::string hc = "hc";
		offer->setMemberByName(hc.c_str(), cost);

		return offer;
	};

	if (!found)	// --- search IAP
	{
		bool added_stay_tuned = false;
		for (unsigned i = 0; i != IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);

#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

			const std::string& type = crmi->GetType();
			if (crmi->HasBundleItems())
				continue;

			if (crmi->GetBillingMethodCount() < 1)
				continue;

			StringHash hash(type.c_str());

			if (type != packID)
				continue;

			auto credit = GetShopManager()->FindShopItem(hash);
			if (!credit)
				continue;

			bool coming_soon = false;
			bool stay_tuned = false;

			found = true;

			Json::Value jex;
			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Reader rd;
				rd.parse(sjex, jex);

				for (const auto& p : jex)
				{
					if (p.asString() == "stay_tuned")
						stay_tuned = true;
					else if (p.asString() == "coming_soon")
						coming_soon = true;
				}
			}

			auto nb = PLAYER_PROFILE()->GetInventory().GetShopItem(hash);

			if (stay_tuned || coming_soon)
			{
				added_stay_tuned = true;
				auto offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("comingSoon"), true);
				offer->setMemberByName("name", GetStringsMgr()->GetStringFromHash(stay_tuned ? StringHash("STR_FPS_MENU_FLASH_EVENTS_STAY_TUNED") : StringHash("STR_FPS_MENU_FLASH_EVENTS_COMING_SOON")));

				gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
				cost->setMemberByName("value", 0);
				std::string hc = "hc";
				offer->setMemberByName(hc.c_str(), cost);
				offers->push(offer);
				break;
			}

			if (nb >= 1)
			{
				auto offer = createOffer(hash, 1, nb, fxPlayer);
				offers->push(offer);
				if (nb >= 4)
				{
					offer = createOffer(hash, 4, nb, fxPlayer);
					offers->push(offer);
				}
			}

			{
				std::map<std::string, std::string> map;
				map[QTY] = std::to_string(crmi->GetAmount());
				auto msg = StringsManager::FormatStringWithTags(StringHash("STR_BUY_BATTLEPACK"), map);

				auto offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("id", (int)StringHash(crmi->GetEntryId()).GetHash());
				offer->setMemberByName("name", msg.c_str());
				offer->setMemberByName("quantity", crmi->GetAmount());

				auto money = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("money", money);
				money->setMemberByName("value", IAP()->GetItemDisplayPrice(crmi).c_str());
				if (crmi->HasPricePromotion())
					money->setMemberByName("oldValue", IAP()->GetItemReplacedDisplayPrice(crmi).c_str());

				int remaining = crmi->GetRemainingPurchaseCount();
				if (remaining > 0)
				{
					offer->setMemberByName("stock", remaining);
					data->setMemberByName("stock", remaining);
				}

				offers->push(offer);
			}

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
			{
				show_description = ESource::IAP;
				descriptionId = IAP()->GetItemHashId(crmi);
			}
			else
			{
				show_description = GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP) ? ESource::None : ESource::IAP;
			}
			break;
		}
	}

	if (!found)
	{
		StringHash hash(packID.c_str());
		auto nb = PLAYER_PROFILE()->GetInventory().GetShopItem(hash);
		if (nb >= 1)
		{
			auto offer = createOffer(hash, 1, nb, fxPlayer);
			offers->push(offer);
			if (nb >= 4)
			{
				offer = createOffer(hash, 4, nb, fxPlayer);
				offers->push(offer);
			}
		}
	}

	data->setMemberByName(KSTR("offers"), offers);

	if (send_keys)
	{
		data->setMemberByName("keys", send_keys);
	}

	switch (show_description)
	{
	case ESource::Offline:
		data->setMemberByName(KSTR("description"), GetShopManager()->GetOfflineItemsPromoDescription(descriptionId));
		break;

	case ESource::IAP:
		data->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));
		break;

	default:
		break;

	}

	//	auto debugstr = gameswf::toJsonValue(data).toStyledString();
	//	debugstr = debugstr;

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_BATTLE_PACKS_DATA, members, membersLength);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Shop_UpdateBattlepacksSelection(const char* battlepackId)
{

	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_COMMAND_BATTLE_PACKS_SELECT_PACK))
	{
		return;
	}
	auto fxPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(fxPlayer);
	data->setMemberByName(KSTR("battlepackId"), battlepackId);
	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_COMMAND_BATTLE_PACKS_SELECT_PACK, members, membersLength);

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onBattlePackViewport(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue inputData = eventState.m_event["data"];

	s32 x = inputData["x"].toInt();
	s32 y = inputData["y"].toInt();
	s32 w = inputData["width"].toInt();
	s32 h = inputData["height"].toInt();

	GetMenuManager()->SetBattlepackViewports({ core::rect<s32>(x, y, x + w, y + h) });

	EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ResizeBattlepackViewport);
	GetEventManager()->raiseAsync(ev);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onArenaBattlePackViewport(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue inputData = eventState.m_event["data"];
	std::vector<core::rect<s32>> viewports;

	if (!inputData.isObject())
		return;

	auto obj = inputData.toObject();
	GLF_ASSERT(obj->is(gameswf::AS_ARRAY));
	auto arr = static_cast<gameswf::ASArray*>(obj);
	for (auto i = 0, c = arr->size(); i < c; ++i)
	{
		const auto& viewport = arr->get(i);
		s32 x = viewport["x"].toInt();
		s32 y = viewport["y"].toInt();
		s32 w = viewport["width"].toInt();
		s32 h = viewport["height"].toInt();

		// think positive thoughts pls
		if ((w < 0) || (h < 0))
			continue;

		viewports.push_back(core::rect<s32>(x, y, x + w, y + h));
	}

	if (viewports.empty())
		return;

	GetMenuManager()->SetBattlepackViewports(viewports);

	EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ResizeBattlepackViewport);
	GetEventManager()->raiseAsync(ev);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onAskForSpecialOfferTimeLeft(const gameswf::ASNativeEventState& eventState)
{
	// --- CPP_SEND_SPECIAL_OFFER_TIME_LEFT
	gameswf::ASValue d = eventState.m_event["data"];
	auto id = d["id"].toInt();

	auto fxPlayer = eventState.m_fx->getPlayer();
	auto data = swfnew gameswf::ASObject(fxPlayer);

	auto iapItemId = IAP()->FindItem(id);
	auto offlineItem = GetShopManager()->FindShopOffer(id);
	if (iapItemId != (size_t)(-1))
	{
		int customTimer = ComputeCustomTimer(iapItemId);

		auto timeleft = (customTimer > 0) ? ConstructTimeLeft(customTimer, fxPlayer) : ConstructIAPTimeLeft(fxPlayer);
		if (timeleft)
			data->setMemberByName("timeLeft", timeleft);
	}
	else if (offlineItem)
	{
		auto timeleft = ConstructOfflineItemsTimeLeft(fxPlayer, offlineItem->id);
		if (timeleft)
			data->setMemberByName("timeLeft", timeleft);
	}

	GET_BASE_RETURN(data);
	eventState.m_fx->getStage().dispatchEvent(CPP_SEND_SPECIAL_OFFER_TIME_LEFT, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void BattlepacksBuyPack(int id, int quantity, bool isTutorial)
{
	auto activeMenuTutorial = TutorialManager()->ActiveMenuTutorial();
	if (isTutorial && activeMenuTutorial && activeMenuTutorial->idHash == StringHash("tutorial_ArenaPartTwo"))
	{
		Shop_SendBattlepackArenaTutorialRewards();
		return;
	}

	//auto debugstr = gameswf::toJsonValue(data).toStyledString();
	//debugstr = debugstr;

	auto checkAndUpdateArenaPack = [](StringHash id)
	{
		auto item = GetShopManager()->Hash2Name(id);
		if (item.find("arena") != std::string::npos)
		{
			EvMenuCmd ev(EvMenuCmd::k_MenuCmd_SetCurrentArenaPack, (item.find("_premium_") != std::string::npos) ? 1 : 0);
			GetEventManager()->raiseAsync(ev);
		}
	};

	auto crm_index = IAP()->FindItem(id);
	auto offer = GetShopManager()->FindShopOffer(id);

	if (offer && offer->id == "ustw_fallback_bundle") //ustw-only stuff - thaomm
	{
		GetShopManager()->AcceptOffer(id);
	}

	if (crm_index != (size_t)-1)
	{
		IAP()->BuyRequest(id);
	}
	else if (offer && !offer->inItem.empty())
	{
		if (!offer->outItems.empty() && GetShopManager()->GetActivateBy(offer->outItems.front().item))	// --- trying to buy a lucky chest - should display a pop-up instead
			return;

		Json::Value extraData;
		extraData["activate"] =
			offer->category == StringHash(GetShopManager()->GetBattlepackOfferCategory().c_str())
			|| offer->category == StringHash(GetShopManager()->GetArenaBattlepackCategory().c_str());
		GetShopManager()->AcceptOffer(id, extraData);

		checkAndUpdateArenaPack(offer->outItems.front().item);
		return;
	}
	else
	{
		GetOnlineManager()->GetAHGSLobbyManager()->ClientSendActivateCredit(id, std::max(quantity, 1));
	}

	checkAndUpdateArenaPack(id);
}

void ShopV2_OnCommandBattlepacksBuyPack(const gameswf::ASNativeEventState& eventState)
{
	// --- read the param
	gameswf::ASValue data = eventState.m_event["data"];
	auto id = data["offerId"].toInt();
	// auto packId = data["packId"].to???;
	auto quantity = data["quantity"].toInt();
	auto isTutorial = data["tutorial"].toBool(); // --- missing for now

	BattlepacksBuyPack(id, quantity, isTutorial);
}

void onCommandBattlepacksBuyPack(const gameswf::ASNativeEventState& eventState)
{
	// --- read the param
	gameswf::ASValue data = eventState.m_event["data"];
	auto id = data["id"].toInt();
	auto quantity = data["quantity"].toInt();
	auto isTutorial = data["tutorial"].toBool();

	BattlepacksBuyPack(id, quantity, isTutorial);
}

void Shop_onCommandBattlepacksOpenPack(const gameswf::ASNativeEventState& eventState)
{
	// --- read the params
	gameswf::ASValue inputData = eventState.m_event["data"];

	std::string id = inputData["id"].toString().c_str();
	
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx)
	{
		return;
	}

	GetMenuManager()->SetMenuActive(true, k_Popups);
	GetMenuManager()->MenuCaptureInput(k_Popups);

	auto popup = swfnew gameswf::ASObject(fx->getPlayer());

	popup->setMemberByName("type", "popup_battlePackOpen");
	popup->setMemberByName("name", "battlePackOpenPopup");
	popup->setMemberByName("titlebar", true);
	popup->setMemberByName("closeButton", true);
	popup->setMemberByName("title", GetShopManager()->GetShopItemDisplayName(StringHash(id.c_str())));

	auto hash = StringHash(id.c_str());
	{
		SwfCards card(nullptr, SwfCards::NameInName);
		auto item = card.Make(fx->getPlayer(), hash, 1, Json::Value::null, Json::Value::null);
		if (item)
			popup->setMemberByName("cardData", item);
	}

	auto buttons = swfnew gameswf::ASArray(fx->getPlayer());
	popup->setMemberByName("buttons", buttons);
	auto nb = PLAYER_PROFILE()->GetInventory().GetShopItem(hash);	// --- !!! because the popup is displayed before updating the inventory in CShopManager::UpdateShopInventoryImpl

	auto createOpenButton = [](gameswf::Player* fxPlayer, int n, int nb, StringHash id) -> gameswf::ASObject*
		{
			static const std::string QTY = "QTY";
			static const std::string TOTAL = "TOTAL";
			auto stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");

			std::map<std::string, std::string> map;
			map[TOTAL] = std::to_string(nb);
			map[QTY] = std::to_string(n);

			auto button = swfnew gameswf::ASObject(fxPlayer);
			button->setMemberByName("name", (std::string("btnOpen") + std::to_string(n)).c_str());
			button->setMemberByName("id", (int)id.GetHash());
			button->setMemberByName("packId", GetShopManager()->Hash2Name(id).c_str());
			auto msg = StringsManager::FormatStringWithTags(stringHash, map);
			button->setMemberByName("label", msg.c_str());
			button->setMemberByName("quantity", n);
			auto sc = swfnew gameswf::ASObject(fxPlayer);
			button->setMemberByName("sc", sc);
			sc->setMemberByName("value", 0);
			button->setMemberByName("closePopup", true);

			return button;
		};

	if (nb >= 1) buttons->push(createOpenButton(fx->getPlayer(), 1, nb, hash));
	if (nb >= 4) buttons->push(createOpenButton(fx->getPlayer(), 4, nb, hash));

	GET_BASE_RETURN(popup)
	fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_POPUP, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onCommandBattlepacksShowPackInfo(const gameswf::ASNativeEventState& eventState)
{
	// --- read the param
	gameswf::ASValue data = eventState.m_event["data"];
	std::string id = data["id"].toCStr();

	//	auto debugstr = gameswf::toJsonValue(data).toStyledString();
	//	debugstr = debugstr;

	GetOnlineManager()->ClientSendReqGachInfo(StringHash(id.c_str()));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_SendBattlepackRewards(const Json::Value& invUpdateJson, StringHash tranzId)
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		return;

	auto data = swfnew gameswf::ASObject(fx->getPlayer());

	auto rewards = swfnew gameswf::ASArray(fx->getPlayer());
	data->setMemberByName(KSTR("rewards"), rewards);
	IGM_sendMissionCompletedPartsData(invUpdateJson, rewards);

	// send the final position of the cards depending on the number of cards
	auto rewardsNo = rewards->size();
	GetMenuManager()->SetBattlepackCardsNo(rewardsNo);


	int pack = 0; // pack == 0 => either the pack in BP menu or the standard pack in Arena Packs menu
	auto item = GetShopManager()->FindShopItem(tranzId);
	std::string itemName = GetShopManager()->Hash2Name(item ? item->id : StringHash());
	if (itemName.find("arena_premium") != std::string::npos)
	{
		pack = 1;
	}

	// --- TODO: remove when fully transitioned to shop v2 for battlepacks
	auto crtMenu = GetMenuManager()->GetActiveMenuName();
	if (crtMenu == "menu_Shop_Battle_Packs" 
		|| crtMenu == "menu_Inventory"
		|| crtMenu == "menu_ShardScreen"
		)
	{
		{
			EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ShowBattlepackScene, 1);
			GetEventManager()->raiseAsync(ev);
		}

		{
			auto battlepackType = tranzId;
			if (battlepackType == "battlepack_tutorial")
				battlepackType = "bronze_pack";
			EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ChangeBattlepackType, battlepackType.GetHash());
			GetEventManager()->raiseAsync(ev);
		}
	}

#ifdef SKIRMISH_EVENT
	if (crtMenu == "menu_SkirmishEventShop")
	{
		{
			EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ShowBattlepackScene, 1);
			GetEventManager()->raiseAsync(ev);
		}

		{
			auto battlepackType = tranzId;
			EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ChangeBattlepackType, battlepackType.GetHash());
			GetEventManager()->raiseAsync(ev);
		}
	}
#endif // SKIRMISH_EVENT

	EvMenuCmd ev(EvMenuCmd::k_MenuCmd_StartBattlepackAnim, 0, pack);
	GetEventManager()->raiseAsync(ev);

	{
		GET_BASE_RETURN(data)
			fx->getStage().dispatchEvent(CPP_SEND_BATTLE_PACKS_REWARDS_DATA, members, membersLength);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_SendBattlepackArenaTutorialRewards()
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		return;

	auto data = swfnew gameswf::ASObject(fx->getPlayer());

	GetMenuManager()->SetBattlepackCardsNo(1);

	{
		EvMenuCmd ev(EvMenuCmd::k_MenuCmd_StartBattlepackAnim, 0);
		GetEventManager()->raiseAsync(ev);
	}
	{
		GET_BASE_RETURN(data)
			fx->getStage().dispatchEvent(CPP_SEND_BATTLE_PACKS_REWARDS_DATA, members, membersLength);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_StartBattlepackRewardsAnimation(bool usedSkip, int packType)
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		return;

	auto data = swfnew gameswf::ASObject(fx->getPlayer());

	{
#if 0 // reopen for next work on gatcha anim
		auto swfPositions = swfnew gameswf::ASArray(fx->getPlayer());
		auto positions = GetMenuManager()->GetBattlepackCardsPositions();
		for (auto position : positions)
		{
			auto swfPos = swfnew gameswf::ASObject(fx->getPlayer());
			swfPos->setMemberByName("x", position.getX());
			swfPos->setMemberByName("y", position.getY());
			swfPositions->push(swfPos);
		}
		data->setMemberByName("positions", swfPositions);
#endif
		data->setMemberByName("skipped", usedSkip);
		GET_BASE_RETURN(data)
			if (packType == 0)
				if (GetMenuManager()->GetActiveMenuName() == "menu_Shop_Battle_Packs" || GetMenuManager()->GetActiveMenuName() == "menu_Inventory")
					fx->getStage().dispatchEvent(CPP_COMMAND_SHOP_BATTLE_PACKS_START_ANIMATION, members, membersLength);
				else
					fx->getStage().dispatchEvent(CPP_COMMAND_BATTLE_PACKS_START_ANIMATION, members, membersLength);
			else if (packType == 1)
				fx->getStage().dispatchEvent(CPP_COMMAND_RTPVP_SHOP_START_ANIMATION, members, membersLength);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onCommandBattlepacksAnimationCompleted(const gameswf::ASNativeEventState& eventState)
{
	// --- go back to idle
	EvMenuCmd ev(EvMenuCmd::k_MenuCmd_StartBattlepackAnim, 2);
	GetEventManager()->raiseAsync(ev);

	auto crtMenu = GetMenuManager()->GetActiveMenuName();
	if (crtMenu == "menu_BattlePacksSlots" 
		|| crtMenu == "menu_PvPSlots" 
		|| crtMenu == "menu_Shop_Battle_Packs" 
		|| crtMenu == "menu_SkirmishEventShop" 
		|| crtMenu == "menu_Inventory"
		|| crtMenu == "menu_ShardScreen"
		)
	{
		EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ShowBattlepackScene, 0);
		GetEventManager()->raiseAsync(ev);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onCommandArenaBattlepacksAnimationCompleted(const gameswf::ASNativeEventState& eventState)
{
	// --- go back to idle
	EvMenuCmd ev(EvMenuCmd::k_MenuCmd_StartBattlepackAnim, 2, -1);
	GetEventManager()->raiseAsync(ev);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForRaidRewards(const gameswf::ASNativeEventState& eventState)
{
	auto profile = PLAYER_PROFILE();
	auto weaponId = profile->GetFindPartsMissionData().weapon;
	auto partId = profile->GetFindPartsMissionData().part;

	gameswf::ASValue data = eventState.m_event["data"];
	offer_key_t raidOfferId = data["id"].toInt();

	Json::Value extraData;
	if (weaponId)
	{
		extraData[KSTR("weaponId")] = weaponId.GetHash();
		extraData[KSTR("partId")] = partId.GetHash();

		//tracking new player interaction - raid parts
		if (!PLAYER_PROFILE()->TutorialCompleted("tutorial_SlowTime"))
		{
			auto partItem = GetShopManager()->FindShopItem(partId);
			auto raidOffer = GetShopManager()->FindShopOffer(raidOfferId);
			int value = 0;
			if (raidOffer->id == "activate_raid_1")
			{
				value = 1;
			}
			else if (raidOffer->id == "activate_raid_2")
			{
				value = 4;
			}
			GLOT()->SendNewPlayerInteraction(TRACKING_TUTORIAL_INTERACTION_RAID, 0, value, partItem->trackingId);
		}
	}
	else
	{
		extraData[KSTR("contract")] = true;
	}
	GetShopManager()->AcceptOffer(raidOfferId, extraData);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_SendRaidRewards(const Json::Value& invUpdateJson)
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_RAID_REWARDS_DATA))
		return;

	auto data = swfnew gameswf::ASObject(fx->getPlayer());

	auto rewards = swfnew gameswf::ASArray(fx->getPlayer());
	data->setMemberByName(KSTR("rewards"), rewards);
	IGM_sendMissionCompletedPartsData(invUpdateJson, rewards);

	{
		GET_BASE_RETURN(data)
			fx->getStage().dispatchEvent(CPP_SEND_RAID_REWARDS_DATA, members, membersLength);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_ShowSkipEventMissionRewardsPopup(const Json::Value& invUpdateJson, const std::string& eventType)
{
	auto fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx)
		return;

	GetMenuManager()->SetMenuActive(true, k_Popups);
	GetMenuManager()->MenuCaptureInput(k_Popups);

	auto popup = swfnew gameswf::ASObject(fx->getPlayer());

	popup->setMemberByName("type", "popup_SkipEventMissionReward");
	popup->setMemberByName("name", "skipEventMissionRewardPopup");
	popup->setMemberByName("titlebar", false);
	popup->setMemberByName("message", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_YOUR_REWARDS));

	auto ev = sem_helpers::GetUniqueEvent(eventType);
	if (ev)
	{
		popup->setMemberByName("image", ev->GetPoster().c_str());
	}

	auto rewards = swfnew gameswf::ASArray(fx->getPlayer());
	popup->setMemberByName(KSTR("rewards"), rewards);
	IGM_sendMissionCompletedPartsData(invUpdateJson, rewards);

	auto buttons = swfnew gameswf::ASArray(fx->getPlayer());
	popup->setMemberByName("buttons", buttons);

	auto btnAccept = swfnew gameswf::ASObject(fx->getPlayer());
	buttons->push(btnAccept);

	btnAccept->setMemberByName("name", "btnAccept");
	btnAccept->setMemberByName("label", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_OK));
	btnAccept->setMemberByName("closePopup", true);
	if (ev && ev->IsBounty() && static_cast<const ClientEvent*>(ev)->GetBountyState())
	{
		// --- bounty - this is for the claim button to redirect to the chapter details menu
		// --- only do this if there are any "anims" pending for this chapter in the event state
		auto previousProgress = static_cast<const ClientEvent*>(ev)->GetProgress() - 1;
		auto eventData = EventsDataManager()->GetBountyEventData(ev->GetPresetHash());
		auto chapter = previousProgress / eventData.ChapterData(0).MissionCount();
		auto hasMapAnim = static_cast<const ClientEvent*>(ev)->GetBountyState()->chapter(chapter).has_map_fragment_anim();
		if (hasMapAnim)
		{
			btnAccept->setMemberByName("eventID", ev->GetID().c_str());
			btnAccept->setMemberByName("globalHuntChapter", chapter);
		}
	}

	GET_BASE_RETURN(popup)
		fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_POPUP, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_SendShopBpData(StringHash category)
{
	if (category == StringHash("battlepass") && PLAYER_PROFILE()->IsBattlepassActive(BattlepassType::_Any))
	{
		DEBUG_OUT_RED("Battlepass already active, should not enter here\n");
		return;
	}

	if (category == StringHash("clan_battlepass") && PLAYER_PROFILE()->GetClanBattlePassData().hasPremium)
	{
		DEBUG_OUT_RED("Clan battlepass already active, should not enter here\n");
		return;
	}

	const char* ev = CPP_SEND_BP_SHOP_DATA;
	if (category == StringHash("clan_battlepass"))
		ev = CPP_SEND_CLAN_BP_SHOP_DATA;

	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx || !fx->getStage().hasEventListener(ev))
	{
		return;
	}
	auto fxPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(fxPlayer);

	bool showDescription = !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP);
	StringHash descriptionId = 0;

	auto packs = swfnew gameswf::ASArray(fxPlayer);
	data->setMemberByName("packs", packs);

	struct Entry
	{
		int index, order;
		Json::Value extraCategory;
	};
	std::vector<Entry> order;

	for (int i = 0; i != IAP()->GetItemsCount(); ++i)
	{
		const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
		if (crmi->IsHidden())
			continue;
#endif
		if (crmi->GetBillingMethodCount() < 1)
			continue;

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
		const std::string& currency = crmi->GetType();
#else
		const std::string& currency = crmi->GetSubType();
#endif			

		auto credit = GetShopManager()->FindShopItem(StringHash(currency.c_str()));
		if (!credit)
			continue;

		if (credit->category != category)
			continue;

		Entry entry{ i, 0, Json::Value::null };

		auto ex = crmi->GetExtendedField("category");
		if (ex.IsValid() && ex.IsJSON())
		{
			auto sjex = ex.ToString();
			Json::Reader rd;
			rd.parse(sjex, entry.extraCategory);

			for (const auto& v : entry.extraCategory)
			{
				auto place = std::strtol(v.asCString(), nullptr, 10);
				if (place > 0)
				{
					entry.order = place;
					//break;
				}
			}
		}

		order.push_back(std::move(entry));
	}

	if (std::all_of(order.begin(), order.end(), [](const Entry& entry) { return entry.order != 0; }))
	{
		std::sort(order.begin(), order.end(), [](const Entry& e1, const Entry& e2) { return e1.order < e2.order; });
	}

	for (const auto& entry : order)
	{
		auto crmi = IAP()->GetCRMItem(entry.index);
		if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
		{
			showDescription = true;
			descriptionId = IAP()->GetItemHashId(crmi);
		}

		gameswf::ASObject* itemSwf = CreateIAPItem(entry.index, entry.extraCategory, crmi->HasPricePromotion() || crmi->HasAmountPromotion(), 0, 0, fx->getPlayer(), false);
		if (itemSwf)
		{
			auto currentTier = PLAYER_PROFILE()->GetBattlePassCurrentChapter();
			if (category == StringHash("clan_battlepass"))
			{
				currentTier = GetCurrentClanBPChapter();
			}
			if (StringHash(crmi->GetType()) == "battlepass_platinum" || StringHash(crmi->GetType()) == "clan_battlepass_platinum")
			{
				auto platinumUnlockTier = GetShopManager()->GetMultiplayerData().BattlePassPlatinumUnlock(category);
				if (currentTier > platinumUnlockTier)
					continue;

				itemSwf->setMemberByName("tier", platinumUnlockTier);
			}
			else if (StringHash(crmi->GetType()) == "battlepass_plus" || StringHash(crmi->GetType()) == "clan_battlepass_plus")
			{
				auto premiumUnlockTier = GetShopManager()->GetMultiplayerData().BattlePassPremiumUnlock(category);
				if (currentTier > premiumUnlockTier)
					continue;

				itemSwf->setMemberByName("tier", premiumUnlockTier);
			}
			else
			{
				itemSwf->setMemberByName("tier", currentTier);
			}
			packs->push(itemSwf);
		}
	}

	if (showDescription)
		data->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));

	//auto debugstr = gameswf::toJsonValue(data).toStyledString();
	//debugstr = debugstr;

	GET_BASE_RETURN(data)
		fx->getStage().dispatchEvent(ev, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForBpShopData(const gameswf::ASNativeEventState& eventState)
{
	Shop_SendShopBpData("battlepass");
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onCommandBpShopBuy(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	std::string id = data["id"].toString().c_str();
	StringHash hash(id.c_str());

	if (IAP()->FindItem(hash) != (size_t)-1)
	{
		IAP()->BuyRequest(hash);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OLD CODE BELOW THIS POINT
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_OnAskForCreditsData(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	std::string id = data["currencyType"].toString().c_str();
	int minimumRequired = data["minimumRequired"].toInt();
	//Android Change: [BM] fix #9244022, this bug should happens on the other platform, please double check
	bool skipShowSubcription = false;
#if defined(OS_ANDROID)
	skipShowSubcription = data["skipShowSubcription"].toBool();
	//end Android Change
#else
	if (id == "neutronium")
	{
		Shop_SendHcMarketData("pack_neutronium");
		//Json::Value data;
		//data["currency"] = "neutronium";
		//data["value"] = 100;
		//GetOnlineManager()->GetAHGSLobbyManager()->ClientSendCheatCommand(AHCheatCommand::RefillNeutronium, data);
		return;
	}
#endif
	if (id == "gold_key" || id == "silver_key")
	{
		Shop_SendHcMarketData("pack_gacha_key");
		return;
	}
	if (id == "pink_key")
	{
		Shop_SendHcMarketData("pack_gacha_key_arena");
		return;
	}

	Shop_SendMarketData(id, minimumRequired, skipShowSubcription);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* ConstructOffIAPPromo(const IapManager::StoreItem* item, gameswf::Player* fxPlayer)
{
	auto ex = item->GetExtendedField("category");
	if (ex.IsValid() && ex.IsJSON())
	{
		auto sjex = ex.ToString();
		Json::Value jex;
		Json::Reader rd;
		rd.parse(sjex, jex);

		for (const auto& v : jex)
		{
			const std::string& categ = v.asString();

			std::string val("0");
			std::string type("");

			bool hasCustomMoreValue = CheckForMoreValueInExtraCategory(categ, val, type);
			if (hasCustomMoreValue)
			{
				auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
				specialOffer->setMemberByName("value", val.c_str());
				specialOffer->setMemberByName("type", type.c_str());

				return specialOffer;
			}
		}
	}


	if (item->HasPricePromotion())
	{
		auto price = item->GetBillingMethod(0)->GetPrice();
		auto oldPrice = item->GetBillingMethod(0)->GetReplacedPrice();
		if (oldPrice > 0)
		{
			auto off = _round(100.f * (1.0f - (price / oldPrice)));
			auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
			specialOffer->setMemberByName("value", off);
			specialOffer->setMemberByName("type", "off");

			return specialOffer;
		}
	}
	else if (item->HasAmountPromotion())
	{
		auto more = _round(item->GetBonusAmountPercent());
		if (more > 0)
		{
			auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
			specialOffer->setMemberByName("value", more);
			specialOffer->setMemberByName("type", "more");

			return specialOffer;
		}
	}

	return nullptr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* ConstructTimeLeft(int seconds, gameswf::Player* fxPlayer)
{
	struct TimeLeft
	{
		int D, h, m, s;

		TimeLeft() : D(0), h(0), m(0), s(0) {}
		bool valid() const { return D || h || m || s; }
	};
	TimeLeft timeLeft;

	timeLeft.D = seconds / (60 * 60 * 24);
	seconds %= (60 * 60 * 24);

	timeLeft.h = seconds / (60 * 60);
	seconds %= (60 * 60);

	timeLeft.m = seconds / 60;
	seconds %= 60;

	timeLeft.s = seconds;

	auto tl = swfnew gameswf::ASObject(fxPlayer);
	tl->setMemberByName("hours", timeLeft.D * 24 + timeLeft.h);
	tl->setMemberByName("minutes", timeLeft.m);
	tl->setMemberByName("seconds", timeLeft.s);

	return tl;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* ConstructIAPTimeLeft(gameswf::Player* fxPlayer)
{
	auto promoEnd = GetShopManager()->GetIAPPromoEndTime();
	auto timeCurrent = GetShopManager()->GetServerTime();

	auto seconds = (long)promoEnd - (long)timeCurrent;

	if (seconds <= 0)
		return nullptr;

	return ConstructTimeLeft(seconds, fxPlayer);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* ConstructGAMETimeLeft(gameswf::Player* fxPlayer)
{
	auto promoEnd = GetShopManager()->GetGameParamsPromoEndTime();
	auto timeCurrent = GetShopManager()->GetServerTime();

	auto seconds = (long)promoEnd - (long)timeCurrent;

	if (seconds <= 0)
		return nullptr;

	return ConstructTimeLeft(seconds, fxPlayer);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* ConstructIAPItemOutsideShop(int itemIdx, const Json::Value& extra_category, bool hasPromo, double smallest_price, int smallest_amount, gameswf::Player* fxPlayer, bool skipShowSubcription, bool shopV2)
{
	return CreateIAPItem(itemIdx, extra_category, hasPromo, smallest_price, smallest_amount, fxPlayer, skipShowSubcription,  shopV2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int GetOfflineItemsTimeLeft(StringHash offerId)
{
	auto promoEnd = GetShopManager()->GetOfflineItemsPromoEndTime(offerId);
	auto timeCurrent = GetShopManager()->GetServerTime();

	auto seconds = (long)promoEnd - (long)timeCurrent;

	if (seconds <= 0)
		return 0;

	return seconds;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* ConstructOfflineItemsTimeLeft(gameswf::Player* fxPlayer, StringHash offerId)
{
	//auto promoEnd = GetShopManager()->GetOfflineItemsPromoEndTime(offerId);
	auto timeCurrent = GetShopManager()->GetServerTime();

	auto seconds = GetOfflineItemsTimeLeft(offerId);

	if (seconds <= 0)
		return nullptr;

	return ConstructTimeLeft(seconds, fxPlayer);
}

//hide offers < minimumRequired
void Shop_SendMarketData(std::string reqCurrency, int minimumRequired, bool skipShowSubcription)
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_CREDITS_DATA))
	{
		return;
	}

	static std::string lastReqCurrency;
	static int lastMinimumRequired = 0;

	if (reqCurrency.empty())
	{
		reqCurrency = lastReqCurrency;
		minimumRequired = lastMinimumRequired;
	}
	else
	{
		lastReqCurrency = reqCurrency;
		lastMinimumRequired = minimumRequired;
	}

	if (reqCurrency.empty())
	{
		reqCurrency = lastReqCurrency = "hc";
		minimumRequired = 0;
	}
	//Android Change: [BM] fix #9244022, this bug should happens on the other platform, please double check

	else if (reqCurrency == "neutronium")
	{
		Shop_SendHcMarketData(StringHash(SHOP_OFFER_CATEGORY_PACK_NEUTRONIUM));
		return;
	}
	else
	{
		auto credit = GetShopManager()->FindShopItem(StringHash(reqCurrency.c_str()));
		if (credit && credit->category == StringHash("gacha_currency"))
		{
			Shop_SendHcMarketData(StringHash(reqCurrency.c_str()));
			return;
		}
	}

	//end Android Change

	gameswf::ASObject* marketDataSwf = swfnew gameswf::ASObject(fx->getPlayer());

	{
		auto hardCurrencyAmount = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_HARD_CURRENCY);
		marketDataSwf->setMemberByName("hardCurrency", hardCurrencyAmount);
	}

	{
		auto softCurrency = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_SOFT_CURRENCY);
		marketDataSwf->setMemberByName("diamondDust", softCurrency);
	}

	{
		auto arenaTokenCurrency = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_ARENA_TOKEN);
		marketDataSwf->setMemberByName("arena_token", arenaTokenCurrency);
	}

	bool showDescription = !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP);
	StringHash descriptionId = 0;

	{
		gameswf::ASArray* currencyPacksSwf = swfnew gameswf::ASArray(fx->getPlayer());

		std::vector<std::pair<int, int>> items_ixs;

		std::map<int, Json::Value> extra_categories;
		double smallest_price = -1;
		int smallest_amount = -1;
		int highest_amount = -1;
		bool hasPromo = false;
		for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif
			if (crmi->GetBillingMethodCount() < 1)
				continue;

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			const std::string& currency = crmi->GetType();
#else
			const std::string& currency = crmi->GetSubType();
#endif			

			auto subscriptionId = IAP()->GetBundleOldSubscription(i);
			if (subscriptionId)
			{
				if (reqCurrency != "hc")
					continue;

				if (minimumRequired > 0)
					continue;

				if (crmi->HasPricePromotion())
					hasPromo = true;
			}
			else
			{
				if (currency != reqCurrency)
					continue;

				if (currency == "sc")
				{
					auto shopItem = GetShopManager()->FindShopItem("sc");
					int max_qty = GetShopManager()->GetMaxQty(shopItem);
					if (max_qty > 0 && crmi->GetAmount() + PLAYER_PROFILE()->GetInventory().GetShopItem("sc") > max_qty)
						continue;
				}

				if (crmi->GetAmount() > highest_amount)
				{
					highest_amount = crmi->GetAmount();
				}

				if (crmi->HasAmountPromotion() || crmi->HasPricePromotion())
					hasPromo = true;

				if (smallest_price < 0 || crmi->GetBillingMethod(0)->GetPrice() < smallest_price)
				{
					smallest_price = crmi->GetBillingMethod(0)->GetPrice();
					smallest_amount = crmi->GetAmount();
				}
			}

			items_ixs.push_back(std::make_pair(i, 0));

			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Value jex;
				Json::Reader rd;
				rd.parse(sjex, jex);

				for (const auto& v : jex)
				{
					auto place = std::strtol(v.asCString(), nullptr, 10);
					if (place > 0)
					{
						items_ixs.back().second = place;
						//break;
					}
				}

				extra_categories[i] = std::move(jex);
			}
		}

		// --- std::sort_if
		if (std::all_of(items_ixs.begin(), items_ixs.end(), [](const std::pair<int, int>& p) { return p.second > 0; }))	// --- only sort if all members have order extra category
		{
			std::sort(items_ixs.begin(), items_ixs.end(), [](const std::pair<int, int>& p1, const std::pair<int, int>& p2) { return p1.second < p2.second; });
		}

		for (const auto& it : items_ixs)
		{
			int i = it.first;
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			const std::string& currency = crmi->GetType();
#else
			const std::string& currency = crmi->GetSubType();
#endif
			auto subscriptionId = IAP()->GetBundleOldSubscription(i);

			if (subscriptionId)
			{
				if (reqCurrency != "hc")
					continue;

				if (minimumRequired > 0)
					continue;
			}
			else
			{
				if (currency != reqCurrency)
					continue;

				if (crmi->GetAmount() < minimumRequired && crmi->GetAmount() < highest_amount)	// --- don't hide the highest pack
					continue;
			}

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
			{
				showDescription = true;
				descriptionId = IAP()->GetItemHashId(crmi);
			}

			gameswf::ASObject* itemSwf = CreateIAPItem(i, extra_categories[i], hasPromo, smallest_price, smallest_amount, fx->getPlayer(), skipShowSubcription);
			if (itemSwf)
			{
				currencyPacksSwf->push(itemSwf);
			}
		}
		marketDataSwf->setMemberByName("currencyPacks", currencyPacksSwf);

		{
			bool havePacks = IAP()->GetItemsCount() > 0;
			GetOnlineManager()->SendOCTEvent(of::SHOP, havePacks ? of::SUCCESS : of::FAIL, "", 0);
		}
	}

	if (showDescription)
		marketDataSwf->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));

	GetShopManager()->ResetNotEnoughFlow();

	{
		GET_BASE_RETURN(marketDataSwf);
		fx->getStage().dispatchEvent(CPP_SEND_CREDITS_DATA, members, membersLength);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_OnCreditsBuy(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	std::string id = data["id"].toString().c_str();
	StringHash hash = StringHash(id.c_str());

	size_t i = IAP()->FindItem(hash);

	if (i == (size_t)-1)
	{
		GetShopManager()->AcceptOffer(hash);
		return;
	}

	StringHash subscription = (i != (size_t)-1) ? IAP()->GetBundleOldSubscription(i) : StringHash(0);
	if (subscription)
	{
		auto sub_data = GetShopManager()->GetOldSubscriptionData(subscription);
		if (sub_data && sub_data->type != CShopManager::ESTF_STEALTH)
		{
			GetMenuManager()->ShowBuySubscriptionPopup(i);
			return;
		}
	}

	GetShopManager()->ClearLastTranzactionItemsInfo();
	bool ret = IAP()->BuyRequest(hash);

#if defined _DEBUG
	unsigned idx = IAP()->FindItem(hash);
	if (idx < IAP()->GetItemsCount())
	{
		const auto crmi = IAP()->GetCRMItem(idx);
		// --- TODO buy it
		if (crmi->GetBillingMethodCount() > 0)
		{
			DEBUG_OUT("%s", crmi->GetBillingMethod(0)->GetExtendedField("content_id").ToString().c_str());
		}
	}
#endif	// _DEBUG
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_SendHcMarketData(StringHash category)
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_CREDITS_DATA))
	{
		return;
	}

	static StringHash lastCategory = 0;
	if (category)
		lastCategory = category;
	else
		category = lastCategory;

	gameswf::ASObject* marketDataSwf = swfnew gameswf::ASObject(fx->getPlayer());

	bool showDescription = !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_OFFLINE);
	StringHash descriptionId = 0;

	struct OfferData
	{
		const ShopOffer* offer;
		int place;

		OfferData(const ShopOffer* offer = nullptr, int place = 0) : offer(offer), place(place) {}
	};
	std::vector<OfferData> offers;
	{
		auto poffers = GetShopManager()->GetOffersInCategory(category);
		poffers.erase(std::remove_if(poffers.begin(), poffers.end(), [](const ShopOffer* p) { return p->inItem.empty(); }), poffers.end());	// --- remove offers that are disabled (instead of send them with price 0)
		if (poffers.empty())
			return;

		offers.reserve(poffers.size());
		for (auto offer : poffers)
		{
			if (!offer)
				continue;

			int place = 0;
			for (auto xtra : offer->xtra)
			{
				const auto& txt = GetShopManager()->Hash2Name(xtra);
				place = std::strtol(txt.c_str(), nullptr, 10);
				if (place > 0)
					break;
			}
			offers.emplace_back(offer, place);
		}
	}

	if (std::all_of(offers.begin(), offers.end(), [](const OfferData& p) { return p.place > 0; }))
	{
		std::sort(offers.begin(), offers.end(), [](const OfferData& p1, const OfferData& p2) { return p1.place < p2.place; });
	}

	gameswf::ASArray* currencyPacksSwf = swfnew gameswf::ASArray(fx->getPlayer());
	for (const auto& data : offers)
	{
		if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_OFFLINE, data.offer->id))
		{
			showDescription = true;
			descriptionId = data.offer->id;
		}

		gameswf::ASObject* itemSwf = CreateHCItem(data.offer, fx->getPlayer());
		if (itemSwf)
		{
			currencyPacksSwf->push(itemSwf);
		}
	}
	marketDataSwf->setMemberByName("currencyPacks", currencyPacksSwf);


	if (showDescription)
		marketDataSwf->setMemberByName(KSTR("description"), GetShopManager()->GetOfflineItemsPromoDescription(descriptionId));

	//	auto debugstr = gameswf::toJsonValue(marketDataSwf).toStyledString();
	//	debugstr = debugstr;

	{
		GET_BASE_RETURN(marketDataSwf);
		fx->getStage().dispatchEvent(CPP_SEND_CREDITS_DATA, members, membersLength);
	}

	if (category == "pack_neutronium")
	{
		GameAdsManager::TVideoState videoStateNeutronium = ADS()->GetVideoState(GameAdsManager::k_Neutronium);
		bool canShowVideoNeutronium = videoStateNeutronium.isAvailableFromCrom &&
			(ADS()->IsIncentivizedAvailable(videoStateNeutronium.m_video[crm::k_szPopupAdsLocation].asString()) == adslib::AvailabilityStatus::ADS_STATUS_AVAILABLE);

		if (canShowVideoNeutronium)
		{
			fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_WATCH_VIDEO_BUTTON);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForConsumables(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue inputData = eventState.m_event["data"];

	bool showArenaBundles = false;
	showArenaBundles = inputData["arenaBundles"].toBool();
	GetMenuManager()->SetBundleArena(showArenaBundles);
	Shop_SendBundlesData(showArenaBundles);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BundleListArray::BundleListArray(gameswf::Player* fxPlayer, int additionalInfoFlags)
	: arr(nullptr)
	, fxPlayer(fxPlayer)
	, additionalInfoFlags(additionalInfoFlags)
{
}


void BundleListArray::AddItem(StringHash hash, int qty)
{
	if (qty <= 0)
		return;

	gameswf::ASObject* entry = nullptr;

	if (std::find(credits_to_skip.begin(), credits_to_skip.end(), hash) != credits_to_skip.end())
		return;

	auto credit = GetShopManager()->FindShopItem(hash);

	if (!credit)
	{
		auto item = GetShopManager()->FindGachaPreset(hash);
		if (item.item)
		{
			credit = GetShopManager()->FindShopItem(item.item);
			if (credit)
			{
				qty *= item.qty;

				const auto& pseudocredit = GetShopManager()->FindPseudocredit(item.item);
				if (pseudocredit.credit)
				{
					hash = item.item;
				}
				else
				{
					hash = credit->id;
				}
			}
		}
	}

	const auto& pseudocredit = GetShopManager()->FindPseudocredit(hash);

	if (!credit)
		return;

	{
		auto name = credit->name.Get();
		auto creditId = name.c_str();

		auto category = GetShopManager()->Hash2Name(credit->category.GetHash());
		if (category == "gift" || category == "subscription" || category == "mc5_gift" || category == "utility")
			return;

		if (credit->refillFor)
		{
			entry = swfnew gameswf::ASObject(fxPlayer);
			entry->setMemberByName("id", GetShopManager()->Hash2Name(credit->refillFor).c_str());
			entry->setMemberByName("value", GetStringsMgr()->GetStringFromHash("STR_FPS_MENU_FLASH_REFILLED"));

			auto refill_credit = GetShopManager()->FindShopItem(credit->refillFor);
			if (refill_credit)
				entry->setMemberByName("type", GetShopManager()->Hash2Name(refill_credit->category).c_str());

			credits_to_skip.push_back(credit->refillFor);
			auto it = std::find(added_credits.begin(), added_credits.end(), credit->refillFor);
			while (it != added_credits.end())
			{
				auto idx = std::distance(added_credits.begin(), it);
				arr->remove(idx);
				added_credits.erase(it);
				it = std::find(added_credits.begin(), added_credits.end(), credit->refillFor);
			}
		}
		else
		{
			entry = SwfCards(arr).Make(fxPlayer, hash, qty, Json::Value::null, Json::Value::null);
		}
#if 0	// -- disabled, use the other function
		else
		{
#ifdef ENABLE_KARMA
			if (credit->id == StringHash(SHOP_ITEM_KARMA))
			{
				entry->setMemberByName(KSTR("id"), credit->name.Get().c_str());
				entry->setMemberByName(KSTR("type"), credit->name.Get().c_str());
				entry->setMemberByName(KSTR("value"), qty);

				const auto& mp_data = GetShopManager()->GetMultiplayerData();
				const std::string& name = mp_data.FindKarmaRarity(qty);
				entry->setMemberByName(KSTR("rarity"), name.c_str());

				auto item = GetShopManager()->FindShopItem(SHOP_ITEM_KARMA);
				auto value = GetShopManager()->GetShopItemCurrentValue(item);
				auto gaugePoints = mp_data.GetKarmaGaugePoints();
				float karma_balance = ((float)(qty) / gaugePoints);

				auto totalValue = mp_data.GetKarmaGaugeMaxNb();

				gameswf::ASObject* swfprogress = swfnew gameswf::ASObject(fxPlayer);
				swfprogress->setMemberByName(KSTR("before"), karma_balance);
				swfprogress->setMemberByName(KSTR("after"), karma_balance);
				swfprogress->setMemberByName(KSTR("total"), totalValue);

				entry->setMemberByName(KSTR("progress"), swfprogress);

			}
			else
#endif
				if (credit->category == StringHash(SHOP_ITEM_CATEGORY_GIVE_UNLIMITED) ||
					credit->category == StringHash(SHOP_ITEM_CATEGORY_GIVE_MODIFIER) ||
					credit->category == StringHash(SHOP_ITEM_CATEGORY_GIVE_DEPUTY))
				{
					auto offer = GetShopManager()->FindShopOffer(credit->id);
					if (!offer)
						return;

					StringHash itemForCategory;
					if (credit->category == StringHash(SHOP_ITEM_CATEGORY_GIVE_UNLIMITED))
						itemForCategory = StringHash(SHOP_ITEM_CATEGORY_UNLIMITED_FOR);
					else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_GIVE_MODIFIER))
						itemForCategory = StringHash(SHOP_ITEM_CATEGORY_MODIFIER_FOR);
					else // if (credit->category == StringHash(SHOP_ITEM_CATEGORY_GIVE_DEPUTY))
						itemForCategory = StringHash(SHOP_ITEM_CATEGORY_DEPUTY);

					const auto& outItems = offer->outItems;
					const ShopItemQty* itemFor = nullptr;
					const ShopItemQty* timeItem = nullptr;
					for (const auto& outItem : outItems)
					{
						auto shopItem = GetShopManager()->FindShopItem(outItem.item);
						if (!itemFor && shopItem->category == itemForCategory)
						{
							itemFor = &outItem;
							continue;
						}
						else if (!timeItem && shopItem->category == StringHash(SHOP_ITEM_CATEGORY_TIME))
						{
							timeItem = &outItem;
							continue;
						}
					}
					if (!itemFor || !timeItem)
						return;

					credit = GetShopManager()->FindShopItem(itemFor->item);
					qty = itemFor->qty.Get();

					entry->setMemberByName(KSTR("id"), credit->name.Get().c_str());
					entry->setMemberByName(KSTR("type"), GetShopManager()->Hash2Name(credit->category).c_str());
					entry->setMemberByName(KSTR("value"), std::to_string(qty).c_str());
					entry->setMemberByName(KSTR("time"), timeItem->qty.Get() * 60);
				}
				else if (credit->category == StringHash(SHOP_OFFER_CATEGORY_GIVE_NEUTRONIUM))
				{
					entry->setMemberByName("type", KSTR("currency"));
					entry->setMemberByName("id", KSTR("neutronium"));
				}
				else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_GIVE_WINSTREAK))
				{
					entry->setMemberByName("type", KSTR("win_streak"));
					entry->setMemberByName("id", creditId);
					entry->setMemberByName("showInfoBox", true);
				}
				else
				{
					entry->setMemberByName("type", category.c_str());
					entry->setMemberByName("id", creditId);
				}

			auto maxQty = GetShopManager()->GetMaxQty(credit);
			if (maxQty > 0)
				entry->setMemberByName(KSTR("maxValue"), maxQty);

			if (credit->category == StringHash(SHOP_ITEM_CATEGORY_CURRENCY) ||
				credit->category == StringHash(SHOP_ITEM_CATEGORY_GIVE_WINSTREAK) ||
				credit->category == StringHash(SHOP_ITEM_CATEGORY_EVENT_CURRENCY))
			{
				entry->setMemberByName("value", std::to_string(qty).c_str());
			}
			else if (GetShopManager()->GetMaxQty(credit) == 1)
			{
				entry->setMemberByName("value", GetShopManager()->GetShopItemDisplayName(credit));
			}
			else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_ACTIVATE_CURRENCY) && credit->id == SHOP_ITEM_LUCKY_KEY)
			{
				entry->setMemberByName(KSTR("id"), KSTR("bronze_key")); // --- TODO: merge with above after rename in flash
				entry->setMemberByName("value", std::to_string(qty).c_str());
			}
			else
			{
				char buff[32];
				glf::Snprintf(buff, GetStringsMgr()->GetStringFromHash(StringHash("STR_FPS_MENU_FLASH_GIFT_POPUP_REWARD_AMOUNT")), qty);
				entry->setMemberByName("value", buff);
				// --- this is in order to have easier access to it when displaying the tooltip
				entry->setMemberByName("_qty", std::to_string(qty).c_str());
			}

			if (credit->category == StringHash(SHOP_ITEM_CATEGORY_CRAFT_PART) ||
				credit->category == StringHash(SHOP_ITEM_CATEGORY_DRONE_CRAFT_PART))
			{
				auto wdmgr = WeaponDataManager();
				auto partId = part_key_t(hash);
				auto partAttr = wdmgr->GetPartAttribute(partId);
				if (!partAttr)
					return;

				entry->setMemberByName(KSTR("id"), wdmgr->GetWeaponAttributeName(partAttr));
				entry->setMemberByName(KSTR("rarity"), wdmgr->GetPartRarity(partId));
				entry->setMemberByName(KSTR("internalName"), GetShopManager()->Hash2Name(credit->id).c_str());
			}
			else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_WEAPON) ||
				credit->category == StringHash(SHOP_ITEM_CATEGORY_DRONE_WEAPON))
			{
				auto wdmgr = WeaponDataManager();
				entry->setMemberByName("icon", wdmgr->GetWeaponIcon(credit->id));
				entry->setMemberByName("value", wdmgr->GetWeaponName(credit->id));
				entry->setMemberByName(KSTR("minDamage"), PLAYER_PROFILE()->GetWeaponMinPower(credit->id));
				entry->setMemberByName(KSTR("crtDamage"), PLAYER_PROFILE()->GetWeaponAttributeValue(credit->id, "Power"));
				entry->setMemberByName(KSTR("maxDamage"), PLAYER_PROFILE()->GetWeaponMaxPower(credit->id));
				entry->setMemberByName("damagePerClip", PLAYER_PROFILE()->GetWeaponDPC(credit->id));
				entry->setMemberByName("rarity", wdmgr->GetWeaponRarityIcon(credit->id));
				auto charges = ConstructChargesInfo(fxPlayer, hash, nullptr);
				if (charges)
					entry->setMemberByName(KSTR("charges"), charges);
				if (additionalInfoFlags & SwfCards::WeaponModifiers)
				{
					AddWeaponModifiersInfo(entry, credit->id);
				}
				Weapons_AddWeaponAffinities(entry, credit->id, false);
				Weapons_AddWeaponRegionInterval(entry, credit->id);
			}
			else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_PVP_FLAG))
			{
				const auto& mp_data = GetShopManager()->GetMultiplayerData();
				entry->setMemberByName(KSTR("value"), PLAYER_PROFILE()->PvpFlagDefense(credit->id));

				Multiplayer_AddPvpFlagPerkData(entry, credit->id);
			}
			else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_WEAPON_PART) ||
				credit->category == StringHash(SHOP_ITEM_CATEGORY_DRONE_PART))
			{
				auto wdmgr = WeaponDataManager();
				auto weaponID = wdmgr->FindWeaponForPartCredit(credit->id);
				entry->setMemberByName("id", wdmgr->GetWeaponInternalName(weaponID));
				entry->setMemberByName("icon", wdmgr->GetWeaponIcon(weaponID));
				entry->setMemberByName("rarity", wdmgr->GetWeaponRarityIcon(weaponID));
				if (wdmgr->GetWeaponClass(weaponID) == weapon_class_key_t("Prototype"))
				{
					entry->setMemberByName(KSTR("weaponClass"), "prototype");
				}
			}
			else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_PLAYER_CARD))
			{
				const auto& mp_data = GetShopManager()->GetMultiplayerData();
				entry->setMemberByName(KSTR("id"), creditId);
				entry->setMemberByName(KSTR("icon"), mp_data.GeIconOfId(credit->id));
				entry->setMemberByName(KSTR("value"), GetStringsMgr()->GetStringFromHash(mp_data.GetNameOfId(credit->id)));
				entry->setMemberByName(KSTR("tier"), pseudocredit.rating ? pseudocredit.rating : mp_data.GetRatingOfId(credit->id));
				entry->setMemberByName(KSTR("specialization"), mp_data.GetClassOfId(credit->id));
				AddSquadMateAttribs(entry, credit->id, mp_data);
				entry->setMemberByName(KSTR("amount"), (std::to_string(qty) + "x").c_str());
			}
			else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_PLAYER_CARD_PART))
			{
				auto creditName = credit->name.Get();
				entry->setMemberByName("type", "class_xp");
				const auto& mp_data = GetShopManager()->GetMultiplayerData();
				entry->setMemberByName(KSTR("id"), creditName.c_str());
				entry->setMemberByName(KSTR("rarity"), creditName.c_str());
				entry->setMemberByName(KSTR("value"), qty);
				entry->setMemberByName(KSTR("xp"), mp_data.GetXPForRank(credit->id));
			}
			else if (credit->category == StringHash(SHOP_ITEM_CATEGORY_AVATAR_MODULE))
			{
				const auto& mp_data = GetShopManager()->GetMultiplayerData();
				auto categoryId = mp_data.AvatarModuleCategory(hash);

				entry->setMemberByName(KSTR("category"), mp_data.AvatarCategoryInternalName(categoryId));
				entry->setMemberByName(KSTR("tier"), mp_data.AvatarModuleRarity(hash));
			}
			else if (credit->category == SHOP_ITEM_CATEGORY_SO_BOOST)
			{
				const auto& mp_data = GetShopManager()->GetMultiplayerData();

				entry->setMemberByName("icon", mp_data.SquadOpBoost(credit->id).icon());
				entry->setMemberByName(KSTR("rarity"), mp_data.SquadOpBoost(credit->id).rarity());
			}
			else if (credit->category == SHOP_ITEM_CATEGORY_PVP_BOOST)
			{
				const auto& mp_data = GetShopManager()->GetMultiplayerData();

				entry->setMemberByName("icon", mp_data.PvpBoost(credit->id).icon());
				entry->setMemberByName(KSTR("rarity"), mp_data.PvpBoost(credit->id).rarity());
			}
			else if (credit->category == SHOP_ITEM_CATEGORY_PVP_CONSUMABLE) //ceg arena
			{
				entry->setMemberByName(KSTR("value"), qty);
			}
			else if (credit->category == SHOP_ITEM_CATEGORY_HOLO_BADGE)
			{
				const auto& mp_data = GetShopManager()->GetMultiplayerData();

				entry->setMemberByName(KSTR("rarity"), mp_data.HoloBadge(credit->id).rarity());
			}
			else if (credit->category == SHOP_ITEM_CATEGORY_BULLET_SKIN)
			{
				AddBulletSkinModifiersInfo(credit->id, entry);
			}
			else if (credit->category == SHOP_ITEM_CATEGORY_CAMO)
			{
				AddCamoModifiersInfo(credit->id, entry);
			}
		}
#endif	// 0
	}

	if (!entry)
		return;

	if (!arr)
		arr = swfnew gameswf::ASArray(fxPlayer);
	arr->push(entry);
	added_credits.push_back(hash);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* CreateBundleObject(gameswf::Player* fxPlayer, const ShopOffer* offer, BundleListFlags flags)
{
	if (!offer)
		return nullptr;

	if (offer->inItem.empty())
		return nullptr;

	auto itemSwf = swfnew gameswf::ASObject(fxPlayer);

	itemSwf->setMemberByName("id", (int)offer->id.GetHash());
	itemSwf->setMemberByName("art", "");	// --- TODO
	itemSwf->setMemberByName("name", offer->name.Get().c_str());
	if ((flags & BundleListFlags::ShopV2) && !offer->outItems.empty())
	{
		for (const auto& outItem : offer->outItems)
		{
			auto title = GetShopManager()->GetShopItemDisplayName(outItem.item);
			if (title != "String not found")
			{
				itemSwf->setMemberByName("title", title);
				break;
			}
		}
	}

	gameswf::ASObject* specialOffer;
	auto cost = ConstructCostInfo(fxPlayer, offer->id, &specialOffer);
	itemSwf->setMemberByName("unused", cost);
	if (specialOffer)
		itemSwf->setMemberByName("specialOffer", specialOffer);

	int limit = GetShopManager()->GetShopOfferLimits(offer->id);
	if (limit >= 0)
		itemSwf->setMemberByName("stock", limit);

	//custom sorting and custom pointcuts
	const static std::string customPointcut = "use_pointcut=";
	for (auto xtraHash : offer->xtra)
	{
		const std::string& categStr = GetShopManager()->Hash2Name(xtraHash);
		auto place = std::strtol(categStr.c_str(), nullptr, 10);
		if (place > 0)
		{
			//items_ixs.back().second = place;
			itemSwf->setMemberByName("customListPlace", (int)place);
		}

		if (categStr.find(customPointcut) == 0)
		{
			const std::string pointcutToUse = categStr.substr(customPointcut.length());
			itemSwf->setMemberByName("infoPointcut", pointcutToUse.c_str());
		}

		/*
		 * Latest list of bundle icons:
		 *
		 * Bundle:Consumables_BRONZE
		 * Bundle:Consumables_GOLD
		 * Bundle:Consumables_SILVER
		 * Bundle:Vanity_BRONZE
		 * Bundle:Vanity_GOLD
		 * Bundle:Vanity_SILVER
		 * Bundle:Weapon_BRONZE
		 * Bundle:Weapon_GOLD
		 * Bundle:Weapon_SILVER
		 * Bundle:PVPConsumables_BRONZE
		 * Bundle:PVPConsumables_GOLD
		 * Bundle:PVPConsumables_SILVER
		 *
		 */
		static const std::string bin_xtra("Bundle:");
		if (categStr.find(bin_xtra) == 0)
		{
			itemSwf->setMemberByName("internalName", categStr.c_str() + bin_xtra.length());
		}
	}

	if (!offer->inItem.empty())
	{
		const char* currency = GetShopManager()->Hash2Name(offer->inItem.front().item).c_str();

		auto cost = swfnew gameswf::ASObject(fxPlayer);
		itemSwf->setMemberByName("cost", cost);
		auto money = swfnew gameswf::ASObject(fxPlayer);
		cost->setMemberByName(currency, money);
		money->setMemberByName("value", offer->inItem.front().qty.Get());
		itemSwf->setMemberByName("currency", currency);
		itemSwf->setMemberByName("num", offer->inItem.front().qty.Get());
		if (!offer->inItemReplaced.empty() && offer->inItemReplaced.front().qty > offer->inItem.front().qty)
		{
			money->setMemberByName("oldValue", offer->inItemReplaced.front().qty.Get());
		}
	}

	gameswf::ASObject* swfContent = nullptr;
	if (flags & BundleListFlags::ShopV2)
	{
		swfContent = swfnew gameswf::ASObject(fxPlayer);
		itemSwf->setMemberByName(KSTR("content"), swfContent);

		AddDeckRarityFromExtraCategory(*offer, itemSwf);
		AddDeckTitleFromExtraCategory(*offer, itemSwf);
		AddDeckSizeFromExtraCategory(*offer, itemSwf);

		//itemSwf->setMemberByName("size", "medium"); // --- TODO
	}

	// --- check if there are any weapons, make sure to put them first in case there are
	ShopVector<ShopItemQty>::type outItems;
	if ((flags & BundleListFlags::ShopV2) && offer->outItems.size() > 1)
	{
		// --- see if there's a weapon
		auto wit = std::find_if(offer->outItems.begin(), offer->outItems.end(), [](const ShopItemQty& entry)
			{
				auto shopItem = GetShopManager()->FindShopItem(entry.item);
				return shopItem && shopItem->category == StringHash(SHOP_ITEM_CATEGORY_WEAPON);
			}
		);
		// --- see if there's a non-weapon
		auto nwit = std::find_if(offer->outItems.begin(), offer->outItems.end(), [](const ShopItemQty& entry)
			{
				auto shopItem = GetShopManager()->FindShopItem(entry.item);
				return shopItem && shopItem->category != StringHash(SHOP_ITEM_CATEGORY_WEAPON);
			}
		);
		if (wit != offer->outItems.end() && nwit != offer->outItems.end())
		{
			outItems = offer->outItems;
			std::stable_sort(outItems.begin(), outItems.end(), [](const ShopItemQty& s1, const ShopItemQty& s2)
				{
					auto si1 = GetShopManager()->FindShopItem(s1.item);
					auto si2 = GetShopManager()->FindShopItem(s2.item);
					return si1 && si1->category == StringHash(SHOP_ITEM_CATEGORY_WEAPON) &&
						(!si2 || si2->category != StringHash(SHOP_ITEM_CATEGORY_WEAPON));
				});
		}
	}

	BundleListArray bla(fxPlayer, SwfCards::WeaponModifiers);
	for (const auto& k : (!outItems.empty() ? outItems : offer->outItems))
	{
		bla.AddItem(k.item, k.qty);
	}
	auto list = bla.GetArray();
	if (list)
	{
		if ((flags & BundleListFlags::ShopV2) && swfContent)
			swfContent->setMemberByName(KSTR("cards"), list);
		else
			itemSwf->setMemberByName("list", list);
	}

	// --- check and add 3D content if it should be displayed
	std::vector<StringHash> items;
	items.reserve(offer->outItems.size());
	for (const auto& k : offer->outItems)
	{
		items.push_back(k.item);
	}
	Shop_BundlesCheckAdd3DContent(itemSwf, items);

	// --- add data if this is rental offer
	auto IsKeyInArray = [](StringHash key, const std::vector<StringHash>& arr)
		{
			return std::find(arr.begin(), arr.end(), key) != arr.end();
		};
	if (IsKeyInArray(SHOP_ITEM_XTRA_RENT_BUNDLE, offer->xtra) && offer->name.Get().find("rent_bundle_") == 0)
	{
		auto itemIt = offer->outItems.end(), timeIt = offer->outItems.end();
		for (auto it = offer->outItems.begin(), ite = offer->outItems.end(); it != ite; ++it)
		{
			auto credit = GetShopManager()->FindShopItem(it->item);
			if (credit)
			{
				if (credit->category == StringHash(SHOP_ITEM_CATEGORY_TIME))
				{
					if (timeIt == ite)
						timeIt = it;
				}
				else
				{
					// --- the item will be the first non-time item from the offer
					if (itemIt == ite)
						itemIt = it;
				}
			}
			// --- found everything I was looking for?
			if (itemIt != ite && timeIt != ite)
				break;
		}

		// --- if there's no such item, stop
		if (itemIt == offer->outItems.end())
			return itemSwf;

		// --- get rent duration from time credit in offer - thaomm note
		int rentDuration = 0;
		if (timeIt != offer->outItems.end())
			rentDuration = timeIt->qty.Get() * 60; // --- minutes to seconds

		auto fx = GetMenuManager()->GetRoot(k_MainMenu);
		auto swfPlayer = fx->getPlayer();
		const auto& inventory = PLAYER_PROFILE()->GetInventory();
		auto item = itemIt->item;
		auto itemQty = itemIt->qty.Get();
		auto owned = inventory.GetShopItem(item) > 0;
		auto expiry = inventory.ItemExpiry(item);
		auto status =
			(owned && expiry == 0) ? "owned" :
			owned ? "rented" :
			"available";

		// --- status
		itemSwf->setMemberByName("status", status);

		// --- rent duration
		if (rentDuration)
			itemSwf->setMemberByName("rentDuration", ConstructTimeLeft(rentDuration, swfPlayer));
	}

	return itemSwf;
}

static const std::vector<std::pair<StringHash, const char*>> eventTypeXtraMapping =
{
	{ StringHash("demon"), EVENT_TYPE_RED_BOSS },
	{ StringHash("survival"), EVENT_TYPE_SURVIVAL },
	{ StringHash("coop"), EVENT_TYPE_COOP },
	{ StringHash("skirmish"), EVENT_TYPE_SKIRMISH },
};

struct BundlesData
{
	gameswf::ASArray* list;

	bool hasIAPPromo = false;
	bool hasIAPBundle = false;
	bool hasOfflineBundle = false;
	bool hasGameBundle = false;
};

// Helper to check if a StringHash is present in an extra array.
static bool IsKeyInArray(StringHash key, const std::vector<StringHash>& arr)
{
	return std::find(arr.begin(), arr.end(), key) != arr.end();
}

// Shared filter matcher for IAP bundles (JSON extras)
static bool MatchesFilter(BundleListFilter filter, const Json::Value& jex)
{
	if (filter == BundleListFilter::Arena && !BundleHasExtracategory(jex, SHOP_ITEM_XTRA_ARENA_BUNDLE)) return false;
	if ((filter == BundleListFilter::Daily && !BundleHasExtracategory(jex, SHOP_ITEM_XTRA_DAILY_BUNDLE)) ||
		(filter != BundleListFilter::Daily && BundleHasExtracategory(jex, SHOP_ITEM_XTRA_DAILY_BUNDLE))) return false;
	if ((filter == BundleListFilter::Events && GetBundleExtraCategoryValue(jex, SHOP_ITEM_XTRA_EVENT_TYPE_BUNDLE).empty()) ||
		(filter != BundleListFilter::Events && !GetBundleExtraCategoryValue(jex, SHOP_ITEM_XTRA_EVENT_TYPE_BUNDLE).empty())) return false;
	if ((filter == BundleListFilter::Rental && !BundleHasExtracategory(jex, SHOP_ITEM_XTRA_RENT_BUNDLE)) ||
		(filter != BundleListFilter::Rental && BundleHasExtracategory(jex, SHOP_ITEM_XTRA_RENT_BUNDLE))) return false;
	return true;
}

// Shared filter matcher for offline bundles (extra categories)
static bool MatchesFilter(BundleListFilter filter, const ShopOffer& offer)
{
	if (filter == BundleListFilter::Arena && !IsKeyInArray(SHOP_ITEM_XTRA_ARENA_BUNDLE, offer.xtra)) return false;
	if ((filter == BundleListFilter::Daily && !IsKeyInArray(SHOP_ITEM_XTRA_DAILY_BUNDLE, offer.xtra)) ||
		(filter != BundleListFilter::Daily && IsKeyInArray(SHOP_ITEM_XTRA_DAILY_BUNDLE, offer.xtra))) return false;
	if ((filter == BundleListFilter::Events && GetBundleXtraCategoryValue(offer, SHOP_ITEM_XTRA_EVENT_TYPE_BUNDLE).empty()) ||
		(filter != BundleListFilter::Events && !GetBundleXtraCategoryValue(offer, SHOP_ITEM_XTRA_EVENT_TYPE_BUNDLE).empty())) return false;
	if ((filter == BundleListFilter::Rental && !IsKeyInArray(SHOP_ITEM_XTRA_RENT_BUNDLE, offer.xtra)) ||
		(filter != BundleListFilter::Rental && IsKeyInArray(SHOP_ITEM_XTRA_RENT_BUNDLE, offer.xtra))) return false;
	return true;
}

// Shared rent-offer lookup to avoid duplicate loops.
static gameswf::ASObject* FindRentOffer(gameswf::Player* fxPlayer, BundleListFlags flags, const std::function<bool(const ShopOffer&, const std::string&)>& match)
{
	for (int i = 1;; ++i)
	{
		auto xtra = "rent_bundle_" + std::to_string(i);
		auto xtraOffer = GetShopManager()->FindShopOffer(StringHash(xtra.c_str()));
		if (!xtraOffer)
			break;
		if (!IsKeyInArray(SHOP_ITEM_XTRA_RENT_BUNDLE, xtraOffer->xtra))
			continue;
		if (!match(*xtraOffer, xtra))
			continue;
		return CreateBundleObject(fxPlayer, xtraOffer, flags);
	}
	return nullptr;
}

BundlesData Shop_ConstructBundlesData(gameswf::Player* fxPlayer, BundleListFilter filter, BundleListFlags flags)
{
	BundlesData ret;
	auto consumables = swfnew gameswf::ASArray(fxPlayer);

	// --- IAP bundles first
	{
		for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

			const std::string& type = crmi->GetType();
			if (!crmi->HasBundleItems())
				continue;

			if (crmi->GetBillingMethodCount() < 1)
				continue;

			if (IAP()->GetBundleOldSubscription(i))	// --- subscriptions are in hc section
				continue;

			Json::Value jex;
			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Reader rd;
				rd.parse(sjex, jex);
			}

			if (!MatchesFilter(filter, jex))
				continue;

			// --- TODO: forced promo layout
			if (crmi->HasPricePromotion())
				ret.hasIAPPromo = true;

			auto itemSwf = CreateBundleIAPItem(i, jex, fxPlayer, flags);

			if (itemSwf)
			{
				ret.hasIAPBundle = true;

				// --- early out in case we just want to see if there are any items here
				if (flags & BundleListFlags::CheckExistOnly)
					return ret;

				if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
				{
					ret.hasIAPPromo = true;
					itemSwf->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(IAP()->GetItemHashId(crmi)));
				}

				// rental shop IAP bundle
				if (filter == BundleListFilter::Rental)
				{
					itemSwf->setMemberByName("rentalShop", true);
					auto rentOffer = FindRentOffer(fxPlayer, flags, [&jex](const ShopOffer& offer, const std::string& xtra)
						{
							return BundleHasExtracategory(jex, xtra.c_str());
						});
					if (rentOffer)
						itemSwf->setMemberByName("rentOffer", rentOffer);
					if (crmi->HasPricePromotion())
					{
						auto timeLeft = ConstructIAPTimeLeft(fxPlayer);
						if (timeLeft)
							itemSwf->setMemberByName(KSTR("timeLeft"), timeLeft);
					}
				}
				consumables->push(itemSwf);
			}
		}
	}

	// --- hc bundles next
	const std::string bundleIdBaseArr[] = { "squadmate_bundle_", "bundle_", "chain_offer_hc_", "event_chain_hc_", "daily_chain_hc_" };
	for (const auto& bundleIdBase : bundleIdBaseArr)
	{
		bool isChainStart = true;
		for (int i = 1;; ++i)
		{
			auto bundleId = bundleIdBase + std::to_string(i);
			auto bundleOffer = GetShopManager()->FindShopOffer(StringHash(bundleId.c_str()));

			if (!bundleOffer)
				break;

			// --- check for already owned item
			if (GetShopManager()->ShouldHideBundle(StringHash(bundleId.c_str())))
				continue;

			if (!MatchesFilter(filter, *bundleOffer))
				continue;

			bool hasOfflinePromo = GetShopManager()->OfferHasPromo(*bundleOffer);

			auto itemSwf = CreateBundleObject(fxPlayer, bundleOffer, flags);
			if (itemSwf)
			{
				ret.hasOfflineBundle = true;

				// --- early out in case we just want to see if there are any items here
				if (flags & BundleListFlags::CheckExistOnly)
					return ret;

				if (bundleIdBase == "chain_offer_hc_" || bundleIdBase == "event_chain_hc_" || bundleIdBase == "daily_chain_hc_")
				{
					itemSwf->setMemberByName("category", "chain_offer_hc");
					itemSwf->setMemberByName("chainIndex", i);
					if (isChainStart)
					{
						itemSwf->setMemberByName("isChainStart", true);
						isChainStart = false;
					}
					else
					{
						itemSwf->setMemberByName("isChainStart", false);
					}
					auto timeLeft = ConstructOfflineItemsTimeLeft(fxPlayer, bundleOffer->id);
					if (timeLeft)
						itemSwf->setMemberByName(KSTR("timeLeft"), timeLeft);
				}

				if (IsKeyInArray("mystery", bundleOffer->xtra))
				{
					itemSwf->setMemberByName("mystery", true);
				}

				// rental shop bundle
				if (filter == BundleListFilter::Rental && bundleIdBase != "rent_bundle_")
				{
					itemSwf->setMemberByName("rentalShop", true);

					// --- add offer has name of this bundle's extra category
					auto rentOffer = FindRentOffer(fxPlayer, flags, [bundleOffer](const ShopOffer& offer, const std::string& xtra)
						{
							return IsKeyInArray(StringHash(xtra.c_str()), bundleOffer->xtra);
						});
					if (rentOffer)
						itemSwf->setMemberByName("rentOffer", rentOffer);
				} // end rent bundle 

				if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_OFFLINE, bundleOffer->id))
					itemSwf->setMemberByName(KSTR("description"), GetShopManager()->GetOfflineItemsPromoDescription(bundleOffer->id));
				if (hasOfflinePromo)
				{
					ret.hasIAPPromo = true;
					auto timeLeft = ConstructOfflineItemsTimeLeft(fxPlayer, bundleOffer->id);
					if (timeLeft)
						itemSwf->setMemberByName(KSTR("timeLeft"), timeLeft);
				}

				// --- override the title with the event title for the event bundles if an event of that type exists
				if (filter == BundleListFilter::Events)
				{
					auto eventType = StringHash(GetBundleXtraCategoryValue(*bundleOffer, SHOP_ITEM_XTRA_EVENT_TYPE_BUNDLE).c_str());
					auto it = std::find_if(eventTypeXtraMapping.begin(), eventTypeXtraMapping.end(), [eventType](const std::pair<StringHash, const char*>& entry) { return entry.first == eventType; });
					if (it != eventTypeXtraMapping.end())
					{
						const SemEvent* evt = sem_helpers::GetUniqueEvent(it->second);
						if (evt)
						{
							const auto lang = GetApplication()->GetLanguageStringISO_639_2();
							itemSwf->setMemberByName("title", ProcessUnicodeText(evt->GetName()[lang].asString().c_str()));
						}
					}
				}

				consumables->push(itemSwf);
			}
		}
	}

	// custom sort if all items have the required custom position in extra category
	bool customOrder = true;
	auto customOrderedConsumables = swfnew gameswf::ASArray(fxPlayer);
	{
		enum ECurrency { MONEY, HC, OTHER };
		enum EIcon { GOLD, SILVER, BRONZE, NONE };
		struct SortInfo
		{
			int idx;
			int order = 1024;
			float price = 0;
			ECurrency currency = OTHER;
			EIcon icon = NONE;

			explicit SortInfo(int idx) : idx(idx) {}
			SortInfo(int idx, int order) : idx(idx), order(order) {}
			SortInfo(int idx, float price, ECurrency currency, EIcon icon) : idx(idx), price(price), currency(currency), icon(icon) {}
		};
		std::vector<SortInfo> ordermap;
		for (size_t i = 0; i < consumables->size(); ++i)
		{
			auto itemSwf = consumables->get(i);
			gameswf::ASValue place;
			if ((itemSwf.toObject())->getMemberByName("customListPlace", &place))
			{
				ordermap.emplace_back(i, place.toInt());
			}
			else
			{
				gameswf::ASValue currency;
				gameswf::ASValue value;
				gameswf::ASValue internalName;
				if ((itemSwf.toObject())->getMemberByName("currency", &currency) &&
					(itemSwf.toObject())->getMemberByName("num", &value))
				{
					std::string iconstr;
					if ((itemSwf.toObject())->getMemberByName("internalName", &internalName))
					{
						iconstr = internalName.toString().c_str();
					}
					ECurrency ec = OTHER;
					std::string ecstr = currency.toString().c_str();
					if (ecstr == "money") ec = MONEY;
					else if (ecstr == "hc") ec = HC;
					EIcon icon = NONE;
					if (iconstr.find("GOLD") != std::string::npos) icon = GOLD;
					else if (iconstr.find("SILVER") != std::string::npos) icon = SILVER;
					else if (iconstr.find("BRONZE") != std::string::npos) icon = BRONZE;
					ordermap.emplace_back(i, value.toFloat(), ec, icon);
				}
				else
				{
					ordermap.emplace_back(i);
				}
			}
		}
		if (customOrder)
		{
			std::sort(ordermap.begin(), ordermap.end(), [](const SortInfo& s1, const SortInfo& s2)
				{
					if (s1.order != s2.order) return s1.order < s2.order;
					if (s1.currency != s2.currency) return s1.currency < s2.currency;
					if (s1.icon != s2.icon) return s1.icon < s2.icon;
					if (s1.currency != s2.currency) return s1.currency < s2.currency;
					return s1.price > s2.price;
				});
			for (auto it : ordermap)
			{
				auto itemSwf = consumables->get(it.idx);
				customOrderedConsumables->push(itemSwf);
			}
		}
	}

	if (customOrder)
		ret.list = customOrderedConsumables;
	else
		ret.list = consumables;

	return ret;
}

void Shop_SendBundlesData(bool isArenaBundle, bool shopV2)
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(shopV2 ? CPP_SEND_SHOP_BUNDLE_DATA : CPP_SEND_CONSUMABLES_DATA))
		return;

	auto fxPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(fxPlayer);

	auto filter = isArenaBundle ? BundleListFilter::Arena : BundleListFilter::Regular;
	auto bundlesData = Shop_ConstructBundlesData(fxPlayer, filter, shopV2 ? BundleListFlags::ShopV2 : BundleListFlags::None);

	data->setMemberByName(shopV2 ? KSTR("list") : KSTR("consumables"), bundlesData.list);

	bool showIAPDescription = false;
	bool showOfflineDescription = false;
	bool showGameDescription = false;

	if (bundlesData.hasIAPBundle && !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP))
		showIAPDescription = true;
	else if (bundlesData.hasOfflineBundle && !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_OFFLINE))
		showOfflineDescription = true;
	else if (!GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP) && !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_OFFLINE))
		showGameDescription;

	if (showIAPDescription && GetShopManager()->GetIAPPromoDescription() && *GetShopManager()->GetIAPPromoDescription())
	{
		data->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription());
	}
	else if (showOfflineDescription && GetShopManager()->GetOfflineItemsPromoDescription() && *GetShopManager()->GetOfflineItemsPromoDescription())
	{
		data->setMemberByName(KSTR("description"), GetShopManager()->GetOfflineItemsPromoDescription());
	}
	else if (showGameDescription)
	{
		data->setMemberByName(KSTR("description"), GetShopManager()->GetGameParamsPromoDescription());
	}

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(shopV2 ? CPP_SEND_SHOP_BUNDLE_DATA : CPP_SEND_CONSUMABLES_DATA, members, membersLength);
}

BundlesData Shop_ConstructDailyShopBundles(gameswf::Player* swfPlayer, BundleListFlags flags)
{
	BundlesData ret;
	ret.list = swfnew gameswf::ASArray(swfPlayer);

	auto shopMgr = GetShopManager();

	// --- secondary list - daily_XX offers
	auto dailyOffers = shopMgr->GetOffersInCategory("daily_shop");
	for (const auto& offer : dailyOffers)
	{
		if (offer->inItem.empty() || offer->outItems.empty())
			continue;

		ret.hasOfflineBundle = true;

		// --- early out for checking if any exist only
		if (flags & BundleListFlags::CheckExistOnly)
			return ret;

		auto deck = swfnew gameswf::ASObject(swfPlayer);
		ret.list->push(deck);

		const std::string& name = shopMgr->Hash2Name(offer->id);
		deck->setMemberByName(KSTR("id"), (int)offer->id.GetHash());
		if (!offer->outItems.empty())
		{
			deck->setMemberByName("title", GetShopManager()->GetShopItemDisplayName(offer->outItems.front().item));
		}

		// --- cost & special offer
		gameswf::ASObject* specialOffer = nullptr;
		auto cost = ConstructCostInfo(swfPlayer, offer->id, &specialOffer, nullptr);
		deck->setMemberByName(KSTR("cost"), cost);
		if (specialOffer)
		{
			ret.hasIAPPromo = true;
			deck->setMemberByName("specialOffer", specialOffer);
		}

		// --- time left
		deck->setMemberByName("timeLeft", ConstructTimeLeft(DailyManager::Get()->GetCurrentDailyShopExpiry() - GetShopManager()->GetServerTime(), swfPlayer));

		// --- content
		auto swfContent = swfnew gameswf::ASObject(swfPlayer);
		deck->setMemberByName(KSTR("content"), swfContent);

		auto swfCards = swfnew gameswf::ASArray(swfPlayer);
		swfContent->setMemberByName(KSTR("cards"), swfCards);

		for (const auto& item : offer->outItems)
		{
			SwfCards cards(nullptr);
			auto swfItem = cards.Make(swfPlayer, item.item, item.qty, Json::Value::null, Json::Value::null);
			swfCards->push(swfItem);
		}

		AddDeckRarityFromExtraCategory(*offer, deck);
		AddDeckTitleFromExtraCategory(*offer, deck);
		AddDeckSizeFromExtraCategory(*offer, deck);

		// --- check and add 3D content if it should be displayed
		std::vector<StringHash> items;
		items.reserve(offer->outItems.size());
		for (const auto& k : offer->outItems)
		{
			items.push_back(k.item);
		}
		Shop_BundlesCheckAdd3DContent(deck, items);
	}

	return ret;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onBuyConsumables(const gameswf::ASNativeEventState& eventState) // SWF_COMMAND_BUNDLES_BUY
{
	gameswf::ASValue inputData = eventState.m_event["data"];
	StringHash id = inputData["id"].toInt();
	std::string fallback = inputData["fallback_id"].toCStr();
	std::string rentalExtraData = inputData["shop"].toCStr();
	bool isArenaOnly = inputData["isArenaOnly"].toBool();
	//if (GetLevel())
	//{
	//	GetLevel()->OpenIngameMenu();
	//}
//Khoai add - request sms permission when simcard available in GAND
#if GAMELOFT_SHOP
	bool grantToBuyIAP = true;
	if (acp_utils::api::PackageUtils::IsSimCardAvailable())
	{
		grantToBuyIAP = false;
		if (GrantPermission(ANDROID_PERMISSION_SMS))
		{
			grantToBuyIAP = true;
		}
	}
	if (grantToBuyIAP)
#endif
		//Khoai end
	{
		auto iap = IAP()->FindItem(id);
		if (iap != (size_t)-1)
		{
			GetShopManager()->ClearLastTranzactionItemsInfo();
			IAP()->BuyRequest(id);
		}
		else
		{
			if (rentalExtraData != "")
			{
				Json::Value extraData;
				extraData["rentalShop"] = rentalExtraData;
				extraData["isArenaOnly"] = isArenaOnly;
				GetShopManager()->AcceptOffer(id, extraData);
			}
			else if (fallback != "")
			{
				GetShopManager()->AcceptOffer(StringHash(fallback.c_str()));
			}	
			else 
			{
				GetShopManager()->AcceptOffer(id);
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onInfoConumables(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue inputData = eventState.m_event["data"];

	std::string pointcut = inputData["infoPointcut"].toString().c_str();

	//auto debugstr = gameswf::toJsonValue(inputData).toStyledString();
	//debugstr = debugstr;

	CRM()->TriggerPointcutEnterSection(pointcut.c_str()); //trigger pointcut set via extra category
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_ShowBundleConfirmationPopup(StringHash offerId)
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx)
	{
		return;
	}

	GetMenuManager()->SetMenuActive(true, k_Popups);
	GetMenuManager()->MenuCaptureInput(k_Popups);

	auto popup = swfnew gameswf::ASObject(fx->getPlayer());

	popup->setMemberByName("type", "popup_SpecialOffer");
	popup->setMemberByName("name", "specialOfferPopup");
	popup->setMemberByName("titlebar", true);
	popup->setMemberByName("title", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_SPECIALOFFER));

	auto weapons = swfnew gameswf::ASArray(fx->getPlayer());
	popup->setMemberByName("weapons", weapons);

	auto offer = GetShopManager()->FindShopOffer(offerId);
	if (offer)
	{
		for (const auto& item : offer->outItems)
		{
			auto credit = GetShopManager()->FindShopItem(item.item);
			if (credit && credit->category == StringHash("weapon"))
			{
				auto weapon = swfnew gameswf::ASObject(fx->getPlayer());
				weapon->setMemberByName("internalName", WeaponDataManager()->GetWeaponIcon(item.item));
				weapon->setMemberByName("name", GetShopManager()->GetShopItemDisplayName(item.item));
				weapon->setMemberByName("damage", PLAYER_PROFILE()->GetWeaponMinPower(item.item));
				weapons->push(weapon);
			}
		}
	}

	auto customData = swfnew gameswf::ASObject(fx->getPlayer());
	popup->setMemberByName("customData", customData);
	customData->setMemberByName("offerId", (int)offerId.GetHash());

	auto buttons = swfnew gameswf::ASArray(fx->getPlayer());
	popup->setMemberByName("buttons", buttons);

	auto btnCancel = swfnew gameswf::ASObject(fx->getPlayer());
	btnCancel->setMemberByName("name", "btnCancel");
	btnCancel->setMemberByName("label", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_CANCEL));
	btnCancel->setMemberByName("closePopup", true);
	buttons->push(btnCancel);

	auto btnBuy = swfnew gameswf::ASObject(fx->getPlayer());
	btnBuy->setMemberByName("name", "btnBuy");
	btnBuy->setMemberByName("label", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_BUY));
	btnBuy->setMemberByName("closePopup", true);
	if (offer && !offer->inItem.empty())
	{
		btnBuy->setMemberByName("value", offer->inItem.front().qty.Get());
		if (!offer->inItemReplaced.empty())
		{
			btnBuy->setMemberByName("oldValue", offer->inItemReplaced.front().qty.Get());
		}
	}
	buttons->push(btnBuy);

	GET_BASE_RETURN(popup)
		fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_POPUP, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace
{
	std::string currentEnergyPopup;
	StringHash currentEnergyCredit;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Shop_RefreshEnergyPopup()
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx || !fx->getStage().hasEventListener(CPP_COMMAND_REFRESH_POPUP) || currentEnergyPopup.empty() || !currentEnergyCredit)
	{
		return false;
	}

	auto shopMgr = GetShopManager();
	auto giveUnlimitedCredits = shopMgr->GetCreditsInCategory(SHOP_ITEM_CATEGORY_GIVE_UNLIMITED);

	auto data = swfnew gameswf::ASObject(fx->getPlayer());
	data->setMemberByName("name", currentEnergyPopup.c_str());

	auto incomingEnergy = swfnew gameswf::ASArray(fx->getPlayer());
	data->setMemberByName(KSTR("incomingEnergy"), incomingEnergy);

	auto swfGiveUnlimitedCards = swfnew gameswf::ASArray(fx->getPlayer());
	data->setMemberByName("cards", swfGiveUnlimitedCards);
	SwfCards cardsFactory(swfGiveUnlimitedCards);

	do
	{
		auto energyShopItem = shopMgr->IsEnergyCredit(currentEnergyCredit);
		if (!energyShopItem)
			continue;

		auto currentEnergy = shopMgr->GetShopItemCurrentValue(energyShopItem);
		auto maxEnergy = shopMgr->GetRefillQty(energyShopItem);

		if (currentEnergy < maxEnergy)
		{
			auto ts = shopMgr->GetNextCreditRefresh(currentEnergyCredit);
			auto now = shopMgr->GetServerTime();
			if (ts && ts > now)
			{
				auto tl = ts - now;
				auto incomingEnergyEntry = ConstructTimeLeft(tl, fx->getPlayer());
				incomingEnergyEntry->setMemberByName(KSTR("value"), 1);
				incomingEnergyEntry->setMemberByName(KSTR("credit"), shopMgr->Hash2Name(currentEnergyCredit).c_str());
				incomingEnergy->push(incomingEnergyEntry);
			}
		}

		auto unlimitedByCredit = shopMgr->GetUnlimitedBy(energyShopItem->id);
		if (!unlimitedByCredit)
			continue;

		for (const auto* giveUnlimitedCredit : giveUnlimitedCredits)
		{
			auto qty = PLAYER_PROFILE()->GetInventory().GetShopItem(giveUnlimitedCredit->id);
			if (qty <= 0)
				continue;

			auto giveUnlimitedOffer = shopMgr->FindShopOffer(giveUnlimitedCredit->id);
			if (!giveUnlimitedOffer)
				continue;

			auto offerItemIt = std::find_if(giveUnlimitedOffer->outItems.begin(), giveUnlimitedOffer->outItems.end(),
				[unlimitedByCredit](const ShopItemQty& offerItem)
				{
					return offerItem.item == unlimitedByCredit;
				});
			if (offerItemIt == giveUnlimitedOffer->outItems.end())
				continue;

			cardsFactory.Add(giveUnlimitedCredit->id, qty, Json::Value::null, Json::Value::null);
		}
	} while (false);

	GET_BASE_RETURN(data)
		fx->getStage().dispatchEvent(CPP_COMMAND_REFRESH_POPUP, members, membersLength);

	return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onPopupshowActivateItems(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue inData = eventState.m_event["data"];

	//auto debugstr = gameswf::toJsonValue(inData).toStyledString();
	//debugstr = debugstr;

	std::string id = inData["id"].toString().c_str();
	std::string give_id = inData["giveId"].toString().c_str();

	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx || !fx->getStage().hasEventListener(CPP_COMMAND_SHOW_POPUP))
	{
		return;
	}

	GetMenuManager()->SetMenuActive(true, k_Popups);
	GetMenuManager()->MenuCaptureInput(k_Popups);

	auto shopMgr = GetShopManager();
	auto credit = shopMgr->FindShopItem(StringHash(give_id.c_str()));
	auto giveUnlimitedCredits = shopMgr->GetCreditsInCategory(credit->category);
	auto targetCredit = shopMgr->FindShopItem(StringHash(id.c_str()));
	StringHash targetMUFor(0);

	if (targetCredit->category == StringHash("modifier_for"))
	{
		const auto& modifierData = shopMgr->GetModifierForData();
		auto jt = std::find_if(modifierData.begin(), modifierData.end(), [targetCredit](const CShopManager::ModifierFor& mf) { return mf.id == targetCredit->id; });
		if (jt != modifierData.end())
			targetMUFor = jt->for_id;
	}
	else if (targetCredit->category == StringHash("unlimited_for"))
	{
		targetMUFor = shopMgr->GetUnlimitedFor(targetCredit->id);
	}

	auto data = swfnew gameswf::ASObject(fx->getPlayer());
	data->setMemberByName("type", "popup_ActivateItems");
	data->setMemberByName("name", "activateItemsPopup");
	data->setMemberByName("titlebar", true);
	data->setMemberByName("title", GetStringsMgr()->GetStringFromHash("STR_FPS_ACTIVATE_UNLIMITED_ITEMS"));
	data->setMemberByName("closeButton", true);

	auto buttons = swfnew gameswf::ASArray(fx->getPlayer());
	data->setMemberByName("buttons", buttons);

	auto btnActivate = swfnew gameswf::ASObject(fx->getPlayer());
	buttons->push(btnActivate);
	btnActivate->setMemberByName("name", "btnActivate");
	btnActivate->setMemberByName("closePopup", true);
	btnActivate->setMemberByName("label", GetStringsMgr()->GetStringFromHash("STR_FPS_MENU_FLASH_ACTIVATE"));

	auto btnCancel = swfnew gameswf::ASObject(fx->getPlayer());
	buttons->push(btnCancel);
	btnCancel->setMemberByName("name", "btnCancel");
	btnCancel->setMemberByName("closePopup", true);
	btnCancel->setMemberByName("label", GetStringsMgr()->GetStringFromHash("STR_FPS_MENU_FLASH_CANCEL"));

	auto swfGiveUnlimitedCards = swfnew gameswf::ASArray(fx->getPlayer());
	data->setMemberByName("cards", swfGiveUnlimitedCards);
	SwfCards cardsFactory(swfGiveUnlimitedCards);

	auto getNonTimeCredit = [](const std::vector<ShopItemQty>& items) -> StringHash
	{
		auto it = std::find_if(items.begin(), items.end(), [](const ShopItemQty& p) { return p.item != StringHash("time"); });
		return it == items.end() ? StringHash(0) : it->item;
	};

	for (auto shopItem : giveUnlimitedCredits)
	{
		int count = (int)PLAYER_PROFILE()->GetInventory().GetShopItem(shopItem->id);
		if (count > 0)
		{
			auto offer = shopMgr->FindShopOffer(shopItem->id);
			if (offer && !offer->outItems.empty())
			{
				auto giveCredit = shopMgr->FindShopItem(getNonTimeCredit(offer->outItems));
				if (giveCredit && giveCredit->category == targetCredit->category)
				{
					if (targetCredit->category == StringHash("modifier_for"))
					{
						auto jt = std::find_if(shopMgr->GetModifierForData().begin(), shopMgr->GetModifierForData().end(),
							[giveCredit, targetMUFor](const CShopManager::ModifierFor& mf) { return mf.id == giveCredit->id && mf.for_id == targetMUFor; });
						if (jt == shopMgr->GetModifierForData().end())
							continue;
					}
					else if (targetCredit->category == StringHash("unlimited_for"))
					{
						if (shopMgr->GetUnlimitedFor(giveCredit->id) != targetMUFor)
							continue;
					}
					cardsFactory.Add(shopItem->id, count, Json::Value::null, Json::Value::null);
				}
			}
		}
	}


	//auto debugstr2 = gameswf::toJsonValue(data).toStyledString();
	//debugstr2 = debugstr2;

	GET_BASE_RETURN(data)
		fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_POPUP, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onPopupRefillEnergyRefresh(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	std::string popupName = data["popupName"].toString().c_str();
	auto showCards = data["showCards"].toBool();
	if (popupName == "refillEnergyPopup" || popupName == "refillEventEnergyPopup"
		|| popupName == "refillPVPEnergyPopup" || popupName == "refillArenaEnergyPopup")
	{
		std::string energyCredit = data["credit"].toCStr();

		currentEnergyPopup = popupName;
		currentEnergyCredit = StringHash(energyCredit.c_str());

		auto energyShopItem = GetShopManager()->FindShopItem(currentEnergyCredit);
		auto currentEnergy = GetShopManager()->GetShopItemCurrentValue(energyShopItem);
		auto maxEnergy = GetShopManager()->GetRefillQty(energyShopItem);
		if ((currentEnergy < maxEnergy) || showCards)
		{
			Shop_RefreshEnergyPopup();

			GetShopManager()->StartUpdatePerSecond();
		}
		else
		{
			void hideGenericNotificationPopup(const char* eventName);
			hideGenericNotificationPopup("refillEnergyPopup");
			hideGenericNotificationPopup("refillEventEnergyPopup");
			hideGenericNotificationPopup("refillPVPEnergyPopup");
			hideGenericNotificationPopup("refillArenaEnergyPopup");
			GetShopManager()->StopUpdatePerSecond();
		}
	}
	else if (popupName.empty())
	{
		GetShopManager()->StopUpdatePerSecond();
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void onCommandActivateUnlimitedEnergy(const gameswf::ASNativeEventState& eventState)
{
	auto swfData = eventState.m_event[KSTR("data")];
	auto swfDataObject = swfData.toObject();
	auto swfDataArr = static_cast<gameswf::ASArray*>(swfDataObject);

	Json::Value cmdData;
	auto& jItems = cmdData["items"];
	for (auto i = 0, c = swfDataArr->size(); i < c; ++i)
	{
		const auto& swfEntry = swfDataArr->get(i);
		std::string giveId = swfEntry["giveId"].toCStr();
		if (giveId.empty())
			continue;

		jItems[giveId] = swfEntry["amount"].toInt();
	}

	GetOnlineManager()->GetAHGSLobbyManager()->ClientSendShopCommand(antihackgs::ShopCommand::ActivateItems, cmdData);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* ConstructBMOfferList(gameswf::Player* swfPlayer, const char* bmPrefix)
{
	auto shopMgr = GetShopManager();

	auto swfOffers = swfnew gameswf::ASArray(swfPlayer);

	// --- send offer list
	char slotStr[3]; int slot = 1;
	CShopManager::ShopOffer* slotOffer = nullptr;
	while (true)
	{
		glf::Snprintf(slotStr, "%d", slot);
		auto offerId = StringHash(Hash(bmPrefix, (const char*)&slotStr));
		auto offer = slotOffer = shopMgr->FindShopOffer(offerId);
		if (!offer)
			break;

		auto swfOffer = swfnew gameswf::ASObject(swfPlayer);

		swfOffer->setMemberByName("id", shopMgr->Hash2Name(offerId).c_str());

		if (!offer->inItem.empty())
		{
			auto cost = ConstructCostInfo(swfPlayer, offerId, nullptr, nullptr);
			swfOffer->setMemberByName("cost", cost);
		}

		if (!offer->outItems.empty())
		{
			const auto& item = offer->outItems.front();
			SwfCards cards(nullptr);
			swfOffer->setMemberByName("reward", cards.Make(swfPlayer, item.item, item.qty, Json::Value::null, Json::Value::null));
		}

		swfOffers->push(swfOffer);
		++slot;
	}
	return swfOffers;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForBlackMarketData(const gameswf::ASNativeEventState& eventState)
{
	Shop_sendBlackMarketData();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_sendBlackMarketData()
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_BLACK_MARKET_DATA))
	{
		return;
	}

	auto shopMgr = GetShopManager();

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);

	auto swfOffers = ConstructBMOfferList(swfPlayer, "bm_");
	data->setMemberByName("list", swfOffers);

	const auto& bmData = PLAYER_PROFILE()->GetProfileBlackMarketData();
	time_t now = GetShopManager()->GetServerTime();

	// --- time left until auto refresh
	data->setMemberByName("timeLeft", (int)(bmData.autoRefreshTs() - now));

	// --- manual refresh info (either time left until button is available or the refresh cost, or neither (no bm manual refresh possible, offer deactivated from CRM))
	auto refreshOffer = shopMgr->FindShopOffer("bm_refresh");
	bool canRefresh = false;
	if (refreshOffer)
	{
		auto swfRefresh = swfnew gameswf::ASObject(swfPlayer);
		if (refreshOffer->inItem.empty())
		{
			if (bmData.manualRefreshTs())
				swfRefresh->setMemberByName("timeLeft", (int)(bmData.manualRefreshTs() - now));
		}
		else
		{
			auto cost = ConstructCostInfo(swfPlayer, "bm_refresh", nullptr, nullptr);
			swfRefresh->setMemberByName("cost", cost);
		}
		canRefresh = true;
		data->setMemberByName("refresh", swfRefresh);
	}

	// --- restock info
	auto restockOffer = shopMgr->FindShopOffer("bm_restock");
	if (restockOffer && !restockOffer->inItem.empty())
	{
		auto swfRestock = swfnew gameswf::ASObject(swfPlayer);
		data->setMemberByName("restock", swfRestock);

		auto cost = ConstructCostInfo(swfPlayer, "bm_restock", nullptr, nullptr);
		swfRestock->setMemberByName("cost", cost);
	}

	// --- happy hour
	auto happyHour = swfnew gameswf::ASObject(swfPlayer);
	data->setMemberByName("happyHour", happyHour);

	int timeleft = bmData.happyHourEnd() - GetShopManager()->GetServerTime();
	if (timeleft > 0)
	{
		//auto tl = ConstructTimeLeft(timeleft, swfPlayer);
		//if (tl)
		//	happyHour->setMemberByName("timeLeft", tl);
		happyHour->setMemberByName("timeLeft", timeleft);
	}

	auto progress = swfnew gameswf::ASObject(swfPlayer);
	happyHour->setMemberByName("progress", progress);

	progress->setMemberByName("current", timeleft > 0 ? 100 : (int)bmData.happyHourPercent());
	progress->setMemberByName("maximum", 100);

	// --- remove refresh notification
	NOTIFICATIONS()->RemoveNotificationsByCategoryInfo("bm", "refresh");

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_BLACK_MARKET_DATA, members, membersLength);

	GameAdsManager::TVideoState videoStateBMRefresh = ADS()->GetVideoState(GameAdsManager::k_BM_Refresh);
	bool canShowVideoBMRefresh = videoStateBMRefresh.isAvailableFromCrom &&
		(ADS()->IsIncentivizedAvailable(videoStateBMRefresh.m_video[crm::k_szPopupAdsLocation].asString()) == adslib::AvailabilityStatus::ADS_STATUS_AVAILABLE);

	if (canShowVideoBMRefresh && canRefresh)
	{
		fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_WATCH_VIDEO_BUTTON);
	}

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_playAnimationBlackMarketData()
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_BLACK_MARKET_DATA))
	{
		return;
	}

	const auto& bmData = PLAYER_PROFILE()->GetProfileBlackMarketData();
	int timeleft = bmData.happyHourEnd() - GetShopManager()->GetServerTime();
	if (timeleft > 0)
		return;


	fx->getStage().dispatchEvent(CPP_COMMAND_BLACK_MARKET_PLAY_ANIMATION);

}

/**************************/
/*  Shop V2 - Shop Daily  */
/**************************/
void ADD_SHOP_BAR_ITEM(gameswf::Player* swfPlayer, gameswf::ASArray* swfSidebarItems, const char* id, const char* txt, const char* tags = nullptr)
{
	auto swfItem = swfnew gameswf::ASObject(swfPlayer);
	swfItem->setMemberByName("id", id);
	swfItem->setMemberByName("tags", tags ? tags : id);
	swfItem->setMemberByName("label", txt);
	swfSidebarItems->push(swfItem);
}

//tuan.transy - add disable steam overlay popup
void DisableSteamOverlay(const gameswf::ASNativeEventState& eventState)
{
	GetShopManager()->AcceptOffer("pvp_cooldown_steamoverlay");
}

void ShopV2_AskForShopSidebarData(const gameswf::ASNativeEventState& eventState)
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_SHOP_SIDEBAR_DATA))
	{
		return;
	}

	bool dailyPromo = false;
	bool eventPromo = false;
	bool blackMarketPromo = true;
	bool weaponsPromo = false;
	bool bundlePromo = false;
	bool battlePacksPromo = false;
	bool packsPromo = false;
	bool rentalPromo = false;

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);
	BundleListFlags checkOnly = BundleListFlags::CheckPromoOnly; //BundleListFlags::CheckExistOnly

	// --- send bar items list
	auto swfSidebarItems = swfnew gameswf::ASArray(swfPlayer);
	data->setMemberByName("sideBar", swfSidebarItems);

	// --- check if any daily bundles are available, otherwise hide the section
	{
		auto bundlesData = Shop_ConstructBundlesData(swfPlayer, BundleListFilter::Daily, checkOnly);
		dailyPromo = bundlesData.hasIAPPromo;
		auto displaySection = bundlesData.hasIAPBundle || bundlesData.hasOfflineBundle || bundlesData.hasGameBundle;
		if (!displaySection || !dailyPromo)
		{
			auto bundlesData = Shop_ConstructDailyShopBundles(swfPlayer, checkOnly);
			displaySection = bundlesData.hasIAPBundle || bundlesData.hasOfflineBundle || bundlesData.hasGameBundle;
			dailyPromo = dailyPromo || bundlesData.hasIAPPromo;
		}
		if (displaySection)
			ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "daily", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_DAILY)); // DAILY
	}
	// --- check if events are unlocked and if event bundles are available, otherwise hide the section
	if (PLAYER_PROFILE()->FeatureUnlocked("events_unlocked"))
	{
		auto bundlesData = Shop_ConstructBundlesData(swfPlayer, BundleListFilter::Events, (BundleListFlags)(BundleListFlags::ShopV2 | checkOnly));
		eventPromo = bundlesData.hasIAPPromo;
		if (bundlesData.hasIAPBundle || bundlesData.hasOfflineBundle || bundlesData.hasGameBundle)
			ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "event", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_EVENTS));
	}

	// --- black market - only if the feature is unlocked
	if (PLAYER_PROFILE()->FeatureUnlocked("black_market_unlocked"))
	{
		int ret = ShopV2_CheckBMOfferList(swfPlayer, "bm_");
		blackMarketPromo = (ret & ShopV2Flags::ShopV2Promo) != 0;
		ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "blackmarket", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_BLACK_MARKET_CAPS)); // BLACK MARKET
	}

	// --- weapons - 
	{
		static weapon_type_key_t menuWeaponTypes[] = {
			weapon_type_key_t("Sniper"),
			weapon_type_key_t("Assault"),
			weapon_type_key_t("RPG"),
			weapon_type_key_t("Railgun"),
			weapon_type_key_t("HandGun"),
		};
		for (auto menuWeaponType : menuWeaponTypes)
		{
			auto retVal = Weapons_SendWeaponsShopDataShopV2(menuWeaponType, weapon_class_key_t(), ShopV2Flags::ShopV2Promo);
			if ((retVal & ShopV2Flags::ShopV2Promo) != 0)
			{
				weaponsPromo = true;
				break;
			}
		}
		ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "weapons", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_WEAPONS)); // WEAPONS
	}

	// --- rental shop - hide the section if empty - thaomm
	{
		auto bundlesData = Shop_ConstructBundlesData(swfPlayer, BundleListFilter::Rental, checkOnly);;
		rentalPromo = bundlesData.hasIAPPromo;
		if (bundlesData.hasIAPBundle || bundlesData.hasOfflineBundle || bundlesData.hasGameBundle)
			ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "rental", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_RENTAL));
	}

	// --- bundles - hide the section if empty
	{
		auto bundlesData = Shop_ConstructBundlesData(swfPlayer, BundleListFilter::Regular, (BundleListFlags)(BundleListFlags::ShopV2 | checkOnly));
		bundlePromo = bundlesData.hasIAPPromo;
		if (bundlesData.hasIAPBundle || bundlesData.hasOfflineBundle || bundlesData.hasGameBundle)
			ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "bundle", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_BUNDLES)); // BUNDLE - [dannyd todo] use string GEAR
	}

	// --- battlepacks - 
	{
		int retVal = ShopV2_ComputeAndSendBattlepacksInitData(false, ShopV2Flags::ShopV2Promo, BattlepackType::Ordinary);
		battlePacksPromo = (retVal & ShopV2Flags::ShopV2Promo) != 0;
		ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "battlepacks", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_BATTLEPACKS));
	}

	// --- packs - 
	{
		int retVal = ShopV2_AskForShopPacksData(ShopV2Flags::ShopV2Promo);
		packsPromo = (retVal & ShopV2Flags::ShopV2Promo) != 0;
		ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "packs", GetStringsMgr()->GetString(STR_SHOP_PACKS_SECTION_NAME)); // PACKS 
	}
	//ADD_SHOP_BAR_ITEM(swfPlayer, swfSidebarItems, "gear", GetStringsMgr()->GetString(STR_FPS_MENU_GEAR_STATUS)); // GEAR

	{
		GET_BASE_RETURN(data);
		fx->getStage().dispatchEvent(CPP_SEND_SHOP_SIDEBAR_DATA, members, membersLength);
	}

	// Send Notification promo
	{
		if (!fx->getStage().hasEventListener(CPP_EVENT_PROMO_NOTIFICATION))
		{
			return;
		}

		//dailyPromo = true;
		//eventPromo = true;
		//blackMarketPromo = true;
		//weaponsPromo = true;
		//bundlePromo = true;
		//battlePacksPromo = true;
		//packsPromo = true;

		auto dataPromo = swfnew gameswf::ASObject(swfPlayer);
		dataPromo->setMemberByName("dailyPromo", dailyPromo);
		dataPromo->setMemberByName("eventPromo", eventPromo);
		dataPromo->setMemberByName("blackMarketPromo", blackMarketPromo);
		dataPromo->setMemberByName("weaponsPromo", weaponsPromo);
		dataPromo->setMemberByName("bundlePromo", bundlePromo);
		dataPromo->setMemberByName("battlePacksPromo", battlePacksPromo);
		dataPromo->setMemberByName("packsPromo", packsPromo);
		dataPromo->setMemberByName("rentalPromo", rentalPromo);

		// --- BM refresh & happy hour notifications
		dataPromo->setMemberByName("unreadBlackMarket", NOTIFICATIONS()->CheckNotificationFromInfo("bm", "refresh") ? 1 : 0);

		{
			const auto& bmData = PLAYER_PROFILE()->GetProfileBlackMarketData();
			time_t now = GetShopManager()->GetServerTime();

			int hh_timeleft = bmData.happyHourEnd() - now;
			auto hh_active = hh_timeleft > 0;
			if (hh_active)
			{
				auto hh_offer = GetShopManager()->FindShopOffer("bm_1");
				hh_active = hh_offer && !hh_offer->inItem.empty() && !hh_offer->outItems.empty();
			}
			dataPromo->setMemberByName("unreadHappyHour", hh_active ? 1 : 0);
		}

		GET_BASE_RETURN(dataPromo);
		fx->getStage().dispatchEvent(CPP_EVENT_PROMO_NOTIFICATION, members, membersLength);
	}
	//tuan.transy - steam overlay
	ShowSteamOverlayPopup();
	//end
}

void ShopV2_AskForShopDailyData(const gameswf::ASNativeEventState& eventState)
{
	ShopV2_SendDailyData();
}

void ShopV2_WatchShopDailyAds(const gameswf::ASNativeEventState& eventState)
{
	GameAdsManager::TVideoState videoState = ADS()->GetVideoState(static_cast<GameAdsManager::EVideo>(GameAdsManager::k_Shop_Daily));
	if (videoState.isAvailableFromCrom)
		ADS()->StartCurrentVideo(false, static_cast<GameAdsManager::EVideo>(GameAdsManager::k_Shop_Daily));
}

void ShopV2_AskForShopRentalData(const gameswf::ASNativeEventState& eventState)
{
	ShopV2_SendRentalData();
}

void ShopV2_SendDailyData(BundleListFlags flags)
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_SHOP_DAILY_DATA))
	{
		return;
	}

	auto shopMgr = GetShopManager();

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);

	// --- CRM bundles list
	auto bundlesData = Shop_ConstructBundlesData(swfPlayer, BundleListFilter::Daily, flags);
	data->setMemberByName("list", bundlesData.list);

	// --- daily_XX bundles list
	auto secondListBundlesData = Shop_ConstructDailyShopBundles(swfPlayer, flags);

	auto dailyDeals = swfnew gameswf::ASObject(swfPlayer);
	data->setMemberByName("dailyDeals", dailyDeals);

	dailyDeals->setMemberByName("list", secondListBundlesData.list);
	dailyDeals->setMemberByName("timeLeft", ConstructTimeLeft(DailyManager::Get()->GetCurrentDailyShopExpiry() - GetShopManager()->GetServerTime(), swfPlayer));

	//auto debugstr = gameswf::toJsonValue(data).toStyledString();
	//debugstr = debugstr;

	// --- shop daily ads
	auto shopDailyAds = swfnew gameswf::ASObject(swfPlayer);
	data->setMemberByName("shopDailyAds", shopDailyAds);
	int dailyCnt = PLAYER_PROFILE()->GetShopDailyAdsCount();
	int64 time = PLAYER_PROFILE()->GetShopDailyCooldownEnd();
	shopDailyAds->setMemberByName("adsCnt", dailyCnt);
	shopDailyAds->setMemberByName("timeLeft", ConstructTimeLeft(time - GetShopManager()->GetServerTime(), swfPlayer));
	GameAdsManager::TVideoState videoState_shopDaily = ADS()->GetVideoState(GameAdsManager::k_Shop_Daily);
	bool isAvailable = videoState_shopDaily.isAvailableFromCrom && ADS()->IsIncentivizedAvailable(videoState_shopDaily.m_video[crm::k_szPopupAdsLocation].asString()) == adslib::AvailabilityStatus::ADS_STATUS_AVAILABLE;
	shopDailyAds->setMemberByName("isAvailable", isAvailable);
	Json::Value adsConfig = GetShopManager()->GetHestiaAdsConfig()["shop_daily"];
	shopDailyAds->setMemberByName("smallReward", adsConfig["milestone_reward_normal"].asString().c_str());
	shopDailyAds->setMemberByName("bigReward", adsConfig["milestone_reward_end"].asString().c_str());
	shopDailyAds->setMemberByName("maxRound", adsConfig["max_round"].asInt());
	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_SHOP_DAILY_DATA, members, membersLength);
}

// thaomm - rental shop
void ShopV2_SendRentalData(BundleListFlags flags)
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_SHOP_RENTAL_DATA))
	{
		return;
	}

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);

	// --- CRM bundles list
	auto bundlesData = Shop_ConstructBundlesData(swfPlayer, BundleListFilter::Rental, flags);
	data->setMemberByName("list", bundlesData.list);

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_SHOP_RENTAL_DATA, members, membersLength);
}

void ShopV2_EquipRentedItem(int itemId)
{
	auto shopMgr = GetShopManager();
	auto item = shopMgr->FindShopItem(itemId);
	if (!item)
		return;

	StringHash offerEquipItem = itemId;
	auto fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx)
		return;

	GetMenuManager()->SetMenuActive(true, k_Popups);
	GetMenuManager()->MenuCaptureInput(k_Popups);

	auto popup = swfnew gameswf::ASObject(fx->getPlayer());

	popup->setMemberByName("type", "popup_Confirmation");
	popup->setMemberByName("name", "offerEquipRentedItem");
	popup->setMemberByName("titlebar", false);
	popup->setMemberByName("message", GetStringsMgr()->GetStringFromHash(StringHash("STR_FPS_MENU_FLASH_EQUIP_ITEM_AFTER_PURCHASE_MESSAGE")));

	auto buttons = swfnew gameswf::ASArray(fx->getPlayer());
	popup->setMemberByName("buttons", buttons);

	auto btnAccept = swfnew gameswf::ASObject(fx->getPlayer());
	buttons->push(btnAccept);

	btnAccept->setMemberByName("name", "btnAccept");
	btnAccept->setMemberByName("closePopup", true);
	btnAccept->setMemberByName("equipItem", (int)offerEquipItem.GetHash());
	btnAccept->setMemberByName("equipItemCategory", (int)item->category.GetHash());

	auto btnDecline = swfnew gameswf::ASObject(fx->getPlayer());
	buttons->push(btnDecline);

	btnDecline->setMemberByName("name", "btnDecline");
	btnDecline->setMemberByName("closePopup", true);

	GET_BASE_RETURN(popup)
		fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_POPUP, members, membersLength);
}

void ShopV2_EventPromoNotification(const gameswf::ASNativeEventState& eventState)
{
}

/**************************/
/*  Shop V2 - Events      */
/**************************/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ShopV2_AskForShopEventsData(const gameswf::ASNativeEventState& eventState)
{
	ShopV2_SendEventsData();
}

void ShopV2_SendEventsData(BundleListFlags flags)
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_SHOP_EVENT_DATA))
	{
		return;
	}

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);

	auto bundlesData = Shop_ConstructBundlesData(swfPlayer, BundleListFilter::Events, flags);
	data->setMemberByName("list", bundlesData.list);

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_SHOP_EVENT_DATA, members, membersLength);
}

/**************************/
/* Shop V2 - Black Market */
/**************************/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gameswf::ASObject* ShopV2_ConstructBMOfferList(gameswf::Player* swfPlayer, const char* bmPrefix)
{
	auto shopMgr = GetShopManager();

	auto swfList = swfnew gameswf::ASArray(swfPlayer);

	// --- send offer list
	char slotStr[3]; int slot = 1;
	CShopManager::ShopOffer* slotOffer = nullptr;
	while (true)
	{
		glf::Snprintf(slotStr, "%d", slot);
		auto offerId = StringHash(Hash(bmPrefix, (const char*)&slotStr));
		auto offer = slotOffer = shopMgr->FindShopOffer(offerId);
		if (!offer)
			break;

		auto swfOffer = swfnew gameswf::ASObject(swfPlayer);
		const std::string& name = shopMgr->Hash2Name(offerId);
		swfOffer->setMemberByName(KSTR("id"), name.c_str());
		swfOffer->setMemberByName(KSTR("title"), "ISLAND JOB EVENT");

		// --- cost & special offer
		gameswf::ASObject* specialOffer = nullptr;
		if (!offer->inItem.empty())
		{
			auto cost = ConstructCostInfo(swfPlayer, offerId, &specialOffer, nullptr);
			GLF_ASSERTMSG(cost, "Could not find price information for module %u. You probably need to update the CRM data.", offerId.GetHash());
			swfOffer->setMemberByName(KSTR("cost"), cost);
		}

		auto swfContent = swfnew gameswf::ASObject(swfPlayer);
		swfOffer->setMemberByName(KSTR("content"), swfContent);

		if (!offer->outItems.empty())
		{
			auto swfCards = swfnew gameswf::ASArray(swfPlayer);
			swfContent->setMemberByName(KSTR("cards"), swfCards);

			for (const auto& item : offer->outItems)
			{
				SwfCards cards(nullptr);
				auto swfItem = cards.Make(swfPlayer, item.item, item.qty, Json::Value::null, Json::Value::null);
				swfCards->push(swfItem);
			}
		}

		swfList->push(swfOffer);
		++slot;
	}
	return swfList;
}

int ShopV2_CheckBMOfferList(gameswf::Player* swfPlayer, const char* bmPrefix)
{
	int retFlags = 0;
	auto shopMgr = GetShopManager();

	auto swfList = swfnew gameswf::ASArray(swfPlayer);

	// --- send offer list
	char slotStr[3]; int slot = 1;
	CShopManager::ShopOffer* slotOffer = nullptr;
	while (true)
	{
		glf::Snprintf(slotStr, "%d", slot);
		auto offerId = StringHash(Hash(bmPrefix, (const char*)&slotStr));
		auto offer = slotOffer = shopMgr->FindShopOffer(offerId);
		if (!offer)
			break;

		//auto swfOffer = swfnew gameswf::ASObject(swfPlayer);
		//const std::string& name = shopMgr->Hash2Name(offerId);
		//swfOffer->setMemberByName(KSTR("id"), name.c_str());
		//swfOffer->setMemberByName(KSTR("title"), "ISLAND JOB EVENT");

		// --- cost & special offer
		gameswf::ASObject* specialOffer = nullptr;
		if (!offer->inItem.empty())
		{
			auto cost = ConstructCostInfo(swfPlayer, offerId, &specialOffer, nullptr);
			GLF_ASSERTMSG(cost, "Could not find price information for module %u. You probably need to update the CRM data.", offerId.GetHash());
			//swfOffer->setMemberByName(KSTR("cost"), cost);
		}

		//auto swfContent = swfnew gameswf::ASObject(swfPlayer);
		//swfOffer->setMemberByName(KSTR("content"), swfContent);

		if (!offer->outItems.empty())
		{
			//auto swfCards = swfnew gameswf::ASArray(swfPlayer);
			//swfContent->setMemberByName(KSTR("cards"), swfCards);

			//for (const auto& item : offer->outItems)
			//{
			//	SwfCards cards(nullptr);
			//	auto swfItem = cards.Make(swfPlayer, item.item, item.qty, Json::Value::null, Json::Value::null);
			//	swfCards->push(swfItem);
			//}
			retFlags |= ShopV2Flags::ShopV2Exist;
			if (specialOffer)
			{
				retFlags |= ShopV2Flags::ShopV2Promo;
			}
		}

		//swfList->push(swfOffer);
		++slot;
	}
	return retFlags;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ShopV2_OnAskForShopBlackMarketData(const gameswf::ASNativeEventState& eventState)
{
	ShopV2_SendBlackMarketData();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int ShopV2_SendBlackMarketData(ShopV2Flags flags)
{
	int retFlags = 0;
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_SHOP_BLACK_MARKET_DATA))
	{
		return retFlags;
	}

	auto shopMgr = GetShopManager();

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);

	auto swfOffers = ShopV2_ConstructBMOfferList(swfPlayer, "bm_");
	data->setMemberByName("list", swfOffers);

	const auto& bmData = PLAYER_PROFILE()->GetProfileBlackMarketData();
	time_t now = GetShopManager()->GetServerTime();

	// --- time left until auto refresh
	data->setMemberByName("timeLeft", (int)(bmData.autoRefreshTs() - now));

	// --- manual refresh info (either time left until button is available or the refresh cost, or neither (no bm manual refresh possible, offer deactivated from CRM))
	auto refreshOffer = shopMgr->FindShopOffer("bm_refresh");
	bool canRefresh = false;
	if (refreshOffer)
	{
		auto swfRefresh = swfnew gameswf::ASObject(swfPlayer);
		if (refreshOffer->inItem.empty())
		{
			if (bmData.manualRefreshTs())
				swfRefresh->setMemberByName("timeLeft", (int)(bmData.manualRefreshTs() - now));
		}
		else
		{
			auto cost = ConstructCostInfo(swfPlayer, "bm_refresh", nullptr, nullptr);
			swfRefresh->setMemberByName("cost", cost);
		}
		canRefresh = true;
		data->setMemberByName("refresh", swfRefresh);
	}

	// --- restock info
	auto restockOffer = shopMgr->FindShopOffer("bm_restock");
	if (restockOffer && !restockOffer->inItem.empty())
	{
		auto swfRestock = swfnew gameswf::ASObject(swfPlayer);
		data->setMemberByName("restock", swfRestock);

		auto cost = ConstructCostInfo(swfPlayer, "bm_restock", nullptr, nullptr);
		swfRestock->setMemberByName("cost", cost);
	}

	// --- happy hour
	auto happyHour = swfnew gameswf::ASObject(swfPlayer);
	data->setMemberByName("happyHour", happyHour);

	int timeleft = bmData.happyHourEnd() - GetShopManager()->GetServerTime();
	if (timeleft > 0)
	{
		//auto tl = ConstructTimeLeft(timeleft, swfPlayer);
		//if (tl)
		//	happyHour->setMemberByName("timeLeft", tl);
		happyHour->setMemberByName("timeLeft", timeleft);
	}

	auto progress = swfnew gameswf::ASObject(swfPlayer);
	happyHour->setMemberByName("progress", progress);

	progress->setMemberByName("current", timeleft > 0 ? 100 : (int)bmData.happyHourPercent());
	progress->setMemberByName("maximum", 100);

	// --- remove refresh notification
	NOTIFICATIONS()->RemoveNotificationsByCategoryInfo("bm", "refresh");
	if (flags == ShopV2Flags::ShopV2Promo)
	{
		return retFlags;
	}

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_SHOP_BLACK_MARKET_DATA, members, membersLength);

	GameAdsManager::TVideoState videoStateBMRefresh = ADS()->GetVideoState(GameAdsManager::k_BM_Refresh);
	bool canShowVideoBMRefresh = videoStateBMRefresh.isAvailableFromCrom &&
		(ADS()->IsIncentivizedAvailable(videoStateBMRefresh.m_video[crm::k_szPopupAdsLocation].asString()) == adslib::AvailabilityStatus::ADS_STATUS_AVAILABLE);

	if (canShowVideoBMRefresh && canRefresh)
	{
		fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_WATCH_VIDEO_BUTTON);
	}
	return retFlags;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ShopV2_playAnimationBlackMarketData()
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_COMMAND_SHOP_BLACK_MARKET_PLAY_ANIMATION))
	{
		return;
	}

	const auto& bmData = PLAYER_PROFILE()->GetProfileBlackMarketData();
	int timeleft = bmData.happyHourEnd() - GetShopManager()->GetServerTime();
	if (timeleft > 0)
		return;

	fx->getStage().dispatchEvent(CPP_COMMAND_SHOP_BLACK_MARKET_PLAY_ANIMATION);
}


void ShopV2_AskShopBlackMarketPackBuy(const gameswf::ASNativeEventState& eventState)
{
}

void ShopV2_AskShopBlackMarketRenew(const gameswf::ASNativeEventState& eventState)
{
}

void ShopV2_AskShopBlackMarketRestock(const gameswf::ASNativeEventState& eventState)
{
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ShopV2_OnAskForShopBundlesData(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue inputData = eventState.m_event["data"];

	bool showArenaBundles = false;
	showArenaBundles = inputData["arenaBundles"].toBool();
	GetMenuManager()->SetBundleArena(showArenaBundles);
	Shop_SendBundlesData(showArenaBundles, true);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char* s_packs[] =
{
	"hoard",
	"arena_token",
	"hc",
	"sc",
	"pack_neutronium",
	"pack_gacha_key",
	"pack_gacha_key_arena"
};


int ShopV2_AskForShopPacksData(ShopV2Flags flags, const std::string& id, int minimumRequired, bool skipShowSubcription)
{
	int retVal = 0;
	//CRM()->TriggerPointcutVideo(KSTR("Video_Cash"));
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx || (!fx->getStage().hasEventListener(CPP_SEND_SHOP_PACKS_DATA) && flags == 0))
	{
		return retVal;
	}
	StringHash descriptionId = 0;

	auto data = swfnew gameswf::ASObject(fx->getPlayer());
	gameswf::ASArray* listSwf = swfnew gameswf::ASArray(fx->getPlayer());
	data->setMemberByName("list", listSwf);

	if (id.length() == 0)
	{
		retVal = ShopV2_SendPacksData(listSwf, flags, descriptionId, "hoard") | retVal;
		retVal = ShopV2_SendMarketData(listSwf, flags, descriptionId, "hc", minimumRequired, skipShowSubcription) | retVal;
		retVal = ShopV2_SendMarketData(listSwf, flags, descriptionId, "sc", minimumRequired, skipShowSubcription) | retVal;
		retVal = ShopV2_SendMarketData(listSwf, flags, descriptionId, "arena_token", minimumRequired, skipShowSubcription) | retVal;
		retVal = ShopV2_SendMarketData(listSwf, flags, descriptionId, SHOP_ITEM_SHARD_CURRENCY, minimumRequired, skipShowSubcription) | retVal;
	}
	else
	{
#if !defined(OS_ANDROID)
		if (id == "neutronium")
		{
			Shop_SendHcMarketData("pack_neutronium");
			//Json::Value data;
			//data["currency"] = "neutronium";
			//data["value"] = 100;
			//GetOnlineManager()->GetAHGSLobbyManager()->ClientSendCheatCommand(AHCheatCommand::RefillNeutronium, data);
			return retVal;
		}
#endif
		if (id == "gold_key" || id == "silver_key")
		{
			Shop_SendHcMarketData("pack_gacha_key");
			return retVal;
		}
		if (id == "pink_key")
		{
			Shop_SendHcMarketData("pack_gacha_key_arena");
			return retVal;
		}

		if (id == "hoard")
		{
			ShopV2_SendPacksData(listSwf, flags, descriptionId, id.c_str());
		}
		else
		{
			retVal = ShopV2_SendMarketData(listSwf, flags, descriptionId, id.c_str(), minimumRequired, skipShowSubcription);
		}
	}

	if (flags == ShopV2Flags::ShopV2Promo)
	{
		return retVal;
	}

	if (descriptionId != 0)
		data->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));

	//data->setMemberByName("showArenaTokens", !EloLeaderboard::Get()->GetArenaComingSoon());

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_SHOP_PACKS_DATA, members, membersLength);
	return retVal;
}


void ShopV2_OnAskForShopPacksData(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	std::string id = data["currencyType"].toString().c_str();
	int minimumRequired = data["minimumRequired"].toInt();
	////Android Change: [BM] fix #9244022, this bug should happens on the other platform, please double check
	//	bool skipShowSubcription = false;
	//#if defined(OS_ANDROID)
	//	skipShowSubcription = data["skipShowSubcription"].toBool();
	//	//end Android Change
	//#endif
		// --- no longer show the old subscription on android
	bool skipShowSubcription = true;
	ShopV2_AskForShopPacksData(ShopV2Flags::ShopV2None, id, minimumRequired, skipShowSubcription);
}


int ShopV2_SendPacksData(gameswf::ASArray* listSwf, ShopV2Flags flags, StringHash& descriptionId, const char* category)
{
	int retFlags = 0;
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx)
	{
		return retFlags;
	}
	auto fxPlayer = fx->getPlayer();
	//auto data = swfnew gameswf::ASObject(fxPlayer);

#if 0

	std::set<std::string> promo;

	for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
	{
		auto item = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
		if (item->IsHidden())
			continue;
#endif
		if (item->HasPricePromotion() || item->HasAmountPromotion())
		{
#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			std::string s = item->GetType();
#else
			std::string s = item->GetSubType();
#endif				
			s += "Promo";
			promo.insert(s);

			if (auto sub = IAP()->GetBundleOldSubscription(i))
			{
				auto sub_data = GetShopManager()->GetOldSubscriptionData(sub);
				if (sub_data && !sub_data->active)
					promo.insert("hcPromo");
			}
		}
	}


	for (const auto& p : promo)
	{
		data->setMemberByName(p.c_str(), true);
	}
#endif // 0

#if 0
	//attention - cappingReached (from VideoHC = !enabled videoEnergy) - the condittions for cappingReached are opposite for VideoEnergy and Video Cash
	GameAdsManager::TVideoState videoState = ADS()->GetVideoState(GameAdsManager::k_HC);
	data->setMemberByName("watchVideo", videoState.isAvailableFromCrom &&
		(ADS()->IsIncentivizedAvailable(videoState.m_video[crm::k_szPopupAdsLocation].asString()) == adslib::AvailabilityStatus::ADS_STATUS_AVAILABLE));
	data->setMemberByName("cappingReached", false);

	// --- TODO: move to server
	auto energyShopItem = GetShopManager()->FindShopItem("energy");
	auto energyBonusOffer = GetShopManager()->FindShopOffer("energy_slot");
	if (GetShopManager()->GetEnergyBonusMinQty() && energyBonusOffer && !energyBonusOffer->outItems.empty())
		data->setMemberByName("hcEnergyBonus", energyBonusOffer->outItems.front().qty.Get());

#endif // 0

	bool show_description = !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP);
	/*StringHash */descriptionId = 0;

	const char* KSTR_name = KSTR("title");
	//gameswf::ASArray* listSwf = nullptr;
	//listSwf = swfnew gameswf::ASArray(fxPlayer);
	//data->setMemberByName("list", listSwf);

	// --- featured
	{
		bool hcUsed = false;

		for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif
			if (crmi->GetBillingMethodCount() < 1)
				continue;

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			const std::string& currency = crmi->GetType();
#else
			const std::string& currency = crmi->GetSubType();
#endif			

			auto isOldSubscription = IAP()->GetBundleOldSubscription(i);
			auto isVipSubscription = IAP()->GetBundleSubscription(i);
			auto isBundle = crmi->HasBundleItems();

			if (isVipSubscription && GetShopManager()->GetActiveSubscriptionType())
				continue;

			if (currency != "hc" && currency != "sc" && currency != SHOP_ITEM_HOARD && currency != SHOP_ITEM_PIGGY_BANK && currency != "arena_token" && !isOldSubscription && !isBundle && !isVipSubscription)
				continue;

			if (currency == "sc")
			{
				auto shopItem = GetShopManager()->FindShopItem("sc");
				int max_qty = GetShopManager()->GetMaxQty(shopItem);
				if (max_qty > 0 && crmi->GetAmount() + PLAYER_PROFILE()->GetInventory().GetShopItem("sc") > max_qty)
					continue;
			}

			if (currency == SHOP_ITEM_HOARD)
			{
				auto offer = GetShopManager()->FindShopOffer(StringHash(SHOP_ITEM_HOARD));
				if (offer)
				{
					gameswf::ASObject* itemSwf = swfnew gameswf::ASObject(fxPlayer);
					gameswf::ASObject* itemSwfContent = swfnew gameswf::ASObject(fxPlayer);
					itemSwf->setMemberByName("content", itemSwfContent);

					itemSwf->setMemberByName("id", crmi->GetEntryId());
					itemSwfContent->setMemberByName("art", crmi->GetIconName());
					itemSwf->setMemberByName(KSTR("title"), crmi->GetName());

					// cost
					auto cost = swfnew gameswf::ASObject(fxPlayer);
					itemSwf->setMemberByName("cost", cost);
					{
						auto money = swfnew gameswf::ASObject(fxPlayer);
						// money
						cost->setMemberByName("money", money);
						if (crmi->HasPricePromotion())
							money->setMemberByName("oldValue", IAP()->GetItemReplacedDisplayPrice(crmi).c_str());
						money->setMemberByName("value", IAP()->GetItemDisplayPrice(crmi).c_str());
					}

					// special offer
					{
						//auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
						//promo->setMemberByName(KSTR("specialOffer"), specialOffer);
						//specialOffer->setMemberByName(KSTR("value"), off[Premium].off);
						//specialOffer->setMemberByName(KSTR("type"), "off");
					}

					if (GetShopManager()->FindShopOffer(StringHash("vip_tickets_earn")))
					{
						auto tier = crmi->GetExtendedField("tier").ToString();
						auto tickets = GetShopManager()->GetMultiplayerData().GetIAPTickets(tier);
						if (tickets > 0)
							itemSwfContent->setMemberByName("bonusTicket", (std::string("+") + std::to_string(tickets)).c_str());
					}

					int currentHoard = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_HOARD);
					auto configValue = GetShopManager()->GetMultiplayerData().GetEntryIdxInSkirmishConfig(currentHoard);
					itemSwfContent->setMemberByName("increaseAmount", configValue.virtual_hc);
					//ceg capping
					int platinumCnt = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_PLATINUM_CAPPING);
					int capping = platinumCnt ? configValue.platinum_capping : configValue.capping;
					itemSwfContent->setMemberByName("maxAmount", capping);

					gameswf::ASObject* hc_itemSwf = swfnew gameswf::ASObject(fxPlayer);
					hc_itemSwf->setMemberByName("value", offer->outItems.front().qty.Get());
					itemSwfContent->setMemberByName(SHOP_ITEM_HARD_CURRENCY, hc_itemSwf);

					// --- we do not support timer for skirmisher hoard for now.  If we ever, uncomment this.
					//int customTimer = ComputeCustomTimer(i);
					//if (customTimer > 0)
					//{
					//	auto timeleft = ConstructTimeLeft(customTimer, fxPlayer);
					//	if (timeleft)
					//		itemSwf->setMemberByName("timeLeft", timeleft);
					//}
					if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
					{
						show_description = true;
						descriptionId = IAP()->GetItemHashId(crmi);
					}
					if (platinumCnt)
						itemSwfContent->setMemberByName("doubleCapacity", true);
					auto topupEvents = SemEventManager::Instance()->GetEventsOfType(EVENT_TYPE_TOPUP);
					if (topupEvents.size())
					{
						auto pack_name = crmi->GetExtendedField("group").ToString();
						char pack_name_full[255];
						if (currentHoard > 0)
							glf::Snprintf(pack_name_full, "%s_%d", pack_name.c_str(), currentHoard - 1);
						else
							glf::Snprintf(pack_name_full, "%s", pack_name.c_str());
						auto score = GetShopManager()->GetMultiplayerData().GetTopupEventScoreFromIAPName(pack_name_full, pack_name);
						itemSwfContent->setMemberByName("topUpPoints", std::to_string(score).c_str());

					}
					retFlags |= ShopV2Flags::ShopV2Exist;
					if (crmi->HasPricePromotion() || crmi->HasAmountPromotion())
					{
						retFlags |= ShopV2Flags::ShopV2Promo;
						if (flags == ShopV2Flags::ShopV2Promo)
						{
							return retFlags;
						}
					}
					listSwf->push(itemSwf);
				}
			}
			else if (currency == SHOP_ITEM_PIGGY_BANK)
			{
				auto offer = GetShopManager()->FindShopOffer(StringHash(SHOP_ITEM_PIGGY_BANK));
				if (offer)
				{
					gameswf::ASObject* itemSwf = swfnew gameswf::ASObject(fxPlayer);
					gameswf::ASObject* itemSwfContent = swfnew gameswf::ASObject(fxPlayer);
					itemSwf->setMemberByName("content", itemSwfContent);

					itemSwf->setMemberByName("id", crmi->GetEntryId());
					itemSwfContent->setMemberByName("art", crmi->GetIconName());
					itemSwf->setMemberByName(KSTR("title"), crmi->GetName());

					auto mgr = GetOnlineManager()->GetAHGSLobbyManager();

					// cost
					auto cost = swfnew gameswf::ASObject(fxPlayer);
					itemSwf->setMemberByName("cost", cost);
					{
						auto money = swfnew gameswf::ASObject(fxPlayer);
						// money
						cost->setMemberByName("money", money);
						if (crmi->HasPricePromotion())
							money->setMemberByName("oldValue", IAP()->GetItemReplacedDisplayPrice(crmi).c_str());
						money->setMemberByName("value", IAP()->GetItemDisplayPrice(crmi).c_str());
					}

					if (GetShopManager()->FindShopOffer(StringHash("vip_tickets_earn")))
					{
						auto tier = crmi->GetExtendedField("tier").ToString();
						auto tickets = GetShopManager()->GetMultiplayerData().GetIAPTickets(tier);
						if (tickets > 0)
							itemSwfContent->setMemberByName("bonusTicket", (std::string("+") + std::to_string(tickets)).c_str());
					}

					itemSwfContent->setMemberByName("maxAmount", mgr->m_piggyBankConfig.capPiggyBank);
					itemSwfContent->setMemberByName("increaseAmount", mgr->m_piggyBankConfig.pvpIncrease);

					gameswf::ASObject* hc_itemSwf = swfnew gameswf::ASObject(fxPlayer);
					int currentPGTier = PLAYER_PROFILE()->GetPiggyBankTier();
					int initPiggyBankValue = mgr->m_piggyBankConfig.initialValue;
					int piggyBankHCsaved = PLAYER_PROFILE()->GetInventory().GetShopItem("piggybank_hc");
					hc_itemSwf->setMemberByName("value", initPiggyBankValue + piggyBankHCsaved);
					itemSwfContent->setMemberByName(SHOP_ITEM_HARD_CURRENCY, hc_itemSwf);

					auto topupEvents = SemEventManager::Instance()->GetEventsOfType(EVENT_TYPE_TOPUP);
					if (topupEvents.size())
					{
						auto pack_name = crmi->GetExtendedField("group").ToString();
						char pack_name_full[255];
						if (currentPGTier > 0)
							glf::Snprintf(pack_name_full, "%s_%d", pack_name.c_str(), currentPGTier);
						else
							glf::Snprintf(pack_name_full, "%s", pack_name.c_str());
						auto score = GetShopManager()->GetMultiplayerData().GetTopupEventScoreFromIAPName(pack_name_full, pack_name);
						itemSwfContent->setMemberByName("topUpPoints", std::to_string(score).c_str());

					}

					retFlags |= ShopV2Flags::ShopV2Exist;
					if (crmi->HasPricePromotion() || crmi->HasAmountPromotion())
					{
						retFlags |= ShopV2Flags::ShopV2Promo;
						if (flags == ShopV2Flags::ShopV2Promo)
						{
							return retFlags;
						}
					}
					listSwf->push(itemSwf);
				}
			}
#if 0
			else if (currency == "arena_token")
			{
				if (!PLAYER_PROFILE()->FeatureUnlocked("royale_unlocked"))
					continue;

				auto shopItem = GetShopManager()->FindShopItem("arena_token");
				int max_qty = GetShopManager()->GetMaxQty(shopItem);
				if (max_qty > 0 && crmi->GetAmount() + PLAYER_PROFILE()->GetInventory().GetShopItem("arena_token") > max_qty)
					continue;

				//data->setMemberByName("showArenaTokens", true);
				if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
				{
					show_description = true;
					descriptionId = IAP()->GetItemHashId(crmi);
				}
			}

			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Value jex;
				Json::Reader rd;
				rd.parse(sjex, jex);

				bool price_cut = false;
				bool add_item = false;
				for (const auto& v : jex)
				{
					if (v.asString() == "featured")
					{
						double smallest_price;
						int smallest_amount;
						bool has_promo;
						if (!ComputeIAPPromo(currency, &smallest_price, &smallest_amount, &has_promo))
						{
							smallest_price = 0;
							smallest_amount = 0;
							has_promo = false;
						}

						auto item = CreateIAPItem(i, jex, has_promo, smallest_price, smallest_amount, fx->getPlayer(), false,
							true);
						std::string categ = "bundleOffer";
						if (item)
						{
							if (isVipSubscription)
							{
								Subscription_FillSubscriptionEntries();
								categ = "subscriptionOffer";
								if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
								{
									show_description = true;
									descriptionId = IAP()->GetItemHashId(crmi);
								}
							}
							else if (currency == "hc" || isOldSubscription || currency == "arena_token")
							{
								if (hcUsed)
									categ = "scOffer";
								else
									categ = "hcOffer";
								hcUsed = true;

								if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
								{
									show_description = true;
									descriptionId = IAP()->GetItemHashId(crmi);
								}
							}
							else if (currency == "sc")
							{
								categ = "scOffer";
								if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
								{
									show_description = true;
									descriptionId = IAP()->GetItemHashId(crmi);
								}
							}
							listSwf->push(item);
						}
						break;
					}
				}
			}
#endif // 0
		}
	}

	//if (show_description)
	//{
	//	data->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));
	//}

	//data->setMemberByName("showArenaTokens", !EloLeaderboard::Get()->GetArenaComingSoon());

	//GET_BASE_RETURN(data);
	//fx->getStage().dispatchEvent(CPP_SEND_SHOP_PACKS_DATA, members, membersLength);
	return retFlags;
}

int ShopV2_SendMarketData(gameswf::ASArray* currencyPacksSwf, ShopV2Flags flags, StringHash& descriptionId, std::string reqCurrency, int minimumRequired, bool skipShowSubcription)
{
	int retFlags = 0;
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx /*|| !fx->getStage().hasEventListener(CPP_SEND_CREDITS_DATA)*/)
	{
		return retFlags;
	}

	static std::string lastReqCurrency;
	static int lastMinimumRequired = 0;

	if (reqCurrency.empty())
	{
		reqCurrency = lastReqCurrency;
		minimumRequired = lastMinimumRequired;
	}
	else
	{
		lastReqCurrency = reqCurrency;
		lastMinimumRequired = minimumRequired;
	}

	if (reqCurrency.empty())
	{
		reqCurrency = lastReqCurrency = "hc";
		minimumRequired = 0;
	}
	//Android Change: [BM] fix #9244022, this bug should happens on the other platform, please double check

	else if (reqCurrency == "neutronium")
	{
		Shop_SendHcMarketData(StringHash(SHOP_OFFER_CATEGORY_PACK_NEUTRONIUM));
		return retFlags;
	}
	else
	{
		auto credit = GetShopManager()->FindShopItem(StringHash(reqCurrency.c_str()));
		if (credit && credit->category == StringHash("gacha_currency"))
		{
			Shop_SendHcMarketData(StringHash(reqCurrency.c_str()));
			return retFlags;
		}
	}

	//end Android Change

	gameswf::ASObject* marketDataSwf = swfnew gameswf::ASObject(fx->getPlayer());

	//{
	//	auto hardCurrencyAmount = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_HARD_CURRENCY);
	//	marketDataSwf->setMemberByName("hardCurrency", hardCurrencyAmount);
	//}

	//{
	//	auto softCurrency = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_SOFT_CURRENCY);
	//	marketDataSwf->setMemberByName("diamondDust", softCurrency);
	//}

	//{
	//	auto arenaTokenCurrency = PLAYER_PROFILE()->GetInventory().GetShopItem(SHOP_ITEM_ARENA_TOKEN);
	//	marketDataSwf->setMemberByName("arena_token", arenaTokenCurrency);
	//}

	bool showDescription = !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP);
	/*StringHash */descriptionId = 0;

	{
		//gameswf::ASArray* currencyPacksSwf = swfnew gameswf::ASArray(fx->getPlayer());

		std::vector<std::pair<int, int>> items_ixs;

		std::map<int, Json::Value> extra_categories;
		double smallest_price = -1;
		int smallest_amount = -1;
		int highest_amount = -1;
		bool hasPromo = false;
		for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif
			if (crmi->GetBillingMethodCount() < 1)
				continue;

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			const std::string& currency = crmi->GetType();
#else
			const std::string& currency = crmi->GetSubType();
#endif			

			auto subscriptionId = IAP()->GetBundleOldSubscription(i);
			if (subscriptionId)
			{
				if (reqCurrency != "hc")
					continue;

				if (minimumRequired > 0)
					continue;

				if (crmi->HasPricePromotion())
					hasPromo = true;
			}
			else
			{
				if (currency != reqCurrency)
					continue;

				if (currency == "sc")
				{
					auto shopItem = GetShopManager()->FindShopItem("sc");
					int max_qty = GetShopManager()->GetMaxQty(shopItem);
					if (max_qty > 0 && crmi->GetAmount() + PLAYER_PROFILE()->GetInventory().GetShopItem("sc") > max_qty)
						continue;
				}

				if (crmi->GetAmount() > highest_amount)
				{
					highest_amount = crmi->GetAmount();
				}

				if (crmi->HasAmountPromotion() || crmi->HasPricePromotion())
					hasPromo = true;

				if (smallest_price < 0 || crmi->GetBillingMethod(0)->GetPrice() < smallest_price)
				{
					smallest_price = crmi->GetBillingMethod(0)->GetPrice();
					smallest_amount = crmi->GetAmount();
				}
			}

			items_ixs.push_back(std::make_pair(i, 0));

			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Value jex;
				Json::Reader rd;
				rd.parse(sjex, jex);

				for (const auto& v : jex)
				{
					auto place = std::strtol(v.asCString(), nullptr, 10);
					if (place > 0)
					{
						items_ixs.back().second = place;
						//break;
					}
				}

				extra_categories[i] = std::move(jex);
			}
		}

		// --- std::sort_if
		if (std::all_of(items_ixs.begin(), items_ixs.end(), [](const std::pair<int, int>& p) { return p.second > 0; }))	// --- only sort if all members have order extra category
		{
			std::sort(items_ixs.begin(), items_ixs.end(), [](const std::pair<int, int>& p1, const std::pair<int, int>& p2) { return p1.second < p2.second; });
		}

		for (const auto& it : items_ixs)
		{
			int i = it.first;
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID
			const std::string& currency = crmi->GetType();
#else
			const std::string& currency = crmi->GetSubType();
#endif
			auto subscriptionId = IAP()->GetBundleOldSubscription(i);

			if (subscriptionId)
			{
				if (reqCurrency != "hc")
					continue;

				if (minimumRequired > 0)
					continue;
			}
			else
			{
				if (currency != reqCurrency)
					continue;

				if (crmi->GetAmount() < minimumRequired && crmi->GetAmount() < highest_amount)	// --- don't hide the highest pack
					continue;
			}

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
			{
				showDescription = true;
				descriptionId = IAP()->GetItemHashId(crmi);
			}

			gameswf::ASObject* itemSwf = CreateIAPItem(i, extra_categories[i], hasPromo, smallest_price, smallest_amount, fx->getPlayer(), skipShowSubcription, true);
			if (itemSwf)
			{
				currencyPacksSwf->push(itemSwf);
				retFlags |= ShopV2Flags::ShopV2Exist + hasPromo ? ShopV2Flags::ShopV2Promo : 0;
			}
		}
		//marketDataSwf->setMemberByName("currencyPacks", currencyPacksSwf);

		//{
		//	bool havePacks = IAP()->GetItemsCount() > 0;
		//	GetOnlineManager()->SendOCTEvent(of::SHOP, havePacks ? of::SUCCESS : of::FAIL, "", 0);
		//}
	}

	//if (showDescription)
	//	marketDataSwf->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));

	//??? GetShopManager()->ResetNotEnoughFlow();

	//{
	//	GET_BASE_RETURN(marketDataSwf);
	//	fx->getStage().dispatchEvent(CPP_SEND_CREDITS_DATA, members, membersLength);
	//}
	return retFlags;
}

void ShopV2_SendHcMarketData(gameswf::ASArray* currencyPacksSwf, StringHash& descriptionId, StringHash category)
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx /*|| !fx->getStage().hasEventListener(CPP_SEND_CREDITS_DATA)*/)
	{
		return;
	}

	static StringHash lastCategory = 0;
	if (category)
		lastCategory = category;
	else
		category = lastCategory;

	gameswf::ASObject* marketDataSwf = swfnew gameswf::ASObject(fx->getPlayer());

	bool showDescription = !GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_OFFLINE);
	/*StringHash */descriptionId = 0;

	struct OfferData
	{
		const ShopOffer* offer;
		int place;

		OfferData(const ShopOffer* offer = nullptr, int place = 0) : offer(offer), place(place) {}
	};
	std::vector<OfferData> offers;
	{
		auto poffers = GetShopManager()->GetOffersInCategory(category);
		poffers.erase(std::remove_if(poffers.begin(), poffers.end(), [](const ShopOffer* p) { return p->inItem.empty(); }), poffers.end());	// --- remove offers that are disabled (instead of send them with price 0)
		if (poffers.empty())
			return;

		offers.reserve(poffers.size());
		for (auto offer : poffers)
		{
			if (!offer)
				continue;

			int place = 0;
			for (auto xtra : offer->xtra)
			{
				const auto& txt = GetShopManager()->Hash2Name(xtra);
				place = std::strtol(txt.c_str(), nullptr, 10);
				if (place > 0)
					break;
			}
			offers.emplace_back(offer, place);
		}
	}

	if (std::all_of(offers.begin(), offers.end(), [](const OfferData& p) { return p.place > 0; }))
	{
		std::sort(offers.begin(), offers.end(), [](const OfferData& p1, const OfferData& p2) { return p1.place < p2.place; });
	}

	//gameswf::ASArray* currencyPacksSwf = swfnew gameswf::ASArray(fx->getPlayer());
	for (const auto& data : offers)
	{
		if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_OFFLINE, data.offer->id))
		{
			showDescription = true;
			descriptionId = data.offer->id;
		}

		gameswf::ASObject* itemSwf = CreateHCItem(data.offer, fx->getPlayer(), true);
		if (itemSwf)
		{
			currencyPacksSwf->push(itemSwf);
		}
	}
	//marketDataSwf->setMemberByName("currencyPacks", currencyPacksSwf);


	//if (showDescription)
	//	marketDataSwf->setMemberByName(KSTR("description"), GetShopManager()->GetOfflineItemsPromoDescription(descriptionId));

	//	auto debugstr = gameswf::toJsonValue(marketDataSwf).toStyledString();
	//	debugstr = debugstr;

	//{
	//	GET_BASE_RETURN(marketDataSwf);
	//	fx->getStage().dispatchEvent(CPP_SEND_CREDITS_DATA, members, membersLength);
	//}

#if 0
	if (category == "pack_neutronium")
	{
		GameAdsManager::TVideoState videoStateNeutronium = ADS()->GetVideoState(GameAdsManager::k_Neutronium);
		bool canShowVideoNeutronium = videoStateNeutronium.isAvailableFromCrom &&
			(ADS()->IsIncentivizedAvailable(videoStateNeutronium.m_video[crm::k_szPopupAdsLocation].asString()) == adslib::AvailabilityStatus::ADS_STATUS_AVAILABLE);

		if (canShowVideoNeutronium)
		{
			fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_WATCH_VIDEO_BUTTON);
		}
	}

#endif // 0
}


void ShopV2_OnAskForShopBattlePacksData(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	const std::string packID(data["battlepackId"].toString().c_str());

	//{
	//	EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ChangeBattlepackType, StringHash(packID.c_str()).GetHash());
	//	GetEventManager()->raiseAsync(ev);
	//}
	ShopV2_ComputeAndSendBattlepacksInitData(true, ShopV2Flags::ShopV2None, BattlepackType::Ordinary);
	//ShopV2_ComputeAndSendBattlepacksInitData(true,BattlepackType::Arena);

	//showBattlepacksCompensationRewards();
}

int ShopV2_ComputeAndSendBattlepacksInitData(bool send, ShopV2Flags flags, BattlepackType type)
{
	int retFlags = 0;
	const char* flash_message = "";
	StringHash categoryHash;

	flash_message = CPP_SEND_SHOP_BATTLE_PACKS_DATA;
	switch (type)
	{
	case BattlepackType::Ordinary:
		//flash_message = CPP_SEND_BATTLE_PACKS_INIT_DATA;
		categoryHash = StringHash(GetShopManager()->GetBattlepackOfferCategory().c_str());
		break;

	case BattlepackType::Arena:
		//flash_message = CPP_SEND_RTPVP_SHOP_DATA;
		categoryHash = StringHash(GetShopManager()->GetArenaBattlepackCategory().c_str());
		break;

	default:
		GLF_ASSERT(0);
		break;

	}

	gameswf::RenderFX* fx = nullptr;
	if (send)
	{
		fx = GetMenuManager()->GetRoot(k_MainMenu);
		if (!fx)
			fx = GetMenuManager()->GetRoot(k_InGameMenu);
		if (!fx || !fx->getStage().hasEventListener(flash_message/*CPP_SEND_BATTLE_PACKS_INIT_DATA*/))
		{
			return 0;
		}
	}

	bool push_keys_pack = false;
	struct ButtonData
	{
		StringHash item;
		int off;
		int timeLeft;
		std::string discount;
		int order;
		bool notification;
		bool _new;
		bool locked;

		ButtonData(StringHash item = 0, int order = 1024) : item(item), off(0), timeLeft(0), order(order), notification(false), _new(false), locked(false) {}
	};
	std::vector<ButtonData> tmpPacks;
	auto credits = GetShopManager()->GetCreditsInCategory(categoryHash/*StringHash(GetShopManager()->GetBattlepackOfferCategory().c_str())*/);

	for (auto credit : credits)
	{
		auto offerHash = credit->id;
		auto shopOffer = GetShopManager()->FindShopOffer(offerHash);
		bool open_if_hidden = false;

		if (!shopOffer)
			continue;

		if (shopOffer->outItems.empty())
			continue;

		auto buyItem = shopOffer->outItems.front();

		open_if_hidden = std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("open_if_hidden")) != shopOffer->xtra.end();
		if (open_if_hidden)
		{
			open_if_hidden = PLAYER_PROFILE()->GetInventory().GetShopItem(buyItem.item) > 0;
		}

		// hide offer with extra category "hide_in_shop"
		bool hide_in_shop = std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("hide_in_shop")) != shopOffer->xtra.end();
		if (hide_in_shop)
			continue;

		if (shopOffer->inItem.empty() && !open_if_hidden)
			continue;

		auto openWithKey = GetShopManager()->GetActivateBy(buyItem.item);
		if (openWithKey)
			continue;

		if (openWithKey && !PLAYER_PROFILE()->TutorialCompleted("tutorial_SquadOps"))
			continue;

		StringHash item = shopOffer->outItems.front().item;
		auto str = GetShopManager()->Hash2Name(shopOffer->outItems.front().item);
		if (type == BattlepackType::Arena)
		{
			static const std::string STD("_std_");
			auto ld = str.find(STD);
			if (ld != std::string::npos)
			{
				str.replace(ld, STD.length(), "_premium_");
			}
		}

		int* crtOff = nullptr;
		auto itt = std::find_if(tmpPacks.begin(), tmpPacks.end(), [item, str](const ButtonData& b) { return (b.item == item || b.item == StringHash(str.c_str())); });

		if (itt == tmpPacks.end())
		{
			tmpPacks.push_back(ButtonData(StringHash(str.c_str()), 1024 - tmpPacks.size()));
			itt = tmpPacks.end() - 1;

			const auto& json = GetShopManager()->GetGachaMaxChances();
			const auto& promos = json[GetShopManager()->Hash2Name(item)]["_packs_promo"];
			if (std::find(promos.begin(), promos.end(), Json::Value("limited")) != promos.end())
				itt->_new = true;
			int leagueID = -1;
			std::string name;
			itt->locked = !GetShopManager()->ValidateCredit(buyItem.item);
			if (!itt->locked && type == BattlepackType::Arena)
				itt->locked = IsLeagueLocked(str, leagueID, name);
		}
		else
		{
			crtOff = &itt->off;
		}

		itt->notification |= !!PLAYER_PROFILE()->GetInventory().GetShopItem(item);


		for (auto xtraHash : shopOffer->xtra)
		{
			const auto& categStr = GetShopManager()->Hash2Name(xtraHash);
			if (categStr.empty())
				continue;

			int order = 0;
			if (sscanf(categStr.c_str(), "%d", &order) == 1)
			{
				if (order > 0 && order < itt->order)
				{
					itt->order = order;
				}
			}

			std::string moreValue;
			std::string moreValueType;
			auto discount = CheckForMoreValueInExtraCategory(categStr, moreValue, moreValueType);
			if (discount && moreValueType == "hc_off")
				itt->discount = moreValue;
			retFlags |= ShopV2Flags::ShopV2Promo;
		}

		if (!shopOffer->inItemReplaced.empty() &&
			!shopOffer->inItem.empty() &&
			shopOffer->inItem.front().item == shopOffer->inItemReplaced.front().item &&
			shopOffer->inItem.front().qty < shopOffer->inItemReplaced.front().qty)
		{
			auto off = _round(100.f * (1.0f - ((float)shopOffer->inItem.front().qty.Get() / shopOffer->inItemReplaced.front().qty)));
			if (off > itt->off)
				itt->off = off;
		}

		if (itt->off || !itt->discount.empty())
		{
			auto tl = GetOfflineItemsTimeLeft(offerHash);
			if (tl > 0 && (itt->timeLeft == 0 || tl < itt->timeLeft))
				itt->timeLeft = tl;
		}

		if (!push_keys_pack && !shopOffer->inItem.empty())
		{
			auto keyCredit = GetShopManager()->FindShopItem(shopOffer->inItem.front().item);
			push_keys_pack = keyCredit && keyCredit->category == StringHash("gacha_currency");
		}
	}

	// --- add IAP gacha packs
	{
		for (unsigned i = 0; i != IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

			const std::string& ctype = crmi->GetType();
			if (crmi->HasBundleItems())
				continue;

			if (crmi->GetBillingMethodCount() < 1)
				continue;

			StringHash hash(ctype.c_str());
			auto credit = GetShopManager()->FindShopItem(hash);
			if (!credit)
				continue;

			if (credit->category != StringHash("gacha"))
				continue;

			if ((credit->name.Get().find("arena") == 0) ^ (type == BattlepackType::Arena))
				continue;

			Json::Value jex;
			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Reader rd;
				rd.parse(sjex, jex);
			}

			auto itt = std::find_if(tmpPacks.begin(), tmpPacks.end(), [hash](const ButtonData& b) { return b.item == hash; });
			if (itt == tmpPacks.end())
			{
				tmpPacks.push_back(ButtonData(hash, 1024 - tmpPacks.size()));
				itt = tmpPacks.end() - 1;
				itt->locked = !GetShopManager()->ValidateCredit(credit->id);
			}

			itt->notification |= !!PLAYER_PROFILE()->GetInventory().GetShopItem(credit->id.GetHash());

			for (const auto& jCateg : jex)
			{
				auto categStr = jCateg.asString();
				if (categStr.empty())
					continue;

				int order = 0;
				if (sscanf(categStr.c_str(), "%d", &order) == 1)
				{
					if (order > 0 && order < itt->order)
					{
						itt->order = order;
					}
				}

				std::string moreValue;
				std::string moreValueType;
				auto discount = CheckForMoreValueInExtraCategory(categStr, moreValue, moreValueType);
				if (discount && moreValueType == "hc_off")
					itt->discount = moreValue;
				retFlags |= ShopV2Flags::ShopV2Promo;
			}

			if (crmi->HasPricePromotion())
			{
				auto price = crmi->GetBillingMethod(0)->GetPrice();
				auto oldPrice = crmi->GetBillingMethod(0)->GetReplacedPrice();
				if (oldPrice > 0)
				{
					auto off = _round(100.f * (1.0f - (price / oldPrice)));
					if (off > itt->off)
						itt->off = off;
				}
			}

			bool showTimer = false;
			if (crmi->HasPricePromotion())
			{
				showTimer = itt->off > 0;
				retFlags |= ShopV2Flags::ShopV2Promo;
			}
			auto hasCustomTimer = HasCustomTimer(i);

			if (hasCustomTimer != E_CT_Expired && (showTimer || hasCustomTimer == E_CT_Valid))
			{
				auto customTimer = (hasCustomTimer == E_CT_Valid) ? ComputeCustomTimer(i) : 0;
				if (customTimer <= 0)
				{
					auto promoEnd = GetShopManager()->GetIAPPromoEndTime();
					auto timeCurrent = GetShopManager()->GetServerTime();

					customTimer = (long)promoEnd - (long)timeCurrent;
				}
				if (customTimer > 0)
					itt->timeLeft = customTimer;
			}
		}
	}

	bool presentTutorialOffer = TutorialManager()->IsMenuTutorialActive("tutorial_Crafting") &&
		(!PLAYER_PROFILE()->GetInventory().HasShopItem(StringHash("battlepack_tutorial")));
	if (!presentTutorialOffer)
	{
		std::sort(tmpPacks.begin(), tmpPacks.end(), [](const ButtonData& l, const ButtonData& r)
			{
				if (l.locked != r.locked)
					return l.locked < r.locked;
				return l.order < r.order;
			});
	}

	int seconds = 0;
	for (const auto& btnData : tmpPacks)
	{
		if (btnData.timeLeft > 0)
		{
			if (seconds == 0 || btnData.timeLeft < seconds)
				seconds = btnData.timeLeft;
		}
	}

	if (!send)
		return flags == ShopV2Flags::ShopV2Promo ? retFlags : seconds;

	auto fxPlayer = fx->getPlayer();
	gameswf::ASObject* data = swfnew gameswf::ASObject(fxPlayer);
	AddActiveMenuTutorialInfo(data);
	gameswf::ASArray* battlepacks = swfnew gameswf::ASArray(fxPlayer);

	static const char* packmap[]
	{
		"pack_t1", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_ALPHA_PACK_BREAKLINE",
		"pack_t2", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_DELTA_PACK_BREAKLINE",
		"pack_t3", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_KAPPA_PACK_BREAKLINE",
		"pack_t4", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_SIGMA_PACK_BREAKLINE",
		"pack_t5", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_OMEGA_PACK_BREAKLINE",
		"pack_t6", "STR_FPS_MENU_FLASH_BATTLE_ROYALE_ARMAGEDDON_PACK_BREAKLINE",
	};

	for (const auto& it : tmpPacks)
	{
		std::string packID = GetShopManager()->Hash2Name(it.item);
		gameswf::ASObject* asPack = swfnew gameswf::ASObject(fxPlayer);

		gameswf::ASObject* asPackContent = swfnew gameswf::ASObject(fxPlayer);
		asPack->setMemberByName(KSTR("content"), asPackContent);

		if (type == BattlepackType::Arena)
		{
			static const std::string PREMIUM("_premium_");
			auto ld = packID.find(PREMIUM);
			if (ld != std::string::npos)
			{
				packID.replace(ld, PREMIUM.length(), "_std_");
			}
		}
		asPack->setMemberByName("id", packID.c_str());

		const char* name = GetShopManager()->GetShopItemDisplayName(StringHash(packID.c_str()));
		size_t n = sizeof(packmap) / sizeof(*packmap);
		for (size_t i = 0; i < n; i += 2)
		{
			if (packID.find(packmap[i]) != std::string::npos)
			{
				name = GetStringsMgr()->GetStringFromHash(packmap[i + 1]);
				break;
			}
		}
		asPackContent->setMemberByName("name", name);
		asPack->setMemberByName("title", name);
		asPack->setMemberByName("unread", false);
		asPack->setMemberByName("rarity", GetShopManager()->GetShopItemDefaultRarity(it.item));

		asPack->setMemberByName("locked", it.locked);
		retFlags |= ShopV2Flags::ShopV2Exist;
		if (it._new)
		{
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName("promo", promo); // V2
			promo->setMemberByName("type", "new");
			retFlags |= ShopV2Flags::ShopV2Promo;
		}
		else if (!it.discount.empty())
		{
			retFlags |= ShopV2Flags::ShopV2Promo;
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName("promo", promo);
			promo->setMemberByName("type", "shop");

			auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName(KSTR("specialOffer"), specialOffer);
			specialOffer->setMemberByName(KSTR("value"), it.discount.c_str());
			specialOffer->setMemberByName(KSTR("type"), KSTR("hc_off"));
		}
		else if (it.off > 0)
		{
			retFlags |= ShopV2Flags::ShopV2Promo;
			if (flags == ShopV2Flags::ShopV2Promo)
				return retFlags;
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName("promo", promo);
			promo->setMemberByName("type", "shop");

			auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName(KSTR("specialOffer"), specialOffer);
			specialOffer->setMemberByName(KSTR("value"), it.off);
			specialOffer->setMemberByName(KSTR("type"), KSTR("off"));
			retFlags |= ShopV2Flags::ShopV2Promo;

			if (it.timeLeft > 0)
			{
				auto timeLeft = ConstructTimeLeft(it.timeLeft, fxPlayer);
				if (timeLeft)
					asPack->setMemberByName("timeLeft", timeLeft);
			}
		}
		else if (it.notification)
		{
			retFlags |= ShopV2Flags::ShopV2Promo;
			if (flags == ShopV2Flags::ShopV2Promo)
				return retFlags;
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			asPack->setMemberByName("unread", true);
		}
		if (!it.locked)
		{
			ShopV2_AddBattlepackData(packID, asPack);
		}
		battlepacks->push(asPack);
	}

	if (push_keys_pack)
	{
		gameswf::ASObject* asPack = swfnew gameswf::ASObject(fxPlayer);
		gameswf::ASObject* asPackContent = swfnew gameswf::ASObject(fxPlayer);
		asPack->setMemberByName(KSTR("content"), asPackContent);
		retFlags |= ShopV2Flags::ShopV2Exist;
		battlepacks->push(asPack);

		bool unread = false;
		switch (type)
		{
		case BattlepackType::Ordinary:
			unread = GetShopManager()->CategoryHasPromo("pack_gacha_key") != 0;
			break;

		case BattlepackType::Arena:
			unread = GetShopManager()->CategoryHasPromo("pack_gacha_key_arena") != 0;
			break;

		default:
			GLF_ASSERTMSG(false, "Added a new battlepack type?  Please update here");
			break;
		}

		asPack->setMemberByName("id", "keys_pack");
		asPack->setMemberByName("name", GetStringsMgr()->GetStringFromHash("STR_FPS_MENU_FLASH_KEYS_PACK"));
		asPack->setMemberByName("unread", unread);
		ShopV2_AddBattlepackData("keys_pack", asPack);
	}

	data->setMemberByName("list", battlepacks); // V2
	//switch (type)
	//{
	//case BattlepackType::Ordinary:		data->setMemberByName("battlepacks", battlepacks);		break;
	//case BattlepackType::Arena:			data->setMemberByName("packs", battlepacks);			break;
	//default:																					break;
	//}
	//data->setMemberByName("selectedIndex", 0);

	//	auto debugstr = gameswf::toJsonValue(data).toStyledString();
	//	debugstr = debugstr;

	if (flags == ShopV2Flags::ShopV2None)
	{
		GET_BASE_RETURN(data);
		fx->getStage().dispatchEvent(flash_message/*CPP_SEND_BATTLE_PACKS_INIT_DATA*/, members, membersLength);
	}

	return flags == ShopV2Flags::ShopV2Promo ? retFlags : seconds;
}

void ShopV2_AddBattlepackData(const std::string& packID, gameswf::ASObject* asPack)
{
	auto fxPlayer = asPack->getPlayer();

	gameswf::ASObject* dataContent = nullptr;
	gameswf::ASValue val;
	if (asPack->getMember("content", &val))
	{
		dataContent = val.toObject();
	}
	if (!dataContent)
	{
		return;
	}

	// --- teasers
	auto teasers = swfnew gameswf::ASArray(fxPlayer);
	dataContent->setMemberByName(KSTR("cards"), teasers);

	const Json::Value* json = &GetShopManager()->GetGachaMaxChances();
	Json::Value jTmp;

	// --- more hardcoding for tutorial
	if (TutorialManager()->IsMenuTutorialActive("tutorial_Crafting") &&
		(!PLAYER_PROFILE()->GetInventory().HasShopItem(StringHash("battlepack_tutorial"))) &&
		packID == "bronze_pack")
	{
		auto shopOffer = GetShopManager()->FindShopOffer("battlepack_tutorial");
		if (shopOffer && !shopOffer->outItems.empty())
		{
			jTmp[packID] = (*json)[packID];
			json = &jTmp;

			Json::Value arr;
			Json::Value val;
			val[GetShopManager()->Hash2Name(shopOffer->outItems.front().item)] = shopOffer->outItems.front().qty.Get();
			arr.append(std::move(val));
			auto& delta = jTmp["bronze_pack"]["_inventory_delta"];
			for (auto& j : delta)
				arr.append(std::move(j));
			delta = std::move(arr);
		}
	}

	const auto& packJson = (*json)[packID];
	IGM_sendMissionCompletedPartsData(packJson, teasers);

	//auto mpPlayers = swfnew gameswf::ASArray(fxPlayer);
	//teasers->setMemberByName(KSTR("mpPlayers"), mpPlayers);

	//auto mpParts = swfnew gameswf::ASArray(fxPlayer);
	//teasers->setMemberByName(KSTR("mpParts"), mpParts);

	//auto craftParts = swfnew gameswf::ASArray(fxPlayer);
	//teasers->setMemberByName(KSTR("craftParts"), craftParts);

//	AddDummyCraftPartTeaser(craftParts, part_key_t("Zoom_Epic"), 1, 30);
//	AddDummyCraftPartTeaser(craftParts, part_key_t("Accuracy_Rare"), 3, 40);
//	AddDummyCraftPartTeaser(craftParts, part_key_t("Thermal_Common"), 5, 50);

	enum class ESource { None, Offline, IAP };
	ESource show_description = GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_OFFLINE) ? ESource::Offline : ESource::None;
	StringHash descriptionId = 0;

	bool added_coming_soon = false;
	bool added_stay_tuned = false;
	gameswf::ASObject* send_keys = nullptr;

	bool found = false;

	// --- offers
	auto offers = swfnew gameswf::ASArray(fxPlayer);
	auto credits = GetShopManager()->GetCreditsInCategory(StringHash(GetShopManager()->GetBattlepackOfferCategory().c_str()));

	std::sort(credits.begin(), credits.end(), [](const ShopItem* credit1, const ShopItem* credit2)
		{
			auto shopOffer1 = GetShopManager()->FindShopOffer(credit1->id);
			auto shopOffer2 = GetShopManager()->FindShopOffer(credit2->id);

			int qty1 = shopOffer1 ? (shopOffer1->outItems.empty() ? 0 : shopOffer1->outItems.front().qty.Get()) : 0;
			int qty2 = shopOffer2 ? (shopOffer2->outItems.empty() ? 0 : shopOffer2->outItems.front().qty.Get()) : 0;

			return qty1 < qty2;
		});

	for (const auto& credit : credits)
	{
		// --- oh, the hacks we do for tutorials...
		bool presentCraftingTutorialOffer = (credit->id == StringHash("battlepack_1") || credit->id == StringHash("cbattlepack_1")) &&
			TutorialManager()->IsMenuTutorialActive("tutorial_Crafting") &&
			(!PLAYER_PROFILE()->GetInventory().HasShopItem(StringHash("battlepack_tutorial")));
		bool presentFtueTutorialOffer = (credit->id == StringHash("battlepack_5") || credit->id == StringHash("cbattlepack_5")) &&
			TutorialManager()->IsMenuTutorialActive("tutorial_CoopEventPartTwo") &&
			(!PLAYER_PROFILE()->GetInventory().HasShopItem(StringHash("ftue_battlepack_tutorial")));
		auto presentTutorialOffer = presentCraftingTutorialOffer || presentFtueTutorialOffer;

		auto offerHash = presentCraftingTutorialOffer ? offer_key_t("battlepack_tutorial") :
			presentFtueTutorialOffer ? offer_key_t("ftue_battlepack_tutorial") :
			credit->id;

		auto shopOffer = GetShopManager()->FindShopOffer(offerHash);
		if (!shopOffer)
			continue;

		if (shopOffer->outItems.empty())
			continue;
		auto buyItem = shopOffer->outItems.front();
		auto openWithKey = GetShopManager()->GetActivateBy(buyItem.item);

		if (openWithKey)
			continue;

		if (shopOffer->inItem.empty() && !openWithKey)
			continue;

		if (!presentTutorialOffer && GetShopManager()->Hash2Name(buyItem.item) != packID)
			continue;

		if (openWithKey && buyItem.qty != 1)	// --- this is the unused one
			continue;

		found = true;
		bool open = false;

		if (!openWithKey && !send_keys)
		{
			auto currecyCredit = GetShopManager()->FindShopItem(shopOffer->inItem.front().item);
			if (currecyCredit && currecyCredit->category == StringHash("gacha_currency"))
			{
				send_keys = swfnew gameswf::ASObject(fxPlayer);
				send_keys->setMemberByName("type", "activate_currency");
				send_keys->setMemberByName("value", PLAYER_PROFILE()->GetInventory().GetShopItem(currecyCredit->id));
				send_keys->setMemberByName("id", currecyCredit->name.Get().c_str());
			}
		}

		bool coming_soon = GetShopManager()->IsComingSoon(shopOffer->id) || std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("coming_soon")) != shopOffer->xtra.end();
		bool stay_tuned = GetShopManager()->IsComingSoon(shopOffer->id) || std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("stay_tuned")) != shopOffer->xtra.end();
		bool redirectToSubscription = std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("get_from_subscription")) != shopOffer->xtra.end();
		gameswf::ASObject* offer = NULL;
		StringHash stringHash(0);
		int qty = 0, qty2 = 0, n = 0;
		bool has_enough_keys = !openWithKey || PLAYER_PROFILE()->GetInventory().HasShopItem(openWithKey);
		if (stay_tuned)
		{
			if (added_stay_tuned)
				continue;
			added_stay_tuned = true;
			offer = swfnew gameswf::ASObject(fxPlayer);
			offer->setMemberByName(KSTR("comingSoon"), true);
			stringHash = StringHash("STR_FPS_MENU_FLASH_EVENTS_STAY_TUNED");
		}
		else if (!presentTutorialOffer &&
			(buyItem.qty == 1) &&
			PLAYER_PROFILE()->GetInventory().HasShopItem(buyItem.item) &&
			!redirectToSubscription &&
			has_enough_keys)
		{
			offer = swfnew gameswf::ASObject(fxPlayer);
			gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
			cost->setMemberByName("value", 0);
			std::string hc = "hc";
			if (!shopOffer->inItem.empty())
				hc = GetShopManager()->Hash2Name(shopOffer->inItem.front().item);
			offer->setMemberByName(hc.c_str(), cost);
			stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");
			open = true;
			qty = 1;
			offerHash = buyItem.item;

			if (coming_soon)
				added_coming_soon = true;

			n = PLAYER_PROFILE()->GetInventory().GetShopItem(buyItem.item);
			if (openWithKey)
			{
				int m = PLAYER_PROFILE()->GetInventory().GetShopItem(openWithKey);
				if (m < n)
					n = m;
			}
			if (n > 1)
			{
				qty2 = std::min(n, 4);
			}
		}
		else
		{
			if (openWithKey)
			{
				offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("findKeys"), true);
				if (PLAYER_PROFILE()->GetInventory().HasShopItem(buyItem.item))
					stringHash = StringHash("STR_FPS_MENU_FLASH_LUCKY_CACHE_FIND_KEY");
				else
					stringHash = StringHash("STR_FPS_MENU_FLASH_LUCKY_CACHE_FIND_CHEST");

				auto hc = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("hc"), hc);
				hc->setMemberByName(KSTR("value"), 0);
			}
			else if (redirectToSubscription)
			{
				if (GetShopManager()->GetActiveSubscriptionType())
					continue;

				if (!IAP()->HasVipSubscriptions())
					continue;

				offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("subscribe", true);
				stringHash = StringHash("STR_FPS_MENU_FLASH_VIP_MEMBERSHIP");

				auto hc = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("hc"), hc);
				hc->setMemberByName(KSTR("value"), 0);
			}
			else if (coming_soon)
			{
				if (added_coming_soon)
					continue;
				added_coming_soon = true;
				offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("comingSoon"), true);
				stringHash = StringHash("STR_FPS_MENU_FLASH_EVENTS_COMING_SOON");
			}
			else if (presentFtueTutorialOffer)
			{
				offer = swfnew gameswf::ASObject(fxPlayer);
				gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
				cost->setMemberByName("value", 0);
				std::string hc = "hc";
				offer->setMemberByName(hc.c_str(), cost);
				stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");
				qty = 1;
				n = 1;
			}
			else
			{
				offer = ConstructCostInfo(fxPlayer, shopOffer->id);
				auto currencyCredit = GetShopManager()->FindShopItem(shopOffer->inItem.front().item);
				if (currencyCredit && currencyCredit->category == StringHash("gacha_currency"))
					stringHash = StringHash("STR_UNLOCK_BATTLEPACK");
				else
					stringHash = StringHash("STR_BUY_BATTLEPACK");
			}
			qty = shopOffer->outItems.front().qty.Get();

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_OFFLINE, shopOffer->id))
			{
				show_description = ESource::Offline;
				descriptionId = shopOffer->id;
			}
		}

		if (openWithKey)
		{
			SwfCards keyCard(nullptr);
			int keyQty = PLAYER_PROFILE()->GetInventory().GetShopItem(openWithKey);
			gameswf::ASObject* swfKeys = nullptr;
			if (keyQty > 0)
			{
				swfKeys = keyCard.Make(fxPlayer, SHOP_ITEM_LUCKY_KEY, keyQty, Json::Value::null, Json::Value::null);
			}
			else
			{
				swfKeys = swfnew gameswf::ASObject(fxPlayer);
				swfKeys->setMemberByName("type", "activate_currency");
				swfKeys->setMemberByName("value", 0);
				swfKeys->setMemberByName("id", "bronze_key");
			}

			asPack->setMemberByName(KSTR("keys"), swfKeys);
			asPack->setMemberByName(KSTR("stock"/*"packsAvailable"*/), PLAYER_PROFILE()->GetInventory().GetShopItem(buyItem.item));

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_OFFLINE, shopOffer->id))
			{
				show_description = ESource::Offline;
				descriptionId = shopOffer->id;
			}
		}

		offer->setMemberByName(KSTR("id"), (int)offerHash);
		offer->setMemberByName(KSTR("quantity"), 1);
		offer->setMemberByName("open", open);

		static const std::string QTY = "${QTY}";
		static const std::string TOTAL = "${TOTAL}";

		const char* buy_str = GetStringsMgr()->GetStringFromHash(stringHash);
		std::string buy_str_buff(buy_str);

		{
			int pos = buy_str_buff.find(QTY);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, QTY.length(), std::to_string(qty));
			pos = buy_str_buff.find(TOTAL);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, TOTAL.length(), std::to_string(n));
			offer->setMemberByName(KSTR("name"), buy_str_buff.c_str());
		}

		offers->push(offer);

		if (qty2 > 1)
		{
			gameswf::ASObject* offer2 = new gameswf::ASObject(*offer);
			offer2->setMemberByName(KSTR("quantity"), qty2);
			offer2->setMemberByName("open", open);

			buy_str_buff = GetStringsMgr()->GetStringFromHash(stringHash);
			int pos = buy_str_buff.find(QTY);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, QTY.length(), std::to_string(qty2));
			pos = buy_str_buff.find(TOTAL);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, TOTAL.length(), std::to_string(n));

			offer2->setMemberByName(KSTR("name"), buy_str_buff.c_str());
			offers->push(offer2);
		}
	}

	static const std::string QTY = "QTY";
	static const std::string TOTAL = "TOTAL";
	auto createOffer = [](StringHash id, int n, int nb, gameswf::Player* fxPlayer)
	{
		std::map<std::string, std::string> map;
		map[QTY] = std::to_string(n);
		map[TOTAL] = std::to_string(nb);

		auto stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");
		auto msg = StringsManager::FormatStringWithTags(stringHash, map);

		auto offer = swfnew gameswf::ASObject(fxPlayer);
		offer->setMemberByName("id", (int)id.GetHash());
		offer->setMemberByName("name", msg.c_str());
		offer->setMemberByName("quantity", n);
		offer->setMemberByName("open", true);

		gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
		cost->setMemberByName("value", 0);
		std::string hc = "hc";
		offer->setMemberByName(hc.c_str(), cost);

		return offer;
	};

	if (!found)	// --- search IAP
	{
		bool added_stay_tuned = false;
		for (unsigned i = 0; i != IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);

#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

			const std::string& type = crmi->GetType();
			if (crmi->HasBundleItems())
				continue;

			if (crmi->GetBillingMethodCount() < 1)
				continue;

			StringHash hash(type.c_str());

			if (type != packID)
				continue;

			auto credit = GetShopManager()->FindShopItem(hash);
			if (!credit)
				continue;

			bool coming_soon = false;
			bool stay_tuned = false;

			found = true;

			Json::Value jex;
			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Reader rd;
				rd.parse(sjex, jex);

				for (const auto& p : jex)
				{
					if (p.asString() == "stay_tuned")
						stay_tuned = true;
					else if (p.asString() == "coming_soon")
						coming_soon = true;
				}
			}

			auto nb = PLAYER_PROFILE()->GetInventory().GetShopItem(hash);

			if (stay_tuned || coming_soon)
			{
				added_stay_tuned = true;
				auto offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("comingSoon"), true);
				offer->setMemberByName("name", GetStringsMgr()->GetStringFromHash(stay_tuned ? StringHash("STR_FPS_MENU_FLASH_EVENTS_STAY_TUNED") : StringHash("STR_FPS_MENU_FLASH_EVENTS_COMING_SOON")));

				gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
				cost->setMemberByName("value", 0);
				std::string hc = "hc";
				offer->setMemberByName(hc.c_str(), cost);
				offers->push(offer);
				break;
			}

			if (nb >= 1)
			{
				auto offer = createOffer(hash, 1, nb, fxPlayer);
				offers->push(offer);
				if (nb >= 4)
				{
					offer = createOffer(hash, 4, nb, fxPlayer);
					offers->push(offer);
				}
			}

			{
				std::map<std::string, std::string> map;
				map[QTY] = std::to_string(crmi->GetAmount());
				auto msg = StringsManager::FormatStringWithTags(StringHash("STR_BUY_BATTLEPACK"), map);

				auto offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("id", (int)StringHash(crmi->GetEntryId()).GetHash());
				offer->setMemberByName("name", msg.c_str());
				offer->setMemberByName("quantity", crmi->GetAmount());

				auto money = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("money", money);
				money->setMemberByName("value", IAP()->GetItemDisplayPrice(crmi).c_str());
				if (crmi->HasPricePromotion())
					money->setMemberByName("oldValue", IAP()->GetItemReplacedDisplayPrice(crmi).c_str());

				int remaining = crmi->GetRemainingPurchaseCount();
				if (remaining > 0)
				{
					offer->setMemberByName("stock", remaining);
					asPack->setMemberByName("stock", remaining);
				}

				offers->push(offer);
			}

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
			{
				show_description = ESource::IAP;
				descriptionId = IAP()->GetItemHashId(crmi);
			}
			else
			{
				show_description = GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP) ? ESource::None : ESource::IAP;
			}
			break;
		}
	}

	if (!found)
	{
		StringHash hash(packID.c_str());
		auto nb = PLAYER_PROFILE()->GetInventory().GetShopItem(hash);
		if (nb >= 1)
		{
			auto offer = createOffer(hash, 1, nb, fxPlayer);
			offers->push(offer);
			if (nb >= 4)
			{
				offer = createOffer(hash, 4, nb, fxPlayer);
				offers->push(offer);
			}
		}
	}

	asPack->setMemberByName(KSTR("offers"), offers);

	if (send_keys)
	{
		asPack->setMemberByName("keys", send_keys);
	}

	switch (show_description)
	{
	case ESource::Offline:
		asPack->setMemberByName(KSTR("description"), GetShopManager()->GetOfflineItemsPromoDescription(descriptionId));
		break;

	case ESource::IAP:
		asPack->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));
		break;

	default:
		break;

	}

	//	auto debugstr = gameswf::toJsonValue(asPack).toStyledString();
	//	debugstr = debugstr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForTicketShopData(const gameswf::ASNativeEventState& eventState)
{
	Shop_sendTicketShopData();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_sendTicketShopData(TicketsShopType type)
{
	auto shopMgr = GetShopManager();

	const char* cOffer = "ts_";
	auto vip_tickets_shop = shopMgr->FindShopOffer("vip_tickets_shop");
	auto refreshOffer = shopMgr->FindShopOffer("ts_refresh");
	gameswf::String ev = CPP_SEND_TICKET_SHOP_DATA;

	const auto& bmData = PLAYER_PROFILE()->GetProfileBlackMarketData();
	time_t now = GetShopManager()->GetServerTime();

	// --- time left until auto refresh
	int timeLeft = (int)(bmData.TSautoRefreshTs() - now);

	if (type == TicketsShopType::SurvivalShop)
	{
		cOffer = "ss_";
		vip_tickets_shop = shopMgr->FindShopOffer("vip_survival_shop");
		refreshOffer = shopMgr->FindShopOffer("ss_refresh");
		ev = CPP_SEND_SURVIVAL_EVENT_SHOP_DATA;
		timeLeft = (int)(bmData.SSautoRefreshTs() - now);
	}

	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(ev))
		return;

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);

	auto swfOffers = ConstructBMOfferList(swfPlayer, cOffer);
	data->setMemberByName("list", swfOffers);

	timeLeft = timeLeft < 0 ? 0 : timeLeft;
	data->setMemberByName("timeLeft", timeLeft);

	if (vip_tickets_shop)
	{
		auto vip_tickets_shop_time = GetOfflineItemsTimeLeft("vip_tickets_shop");
		data->setMemberByName("closingTime", vip_tickets_shop_time);
	}

	// --- manual refresh info (either time left until button is available or the refresh cost, or neither (no bm manual refresh possible, offer deactivated from CRM))
	if (refreshOffer && !refreshOffer->inItem.empty())
	{
		auto swfRefresh = swfnew gameswf::ASObject(swfPlayer);
		auto cost = ConstructCostInfo(swfPlayer, refreshOffer->id, nullptr, nullptr);
		swfRefresh->setMemberByName("cost", cost);
		data->setMemberByName("refresh", swfRefresh);
	}

	// --- remove refresh notification
	//NOTIFICATIONS()->RemoveNotificationsByCategoryInfo("ts", "refresh");

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(ev, members, membersLength);
}

#ifdef SKIRMISH_EVENT
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_sendSkirmishShopData()
{
	auto shopMgr = GetShopManager(); 
	
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_SKIRMISH_EVENT_SHOP_DATA))
	{
		return;
	}

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);

	// --- manual refresh info (either time left until button is available or the refresh cost, or neither (no bm manual refresh possible, offer deactivated from CRM))
	auto refreshOffer = shopMgr->FindShopOffer("sks_refresh");
	if (refreshOffer && !refreshOffer->inItem.empty())
	{
		auto swfRefresh = swfnew gameswf::ASObject(swfPlayer);
		auto cost = ConstructCostInfo(swfPlayer, refreshOffer->id, nullptr, nullptr);
		swfRefresh->setMemberByName("cost", cost);
		data->setMemberByName("refresh", swfRefresh);
	}

	auto swfOffers = ConstructBMOfferList(swfPlayer, "sks_");
	data->setMemberByName("list", swfOffers);

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_SKIRMISH_EVENT_SHOP_DATA, members, membersLength);
}
#endif // SKIRMISH_EVENT

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onAskForArmsDealerData(const gameswf::ASNativeEventState& eventState)
{
	Shop_sendArmsDealerData();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_sendArmsDealerData()
{
	auto fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_ARMS_DEALER_DATA))
	{
		return;
	}

	auto shopMgr = GetShopManager();

	auto swfPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(swfPlayer);

	auto swfOffers = ConstructBMOfferList(swfPlayer, "ad_");
	data->setMemberByName("list", swfOffers);
	data->setMemberByName("diamondLeagueRequiredTrophies", shopMgr->GetMultiplayerData().GetMaxElo());
	data->setMemberByName("hasFixedDiamondPointsReward", shopMgr->GetMultiplayerData().HasFixedDPRewards());

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_ARMS_DEALER_DATA, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onCommandBlackMarketBuy(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	auto offerId = StringHash(data["id"].toCStr());
	//std::string offer = data["id"].toCStr();

	// --- TODO: add the price and outitems in extradata in order to validate we're bying the same thing
	//auto offer = GetShopManager()->FindShopOffer

	GetShopManager()->AcceptOffer(offerId);

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onCommandBlackMarketRefresh(const gameswf::ASNativeEventState& eventState)
{
	GetShopManager()->AcceptOffer("bm_refresh");
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onCommandBlackMarketRestock(const gameswf::ASNativeEventState& eventState)
{
	GetShopManager()->AcceptOffer("bm_restock");
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onCommandTicketShopBuy(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	auto offerId = StringHash(data["id"].toCStr());

	GetShopManager()->AcceptOffer(offerId);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onCommandTicketShopRefresh(const gameswf::ASNativeEventState& eventState)
{
	GetShopManager()->AcceptOffer("ts_refresh");
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_showBuyConsumablePopup(const ShopOffer* offer)
{
	auto fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx)
		return;

	StringHash title, message;
	auto consumableId = offer->outItems.front().item;
	if (consumableId == StringHash(SHOP_ITEM_RAID_TICKET))
	{
		title = StringHash("STR_RAID_NOT_ENOUGH_TITLE");
		message = StringHash("STR_RAID_NOT_ENOUGH_TEXT");
	}
	else if (consumableId == StringHash(SHOP_ITEM_SQUADMATE_HEAL))
	{
		title = StringHash("STR_HEAL_NOT_ENOUGH_TITLE");
		message = StringHash("STR_HEAL_NOT_ENOUGH_TEXT");
	}
	else if (consumableId == StringHash(SHOP_ITEM_SQUADMATE_REVIVE))
	{
		title = StringHash("STR_REVIVE_NOT_ENOUGH_TITLE");
		message = StringHash("STR_REVIVE_NOT_ENOUGH_TEXT");
	}
	else
	{
		GLF_ASSERTMSG(false, "Shop_showBuyConsumablePopup called for unsupported consumable %s", GetShopManager()->Hash2Name(consumableId).c_str());
		return;
	}

	GetMenuManager()->SetMenuActive(true, k_Popups);
	GetMenuManager()->MenuCaptureInput(k_Popups);

	auto data = swfnew gameswf::ASObject(fx->getPlayer());

	data->setMemberByName(KSTR("type"), KSTR("popup_BuyRaidTickets"));
	data->setMemberByName(KSTR("name"), KSTR("buyConsumablesPopup"));
	data->setMemberByName(KSTR("titlebar"), true);
	data->setMemberByName(KSTR("offerID"), (int)offer->id.GetHash());
	data->setMemberByName(KSTR("title"), GetStringsMgr()->GetStringFromHash(title));
	data->setMemberByName(KSTR("message"), GetStringsMgr()->GetStringFromHash(message));

	{
		std::map<std::string, std::string> kv;
		kv[KSTR("QTY")] = std::to_string(offer->outItems.front().qty);
		kv[KSTR("CONSUMABLE")] = GetShopManager()->GetCurrencyFormatString(consumableId);
		kv[KSTR("PRICE")] = std::to_string(offer->inItem.front().qty);
		kv[KSTR("CURRENCY")] = GetShopManager()->GetCurrencyFormatString(offer->inItem.front().item);

		data->setMemberByName(KSTR("buyMessage"), StringsManager::FormatStringWithTags(StringHash("STR_CONSUMABLE_BUY"), kv).c_str());
	}

	auto cost = ConstructCostInfo(fx->getPlayer(), offer->id);
	if (cost)
		data->setMemberByName(KSTR("cost"), cost);

	auto buttons = swfnew gameswf::ASArray(fx->getPlayer());
	data->setMemberByName(KSTR("buttons"), buttons);

	auto btnCancel = swfnew gameswf::ASObject(fx->getPlayer());
	buttons->push(btnCancel);
	btnCancel->setMemberByName(KSTR("name"), KSTR("btnCancel"));
	btnCancel->setMemberByName(KSTR("closePopup"), true);
	btnCancel->setMemberByName(KSTR("label"), GetStringsMgr()->GetStringFromHash("STR_FPS_MENU_FLASH_CANCEL"));

	GET_BASE_RETURN(data)
		fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_POPUP, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_onSwfCommandBuyRaidTickets(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	auto id = StringHash(data["id"].toCStr());
	auto raids = StringHash(data["raids"].toInt());

	auto offers = GetShopManager()->GetOffersInCategory(SHOP_ITEM_RAID_OFFER);
	const ShopOffer* target_offer = nullptr;
	int max_qty = 0;
	for (const auto offer : offers)
	{
		if (offer->outItems.empty() || offer->inItem.empty())
			continue;

		int qty = offer->outItems.front().qty;
		if (qty > max_qty)	// --- found a better match
		{
			max_qty = qty;
			target_offer = offer;
		}

		if (qty == raids)	// --- found an exact match
		{
			target_offer = offer;
			break;
		}
	}

	if (target_offer)
		Shop_showBuyConsumablePopup(target_offer);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_ShowRendEndedPopup(std::vector<unsigned int> itemsRent)
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx)
	{
		return;
	}
	GetMenuManager()->SetMenuActive(true, k_Popups);
	GetMenuManager()->MenuCaptureInput(k_Popups);
	gameswf::ASObject* popup = swfnew gameswf::ASObject(fx->getPlayer());

	popup->setMemberByName("type", "popup_Rewards");
	popup->setMemberByName("name", "rentEndedPopup");
	popup->setMemberByName("titlebar", false);
	popup->setMemberByName("closeButton", false);
	popup->setMemberByName("closeButton", false);
	// popup->setMemberByName("title", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_RENTAL_EXPIRED));
	popup->setMemberByName("message", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_RENTAL_EXPIRED)); //will replace X with number of expired items
	popup->setMemberByName("showVal", false);

	gameswf::ASArray* buttons = swfnew gameswf::ASArray(fx->getPlayer());
	gameswf::ASObject* btnOk = swfnew gameswf::ASObject(fx->getPlayer());
	btnOk->setMemberByName("name", "btnConfirm");
	btnOk->setMemberByName("closePopup", true);
	btnOk->setMemberByName("label", GetStringsMgr()->GetString(STR_FPS_MENU_FLASH_OK));
	buttons->setMemberByIndex(0, btnOk);
	popup->setMemberByName("buttons", buttons);

	BundleListArray rentEndList(fx->getPlayer());
	for (auto item : itemsRent)
	{
		auto shopItem = GetShopManager()->FindShopItem(item);
		if (!shopItem)
			continue;
		rentEndList.AddItem(item, 1);
	}
	
	auto list = rentEndList.GetArray();
	if (list)
		popup->setMemberByName("rewards", list);

	GET_BASE_RETURN(popup);
	fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_POPUP, members, membersLength);

	//char buff[512];
	//auto strId = StringHash("STR_FPS_MENU_FLASH_RENT_PERIOD_EXPIRED");
	//if (itemId == StringHash(SHOP_ITEM_PVP_FIREWALL))
	//	strId = StringHash("STR_FPS_MENU_FLASH_FIREWALL_EXPIRED_MESSAGE");
	//else if (shopItem->category == StringHash(SHOP_ITEM_CATEGORY_PLAYER_CARD))
	//	strId = StringHash("STR_FPS_MENU_FLASH_SQUADMATE_RENT_PERIOD_EXPIRED");
	//auto format = GetStringsMgr()->GetStringFromHash(strId);
	//glf::Snprintf(buff, format, GetShopManager()->GetShopItemDisplayName(itemId));

	//showGenericNotificationPopup((const char*)buff, "rentEndedPopup");
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool CheckBundlesForItems(StringHash categoryId)
{
	// --- IAP bundles first
	{
		for (unsigned i = 0; i < IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);
#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

			const std::string& type = crmi->GetType();
			if (!crmi->HasBundleItems())
				continue;

			if (crmi->GetBillingMethodCount() < 1)
				continue;

			if (IAP()->GetBundleOldSubscription(i))	// --- subscriptions are in hc section
				continue;

			// --- check if item is already owned
			if (GetShopManager()->ShouldHideBundle(IAP()->GetItemHashId(crmi)))
				continue;

#if USE_IN_APP_BILLING_CRM || !defined OS_ANDROID //truong.px4 add fix compile GAND
			for (int j = 0; j < crmi->GetBundleItemCount(); ++j)
			{
				auto bItem = crmi->GetBundleItem(j);
				auto credit = GetShopManager()->FindShopItem(StringHash(bItem->GetType()));
				if (credit && credit->category == categoryId)
					return true;
			}
#endif
		}
	}

	// --- hc bundles next
	const std::string bundleIdBaseArr[] = { "squadmate_bundle_", "bundle_" };
	for (const auto& bundleIdBase : bundleIdBaseArr)
	{
		for (int i = 1;; ++i)
		{
			auto bundleId = bundleIdBase + std::to_string(i);
			auto bundleOffer = GetShopManager()->FindShopOffer(StringHash(bundleId.c_str()));

			if (!bundleOffer)
				break;

			if (bundleOffer->inItem.empty())
				continue;

			// --- check for already owned item
			if (GetShopManager()->ShouldHideBundle(StringHash(bundleId.c_str())))
				continue;

			for (const auto& k : bundleOffer->outItems)
			{
				auto credit = GetShopManager()->FindShopItem(k.item);
				if (credit && credit->category == categoryId)
					return true;
			}
		}
	}

	return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_ShowGetMorePopup(const std::string& itemType)
{
	auto fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx || !fx->getStage().hasEventListener(CPP_COMMAND_SHOW_POPUP) || GetMenuManager()->IsTopPopup("getMorePopup"))
		return;

	GetMenuManager()->SetMenuActive(true, k_Popups);
	GetMenuManager()->MenuCaptureInput(k_Popups);

	auto popup = swfnew gameswf::ASObject(fx->getPlayer());

	popup->setMemberByName("type", "popup_GetMore");
	popup->setMemberByName("name", "getMorePopup");
	popup->setMemberByName("titlebar", true);
	popup->setMemberByName("itemType", itemType.c_str());

	auto buttons = swfnew gameswf::ASArray(fx->getPlayer());
	popup->setMemberByName("buttons", buttons);

	auto btnBack = swfnew gameswf::ASObject(fx->getPlayer());
	buttons->push(btnBack);

	btnBack->setMemberByName("name", "btnBack");
	btnBack->setMemberByName("label", GetStringsMgr()->GetStringFromHash(StringHash("STR_FPS_MENU_FLASH_BACK")));
	btnBack->setMemberByName("closePopup", true);

	GET_BASE_RETURN(popup)
		fx->getStage().dispatchEvent(CPP_COMMAND_SHOW_POPUP, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_RefreshGetMorePopup(const Json::Value& reply)
{
	auto fx = GetMenuManager()->GetRoot(k_Popups);
	if (!fx || !fx->getStage().hasEventListener(CPP_COMMAND_REFRESH_POPUP) || !GetMenuManager()->IsTopPopup("getMorePopup"))
		return;

	auto categoryId = StringHash(reply["cat"].asString().c_str());
	const auto& sources = reply["sources"];

	auto popup = swfnew gameswf::ASObject(fx->getPlayer());

	popup->setMemberByName("type", "popup_GetMore");
	popup->setMemberByName("name", "getMorePopup");

	auto buttons = swfnew gameswf::ASArray(fx->getPlayer());
	popup->setMemberByName("buttons", buttons);

	struct SwfSource
	{
		StringHash sourceId;
		const char* buttonName;
	};
	static SwfSource swfSources[] =
	{
		{ "battlepack",		"btnBattlepack" },
		{ "battlepack2",	"btnBattlepack2" },
		{ "warlord",		"btnWarlord",	},
		{ "events",			"btnChallenges" },
		{ "missions",		"btnMissions"	},
		{ "bounty",			"btnGlobalHunt" },
		{ "bundles",		"btnBundles"	},
		{ "battlepass",		"btnBattlePass" },
		{ "clan",			"btnClanHQ"		},
	};

	auto handleSource = [buttons](StringHash sourceId, const Json::Value& additionalData, gameswf::ASValue swfStack)
	{
		auto sit = std::find_if(std::begin(swfSources), std::end(swfSources), [sourceId](const SwfSource& swfSource) { return swfSource.sourceId == sourceId; });
		if (sit == std::end(swfSources))
			return;

		const auto& labelOverride = additionalData["labelOverride"];

		auto button = swfnew gameswf::ASObject(buttons->getPlayer());
		buttons->push(button);

		button->setMemberByName("name", sit->buttonName);
		button->setMemberByName("label", GetStringsMgr()->GetStringFromHash(Hash("STR_GET_SQUADMATES_POPUP_", sit->buttonName)));
		button->setMemberByName("closePopup", true);
		button->setMemberByName("stack", swfStack);

		const auto& idOverride = additionalData["id"];
		if (!idOverride.isNull())
		{
			button->setMemberByName("id", idOverride.asString().c_str());
			if (!labelOverride.isNull() && labelOverride.asBool())
				button->setMemberByName("label", GetShopManager()->GetShopItemDisplayName(StringHash(idOverride.asString().c_str())));
		}
	};

	for (auto it = sources.begin(), ite = sources.end(); it != ite; ++it)
	{
		auto sourceId = StringHash(it.memberName());

		glf::Json::Value swfStack;
		glf::Json::Reader().parse((*it)["stack"].toCompactString(), swfStack);

		handleSource(sourceId, *it, gameswf::toASValue(swfStack, buttons->getPlayer()));
	}

	// --- search for bundles on the client
	if (CheckBundlesForItems(categoryId))
	{
		auto swfStack = swfnew gameswf::ASArray(buttons->getPlayer());

		auto swfStackEntry = swfnew gameswf::ASObject(buttons->getPlayer());
		swfStack->push(swfStackEntry);

		swfStackEntry->setMemberByName("menu", GetShopMenuName(SwfShopMenu::Bundles));

		handleSource("bundles", Json::Value::null, swfStack);
	}

	auto btnBack = swfnew gameswf::ASObject(fx->getPlayer());
	buttons->push(btnBack);

	btnBack->setMemberByName("name", "btnBack");
	btnBack->setMemberByName("label", GetStringsMgr()->GetStringFromHash(StringHash("STR_FPS_MENU_FLASH_BACK")));
	btnBack->setMemberByName("closePopup", true);

	GET_BASE_RETURN(popup);
	fx->getStage().dispatchEvent(CPP_COMMAND_REFRESH_POPUP, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shop_GetMore(const gameswf::ASNativeEventState& eventState)
{
	gameswf::ASValue data = eventState.m_event["data"];
	std::string categoryId = data["itemType"].toCStr();

	Json::Value cmdData;
	cmdData["cat"] = categoryId == "class_xp" ? SHOP_ITEM_CATEGORY_PLAYER_CARD_PART : categoryId;

	GetOnlineManager()->GetAHGSLobbyManager()->ClientSendShopCommand(antihackgs::ShopCommand::GetMoreItems, cmdData);

	Shop_ShowGetMorePopup(categoryId);
}
///////////////////////////////ARENA//////////////////////////////////////////////////////////////////////////////////
void onAskForArenaShopData(const gameswf::ASNativeEventState& eventState)
{
	Avatar_PushRoyalePreset();
	Shop_ComputeAndSendBattlepacksInitData(true, BattlepackType::Arena);
}

void onAskForArenaPacksData(const gameswf::ASNativeEventState& eventState)
{
	static const std::string _std_("_std_");
	static const std::string _premium_("_premium_");

	gameswf::ASValue data = eventState.m_event["data"];
	std::string packID1(data["packId"].toString().c_str());
	std::string packID2(packID1);
	auto at = packID2.find(_std_);
	if (at != std::string::npos)
	{
		packID2.replace(at, _std_.length(), _premium_);
	}
	{
		EvMenuCmd ev(EvMenuCmd::k_MenuCmd_ChangeBattlepackType, StringHash(packID1.c_str()), StringHash(packID2.c_str()));
		GetEventManager()->raiseAsync(ev);
	}

	Shop_SendArenaPacksData(packID1);

}

void Shop_SendArenaPacksData(const std::string& packID)
{
	gameswf::RenderFX* fx = GetMenuManager()->GetRoot(k_MainMenu);
	if (!fx)
		fx = GetMenuManager()->GetRoot(k_InGameMenu);
	if (!fx || !fx->getStage().hasEventListener(CPP_SEND_RTPVP_SHOP_PACK_DATA))
	{
		return;
	}
	auto fxPlayer = fx->getPlayer();
	auto data = swfnew gameswf::ASObject(fxPlayer);

	static const std::string STD("_std_");
	std::string premium_packID = packID;
	auto ld = premium_packID.find(STD);
	if (ld != std::string::npos)
	{
		premium_packID.replace(ld, STD.length(), "_premium_");
	}
	enum class ESource { None, Offline, IAP };
	ESource show_description = GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_OFFLINE) ? ESource::Offline : ESource::None;
	StringHash descriptionId = 0;

	bool added_coming_soon = false;
	bool added_stay_tuned = false;
	gameswf::ASObject* send_keys = nullptr;

	struct Off
	{
		int off = 0;
		int timeLeft = 0;
	};
	enum OffType
	{
		Regular,
		Premium,

		_count,
	};
	Off off[_count];

	// --- offers
	auto offers = swfnew gameswf::ASArray(fxPlayer);
	auto offers_premium = swfnew gameswf::ASArray(fxPlayer);
	auto credits = GetShopManager()->GetCreditsInCategory(StringHash(GetShopManager()->GetArenaBattlepackCategory().c_str()));
	for (size_t i = 0; i != credits.size(); ++i)
	{

		auto offerHash = credits[i]->id;

		auto shopOffer = GetShopManager()->FindShopOffer(offerHash);
		if (!shopOffer)
			continue;

		if (shopOffer->outItems.empty())
			continue;
		auto buyItem = shopOffer->outItems.front();


		if (shopOffer->inItem.empty())
			continue;

		if (GetShopManager()->Hash2Name(buyItem.item) != packID &&
			GetShopManager()->Hash2Name(buyItem.item) != premium_packID)
			continue;

		auto isPremium = GetShopManager()->Hash2Name(buyItem.item) == premium_packID;

		if (!send_keys)
		{
			auto currecyCredit = GetShopManager()->FindShopItem(shopOffer->inItem.front().item);
			if (currecyCredit && currecyCredit->category == StringHash("gacha_currency")) //pink_key
			{
				send_keys = swfnew gameswf::ASObject(fxPlayer);
				send_keys->setMemberByName("type", "activate_currency");
				send_keys->setMemberByName("value", PLAYER_PROFILE()->GetInventory().GetShopItem(currecyCredit->id));
				send_keys->setMemberByName("id", currecyCredit->name.Get().c_str());
			}
		}

		bool coming_soon = GetShopManager()->IsComingSoon(shopOffer->id) || std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("coming_soon")) != shopOffer->xtra.end();
		bool stay_tuned = GetShopManager()->IsComingSoon(shopOffer->id) || std::find(shopOffer->xtra.begin(), shopOffer->xtra.end(), StringHash("stay_tuned")) != shopOffer->xtra.end();
		gameswf::ASObject* offer = NULL;
		StringHash stringHash(0);
		int qty = 0, n = 0;
		if (stay_tuned)
		{
			if (added_stay_tuned)
				continue;
			added_stay_tuned = true;
			offer = swfnew gameswf::ASObject(fxPlayer);
			offer->setMemberByName(KSTR("comingSoon"), true);
			stringHash = StringHash("STR_FPS_MENU_FLASH_EVENTS_STAY_TUNED");
		}
		else if ((buyItem.qty > 1) &&
			PLAYER_PROFILE()->GetInventory().HasShopItem(buyItem.item))
		{
			offer = swfnew gameswf::ASObject(fxPlayer);
			gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
			cost->setMemberByName("value", 0);
			std::string hc = "arena_token";
			if (!shopOffer->inItem.empty())
				hc = GetShopManager()->Hash2Name(shopOffer->inItem.front().item);
			offer->setMemberByName(hc.c_str(), cost);
			stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");
			offerHash = buyItem.item;
			offer->setMemberByName("open", true);

			if (coming_soon)
				added_coming_soon = true;

			n = PLAYER_PROFILE()->GetInventory().GetShopItem(buyItem.item);
			qty = std::min(n, 4);
		}
		else
		{
			if (coming_soon)
			{
				if (added_coming_soon)
					continue;
				added_coming_soon = true;
				offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("comingSoon"), true);
				stringHash = StringHash("STR_FPS_MENU_FLASH_EVENTS_COMING_SOON");
			}
			else
			{
				offer = ConstructCostInfo(fxPlayer, shopOffer->id);
				auto currencyCredit = GetShopManager()->FindShopItem(shopOffer->inItem.front().item);
				if (currencyCredit && currencyCredit->category == StringHash("gacha_currency"))
					stringHash = StringHash("STR_UNLOCK_BATTLEPACK");
				else
					stringHash = StringHash("STR_BUY_BATTLEPACK");

				auto& _off = isPremium ? off[Premium] : off[Regular];

				if (!shopOffer->inItemReplaced.empty() &&
					!shopOffer->inItem.empty() &&
					shopOffer->inItem.front().item == shopOffer->inItemReplaced.front().item &&
					shopOffer->inItem.front().qty < shopOffer->inItemReplaced.front().qty)
				{
					auto off = _round(100.f * (1.0f - ((float)shopOffer->inItem.front().qty.Get() / shopOffer->inItemReplaced.front().qty)));
					if (off > _off.off)
						_off.off = off;
				}

				if (_off.off)
				{
					auto tl = GetOfflineItemsTimeLeft(offerHash);
					if (tl > 0 && (_off.timeLeft == 0 || tl < _off.timeLeft))
						_off.timeLeft = tl;
				}
			}
			qty = shopOffer->outItems.front().qty.Get();

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_OFFLINE, shopOffer->id))
			{
				show_description = ESource::Offline;
				descriptionId = shopOffer->id;
			}
		}

		offer->setMemberByName(KSTR("id"), (int)offerHash);
		offer->setMemberByName(KSTR("quantity"), qty);

		static const std::string QTY = "${QTY}";
		static const std::string TOTAL = "${TOTAL}";

		const char* buy_str = GetStringsMgr()->GetStringFromHash(stringHash);
		std::string buy_str_buff(buy_str);

		{
			int pos = buy_str_buff.find(QTY);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, QTY.length(), std::to_string(qty));
			pos = buy_str_buff.find(TOTAL);
			if (pos != std::string::npos)
				buy_str_buff.replace(pos, TOTAL.length(), std::to_string(n));
			offer->setMemberByName(KSTR("name"), buy_str_buff.c_str());
		}

		if (!isPremium)
			offers->push(offer);
		else
			offers_premium->push(offer);
	}

	static const std::string QTY = "QTY";
	static const std::string TOTAL = "TOTAL";
	auto createOffer = [](StringHash id, int n, int nb, gameswf::Player* fxPlayer)
	{
		std::map<std::string, std::string> map;
		map[QTY] = std::to_string(n);
		map[TOTAL] = std::to_string(nb);

		auto stringHash = StringHash("STR_FPS_MENU_FLASH_OPEN_BATTLEPACKS_NUMBER_OF");
		auto msg = StringsManager::FormatStringWithTags(stringHash, map);

		auto offer = swfnew gameswf::ASObject(fxPlayer);
		offer->setMemberByName("id", (int)id.GetHash());
		offer->setMemberByName("name", msg.c_str());
		offer->setMemberByName("quantity", n);
		offer->setMemberByName("open", true);

		gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
		cost->setMemberByName("value", 0);
		std::string hc = "arena_token";
		offer->setMemberByName(hc.c_str(), cost);

		return offer;
	};

	const Json::Value* json = &GetShopManager()->GetGachaMaxChances();
	{
		auto regular = swfnew gameswf::ASObject(fxPlayer);
		data->setMemberByName(KSTR("regular"), regular);

		auto hashPackRegular = StringHash(packID.c_str());
		regular->setMemberByName("name", GetShopManager()->GetShopItemDisplayName(hashPackRegular));
		regular->setMemberByName(KSTR("offers"), offers);
		auto currentValue = GetShopManager()->GetShopItemCurrentValue(hashPackRegular);
		regular->setMemberByName(KSTR("packsAvailable"), currentValue);

		if (off[Regular].off > 0)
		{
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			promo->setMemberByName(KSTR("type"), "shop");
			auto timeLeft = ConstructTimeLeft(off[Regular].timeLeft, fxPlayer);
			if (timeLeft)
			{
				promo->setMemberByName("timeLeft", timeLeft);
			}
			auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
			promo->setMemberByName(KSTR("specialOffer"), specialOffer);
			specialOffer->setMemberByName(KSTR("value"), off[Regular].off);
			specialOffer->setMemberByName(KSTR("type"), "off");

			regular->setMemberByName(KSTR("promo"), promo);
		}
		// --- teasers
		auto teasers = swfnew gameswf::ASArray(fxPlayer);
		Json::Value jTmp;
		const auto& packJson = (*json)[packID];
		IGM_sendMissionCompletedPartsData(packJson, teasers);
		regular->setMemberByName(KSTR("teaser"), teasers);

		regular->setMemberByName(KSTR("id"), packID.c_str());
	}

	////////////PREMIUM PACK  - IAP ////////////

	// --- search IAP
	if (offers_premium->size() == 0)
	{
		bool added_stay_tuned = false;
		for (unsigned i = 0; i != IAP()->GetItemsCount(); ++i)
		{
			const auto crmi = IAP()->GetCRMItem(i);

#if !defined(OS_ANDROID) || USE_IN_APP_BILLING_CRM //truong.px4 add for GAND compile
			if (crmi->IsHidden())
				continue;
#endif

			const std::string& type = crmi->GetType();
			if (crmi->HasBundleItems())
				continue;

			if (crmi->GetBillingMethodCount() < 1)
				continue;

			StringHash hash(type.c_str());

			if (type != premium_packID)
				continue;

			auto credit = GetShopManager()->FindShopItem(hash);
			if (!credit)
				continue;

			bool coming_soon = false;
			bool stay_tuned = false;

			Json::Value jex;
			auto ex = crmi->GetExtendedField("category");
			if (ex.IsValid() && ex.IsJSON())
			{
				auto sjex = ex.ToString();
				Json::Reader rd;
				rd.parse(sjex, jex);

				for (const auto& p : jex)
				{
					if (p.asString() == "stay_tuned")
						stay_tuned = true;
					else if (p.asString() == "coming_soon")
						coming_soon = true;
				}
			}

			auto nb = PLAYER_PROFILE()->GetInventory().GetShopItem(hash);
			auto amount = crmi->GetAmount();

			if (stay_tuned || coming_soon)
			{
				added_stay_tuned = true;
				auto offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName(KSTR("comingSoon"), true);
				offer->setMemberByName("name", GetStringsMgr()->GetStringFromHash(stay_tuned ? StringHash("STR_FPS_MENU_FLASH_EVENTS_STAY_TUNED") : StringHash("STR_FPS_MENU_FLASH_EVENTS_COMING_SOON")));

				gameswf::ASObject* cost = swfnew gameswf::ASObject(fxPlayer);
				cost->setMemberByName("value", 0);
				std::string hc = "arena_token";
				offer->setMemberByName(hc.c_str(), cost);
				offers_premium->push(offer);
				break;
			}

			if (nb >= 1 && amount > 1)
			{
				auto offer = createOffer(hash, std::min(nb, 4), nb, fxPlayer);
				offers_premium->push(offer);
			}
			else
			{
				std::map<std::string, std::string> map;
				map[QTY] = std::to_string(crmi->GetAmount());
				auto msg = StringsManager::FormatStringWithTags(StringHash("STR_BUY_BATTLEPACK"), map);

				auto offer = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("id", (int)StringHash(crmi->GetEntryId()).GetHash());
				offer->setMemberByName("name", msg.c_str());
				offer->setMemberByName("quantity", amount);

				auto money = swfnew gameswf::ASObject(fxPlayer);
				offer->setMemberByName("money", money);
				money->setMemberByName("value", IAP()->GetItemDisplayPrice(crmi).c_str());
				if (crmi->HasPricePromotion())
					money->setMemberByName("oldValue", IAP()->GetItemReplacedDisplayPrice(crmi).c_str());

				int remaining = crmi->GetRemainingPurchaseCount();
				if (remaining > 0)
				{
					offer->setMemberByName("stock", remaining);
					data->setMemberByName("stock", remaining);
				}

				offers_premium->push(offer);

				if (crmi->HasPricePromotion())
				{
					auto price = crmi->GetBillingMethod(0)->GetPrice();
					auto oldPrice = crmi->GetBillingMethod(0)->GetReplacedPrice();
					if (oldPrice > 0)
					{
						auto _off = _round(100.f * (1.0f - (price / oldPrice)));
						if (_off > off[Premium].off)
							off[Premium].off = _off;
					}
				}
			}

			if (GetShopManager()->HasPromoTag(EPROMOTAG_MSG_IAP, IAP()->GetItemHashId(crmi)))
			{
				show_description = ESource::IAP;
				descriptionId = IAP()->GetItemHashId(crmi);
			}
			else
			{
				show_description = GetShopManager()->HasAnyPromoTag(EPROMOTAG_MSG_IAP) ? ESource::None : ESource::IAP;
			}
		}
	}

	if (send_keys)
	{
		data->setMemberByName("keys", send_keys);
	}


	{
		auto premium = swfnew gameswf::ASObject(fxPlayer);
		data->setMemberByName(KSTR("premium"), premium);

		premium->setMemberByName(KSTR("offers"), offers_premium);
		auto hashPack = StringHash(premium_packID.c_str());
		premium->setMemberByName(KSTR("name"), GetShopManager()->GetShopItemDisplayName(hashPack));
		auto currentValue = GetShopManager()->GetShopItemCurrentValue(hashPack);
		premium->setMemberByName(KSTR("packsAvailable"), currentValue);

		if (off[Premium].off > 0)
		{
			auto promo = swfnew gameswf::ASObject(fxPlayer);
			promo->setMemberByName(KSTR("type"), "shop");
			auto timeLeft = ConstructTimeLeft(off[Premium].timeLeft, fxPlayer);
			if (timeLeft)
			{
				promo->setMemberByName("timeLeft", timeLeft);
			}
			auto specialOffer = swfnew gameswf::ASObject(fxPlayer);
			promo->setMemberByName(KSTR("specialOffer"), specialOffer);
			specialOffer->setMemberByName(KSTR("value"), off[Premium].off);
			specialOffer->setMemberByName(KSTR("type"), "off");

			premium->setMemberByName(KSTR("promo"), promo);
		}

		auto premium_teasers = swfnew gameswf::ASArray(fxPlayer);
		const auto& premium_packJson = (*json)[premium_packID];
		IGM_sendMissionCompletedPartsData(premium_packJson, premium_teasers);
		premium->setMemberByName(KSTR("teaser"), premium_teasers);

		premium->setMemberByName(KSTR("id"), premium_packID.c_str());
	}

	switch (show_description)
	{
	case ESource::Offline:
		data->setMemberByName(KSTR("description"), GetShopManager()->GetOfflineItemsPromoDescription(descriptionId));
		break;

	case ESource::IAP:
		data->setMemberByName(KSTR("description"), GetShopManager()->GetIAPPromoDescription(descriptionId));
		break;

	default:
		break;

	}

	int leagueId = -1;
	std::string leagueName;
	if (IsLeagueLocked(packID, leagueId, leagueName))
	{
		std::map<std::string, std::string> vars;
		vars["DIVISION"] = leagueName;
		auto req = GetStringsMgr()->FormatStringWithTags(StringHash("STR_FPS_MENU_FLASH_BATTLE_ROYALE_ARENA_SHOP_DIVISION_PACK_REQUIREMENT"), vars);
		data->setMemberByName(KSTR("requirement"), req.c_str());
	}
	else
	{
		auto pvpmgr = PvpDataManager();

		time_t now = GetShopManager()->GetServerTime();
		int time = pvpmgr->PvpLeagueStartTime(leagueId) * 60 * 60;
		int time_left = now - EloLeaderboard::Get()->GetEloStart();
		if (time_left < time)
		{
			auto timeLeft = ConstructTimeLeft(time - time_left, fxPlayer);
			data->setMemberByName("timeLeft", timeLeft);
		}
	}


	//	auto debugstr = gameswf::toJsonValue(data).toStyledString();
	//	debugstr = debugstr;

	GET_BASE_RETURN(data);
	fx->getStage().dispatchEvent(CPP_SEND_RTPVP_SHOP_PACK_DATA, members, membersLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct MenuMapping
{
	SwfShopMenu menu;
	const char* oldName;
	const char* newName;
};
std::vector<MenuMapping> shopMenuMapping{
	{ SwfShopMenu::Battlepacks,		"menu_BattlePacks",		"menu_Shop_Battle_Packs" },
	{ SwfShopMenu::Bundles,			"menu_BundlesMain",		"menu_Shop_Bundle" },
	{ SwfShopMenu::BlackMarket,		"menu_BlackMarket",		"menu_Shop_Black_Market" },
	{ SwfShopMenu::Credits,			"menu_CreditsMain",		"menu_Shop_Packs" },
	{ SwfShopMenu::CreditsIngame,	"menu_CreditsInGame",	"menu_Shop_Packs_IGM" },
	{ SwfShopMenu::Weapons,			"menu_WeaponsShop",		"menu_Shop_Weapons" },

	{ SwfShopMenu::Daily,			"menu_BundlesMain",		"menu_Shop_Daily" },
	{ SwfShopMenu::Events,			"menu_BundlesMain",		"menu_Shop_Event" },
	{ SwfShopMenu::Rental,			"menu_BundlesMain",		"menu_Shop_Rental" },
};

const char* GetShopMenuName(SwfShopMenu swfMenu)
{
	auto it = std::find_if(shopMenuMapping.begin(), shopMenuMapping.end(), [swfMenu](const MenuMapping& mapping) {return mapping.menu == swfMenu; });
	if (it == shopMenuMapping.end())
	{
		GLF_ASSERTMSG(false, "Could not find shop menu mapping for %d", (int)swfMenu);
		it = shopMenuMapping.begin();
	}

	return GetShopManager()->IsNewShop() ? it->newName : it->oldName;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

